 <!DOCTYPE html> <html style="height:100%;"> <head> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <meta content="text/html; charset=utf-8" http-equiv="Content-Type"> <meta name="format-detection" content="telephone=no"> <style>body{height:100%;max-height:100%;overflow:hidden;font-family:Arial, Helvetica, sans-serif;font-size:9pt;color:black;background:white;MARGIN-TOP:0;MARGIN-LEFT:0;MARGIN-RIGHT:0;-webkit-touch-callout:none;-webkit-user-select:none;-khtml-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;}li{margin:0;padding:0;}label{display:block;color:WindowText;background-color:Window;margin:0;padding:0;width:100%;}label:hover{background-color:Highlight;color:HighlightText;}a:visited{text-decoration:none;color:#0044ff }a:link{text-decoration:none;color:#0044ff }a:hover{color:#aa3322 }h1{font-size:11pt;font-weight:bold;color:black;margin-left:5px;margin-top:10px;margin-bottom:6px;}h2{font-size:9pt;font-weight:bold;color:black;margin-left:6px;margin-top:6px;margin-bottom:0;}p{margin-left:6px;margin-top:4px;margin-bottom:0;margin-right:2px }td{font-size:9pt }th{font-size:9pt }th:hover{cursor:pointer;background:#AAA;}.header{position:fixed;top:0;left:0;right:0;height:67px;background:#6a6960;background:-moz-linear-gradient(-45deg, #6a6960 0%, #42413c 100%);background:-webkit-gradient(linear, left top, right bottom, color-stop(0%,#6a6960), color-stop(100%,#42413c));background:-webkit-linear-gradient(-45deg, #6a6960 0%,#42413c 100%);background:-o-linear-gradient(-45deg, #6a6960 0%,#42413c 100%);background:-ms-linear-gradient(-45deg, #6a6960 0%,#42413c 100%);background:linear-gradient(135deg, #6a6960 0%,#42413c 100%);filter:progid:DXImageTransform.Microsoft.gradient( startColorstr='#6a6960', endColorstr='#42413c',GradientType=1 );}.progressbar{position:fixed;top:67px;left:0;right:0;height:2px;background:#ff9e30;}.in{MARGIN-Left:40px;}.log{background:#bbbab5;}.log1{background:#bbbab5;}.log tbody tr:nth-child(odd){background:#e8eefe;}.fullcell{position:fixed;top:69px;right:0;bottom:0;left:0px;overflow:hidden;}.maincell{position:fixed;top:69px;right:0;bottom:0;left:156px;overflow-y:scroll;overflow-x:hidden;padding:8px;vertical-align:top;}.navbar{position:fixed;top:69px;left:0;bottom:0;width:140px;padding:8px;border-right:2px solid #ff9e30;vertical-align:top;background:#72726f;background:-moz-linear-gradient(45deg, #72726f 0%, #a6a5a0 100%);background:-webkit-gradient(linear, left bottom, right top, color-stop(0%,#72726f), color-stop(100%,#a6a5a0));background:-webkit-linear-gradient(45deg, #72726f 0%,#a6a5a0 100%);background:-o-linear-gradient(45deg, #72726f 0%,#a6a5a0 100%);background:-ms-linear-gradient(45deg, #72726f 0%,#a6a5a0 100%);background:linear-gradient(45deg, #72726f 0%,#a6a5a0 100%);filter:progid:DXImageTransform.Microsoft.gradient( startColorstr='#72726f', endColorstr='#a6a5a0',GradientType=1 );}.nav1{margin-top:0;margin-left:-2px;font-weight:bold;color:black;white-space:nowrap;cursor:pointer;}.nav2{margin-left:32px;margin-top:0;color:black;cursor:pointer;}.r{font-size:11pt;}.r0{background:white }.r1{border-bottom:1px solid gray;text-align:left;}.r2{text-align:left;}.r3{border-bottom:1px solid gray;text-align:left;}.r3:hover{background-color:#83827b;cursor:pointer;}.spread{height:100%;width:100%;background-color:white;}.timer{border:1px solid #abcae1;background-color:#abcae1 }.tm{font-size:7pt }.top1{font-size:14pt;font-weight:bold;color:white;margin-top:11px }.top2{color:white }.warn{font-weight:bold;color:#c00000 }.icon1{width:14px;height:15px;background-repeat:no-repeat;background-image:url("data:image/png;base64,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");}.icon2{width:14px;height:15px;background-repeat:no-repeat;background-image:url("data:image/png;base64,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");}.icon3{width:14px;height:15px;background-repeat:no-repeat;background-image:url("data:image/png;base64,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");}.lockicon{width:8px;height:10px;background-repeat:no-repeat;background-image:url("data:image/gif;base64,R0lGODlhCAAKALMAAAAAAIAAAACAAICAAAAAgIAAgACAgMDAwICAgP8AAAD/AP//AAAA//8A/wD//////yH5BAEAAA0ALAAAAAAIAAoAAAQXsDVEKpKNXIpJ/5KXVaRXkuOZlit6VhEAOw==");display:block;float:left;margin-right:3px;}.itemBar{padding:7px;height:20px;margin-top:4px;margin-right:8px;width:auto;border-radius:8px;background-color:#7e7d74;cursor:pointer }.computeritem{cursor:pointer;width:auto;border-radius:5px;background-color:#a6a5a0;height:28px;margin:4px;padding:2px;}.computeritem:hover{background-color:#83827b;}.us{-webkit-touch-callout:initial;-webkit-user-select:auto;-khtml-user-select:text;-moz-user-select:text;-ms-user-select:text;user-select:text;}</style> <style> .rb{cursor:pointer;cursor:hand;border:none;float:right;font-size:130%;margin-right:4px;}</style> <title id='pagetitle'>Manageability Commander Web Edition</title> </head> <body onunload="cleanup()" style="height:100%;"> <div id="topheader" class="header"> <table style="width:100%;height:55px"> <tr> <td valign="top" nowrap="nowrap"> <p class="top1">Manageability Commander <sup style="font-size:10px">Alpha</sup></p> <p class="top2" id="computername"> </td> <td valign="top"> <img width="166" height="64" align="right" style="border:0" src="data:image/png;base64,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"> </td> </tr> </table> <div class="progressbar"> <div id="progressbar" style="height:2px;width:0%;background-color:red"></div> </div> </div> <div id="messageview" class="fullcell" style="text-align:center;padding-top:100px;font-size:20px"> <span id="messageviewstr">Loading...</span> <br><br><input type='button' value="Close" onclick="disconnect()"> </div> <div id="computerSelector" class="fullcell" style="font-size:20px;display:none"> <div style="background-color:lightgray;height:30px"> &nbsp;<input type="button" value="Add Computer..." style='margin:4px' onclick="addComputer()"> <input id="computerFilter" type="Text" placeholder="Filter" style='margin:4px' onkeyup="computerFilter()"> </div> <div style="position:fixed;top:99px;left:0;right:0;bottom:0;overflow-y:scroll"> <div id="noKnownComputers" style="text-align:center;padding-top:100px;color:gray">No known computers.<br><div style="font-size:12px;margin-top:8px">Press "Add Computer" to start.</div></div> <div id="computerList"></div> </div> </div> <div id="mainview" style="height:100%;display:none"> <div id="leftbar" class="navbar"> <br> <p class="nav1"><a onclick="go(1)">System Status</a></p> <p class="nav1"><a onclick="go(14)">Remote Desktop</a></p> <p class="nav1"><a onclick="go(13)">Serial-over-LAN</a></p> <p class="nav1">Hardware Information</p> <p class="nav2"> <a onclick="go(2)">System</a> <br><a onclick="go(3)">Processor</a> <br><a onclick="go(4)">Memory</a> <br><a onclick="go(5)">Disk</a> </p> <div id="lock6" class="lockicon" style="display:none"></div><p class="nav1"><a onclick="go(6)">Event Log</a></p> <div id="lock15" class="lockicon" style="display:none"></div><p class="nav1"><a onclick="go(15)">Audit Log</a></p> <div id="lock16" class="lockicon" style="display:none"></div><p class="nav1"><a onclick="go(16)">Certificates</a></p> <p class="nav1" style="display:none"><a onclick="go(7)">Power Policies</a></p> <p class="nav1" style="display:none"><a onclick="go(8)">Network Settings</a></p> <p class="nav1" style="display:none"><a onclick="go(9)">IPv6 Network Settings</a></p> <p class="nav1" style="display:none"><a onclick="go(10)">System Name Settings</a></p> <p class="nav1"><a onclick="go(17)">Wireless Settings</a></p> <div id="lock11" class="lockicon" style="display:none"></div><p class="nav1"><a onclick="go(11)">User Accounts</a></p> <p class="nav1"><a onclick="go(12)">WSMAN Browser</a></p> <div style="position:fixed;bottom:6px"> <input type='button' value="Disconnect" onclick="disconnect()" style="width:138px"> </div> </div> <div id="mainarea" class="maincell"> <div id="p0"> <h1>Loading...</h1> </div> <div id="p1" style="display:none"> <h1>System Status</h1> <span id="TableSysStatus"></span> </div> <div id="p2" style="display:none"> <h1 style="margin-bottom:16px">System Information</h1> <span id="TableSysInfo"></span> </div> <div id="p3" style="display:none"> <h1 style="margin-bottom:16px">Processor Information</h1> <span id="TableProcInfo"></span> </div> <div id="p4" style="display:none"> <h1 style="margin-bottom:16px">Memory Information</h1> <span id="TableMemInfo"></span> </div> <div id="p5" style="display:none"> <h1 style="margin-bottom:16px">Disk Information</h1> <span id="TableDiskInfo"></span> </div> <div id="p6" style="display:none"> <h1>Event Log</h1> <span id="TableEventLog"></span> <span id="TableEventLog2"></span> </div> <div id="p7" style="display:none"> <h1>Power Policies</h1> <span id="TablePowerPolicies"></span> </div> <div id="p8" style="display:none"> <h1>Network Settings</h1> <span id="TableIPSettingsSpan"></span> <table id="TableIPSettings" class="log1" cellpadding="0" cellspacing="0" style='width:100%;border-radius:8px;display:none'> <tr><td width='200px'><p></td><td></td></tr> <tr><td style='padding-left:15px' colspan='2'><br>Configure the managed device network settings for this computer.<br></td></tr> <tr><td style='padding-left:30px' colspan='2'><input type="checkbox" id='pingCheck'>Respond to ping<br><br></td></tr> <tr><td class="r1"></td><td class="r1"></td></tr> <tr><td style='padding-left:15px' colspan='2'><br>TCP/IP settings for wired connection<br></td></tr> <tr><td style='padding-left:30px' colspan='2'><input type='radio' name='autoip' style='margin:5px'>Obtain IP settings automatically</td></tr> <tr><td style='padding-left:30px' colspan='2'><input type='radio' name='autoip' style='margin:5px'>Use the following IP settings:</td></tr> <tr><td style='padding-left:60px'><span>IP address:</span></td><td>&nbsp;<input type='text' value='' size="24" maxlength="63"></td></tr> <tr><td style='padding-left:60px'><span>Subnet mask:</span></td><td>&nbsp;<input type='text' value='' size="24" maxlength="63"></td></tr> <tr><td style='padding-left:60px'><span>Gateway address:</span></td><td>&nbsp;<input type='text' value='' size="24" maxlength="63"></td></tr> <tr><td style='padding-left:60px'><span>Preferred DNS address:</span></td><td>&nbsp;<input type='text' value='' size="24" maxlength="63"></td></tr> <tr><td style='padding-left:60px'><span>Alternate DNS address:</span></td><td>&nbsp;<input type='text' value='' size="24" maxlength="63"></td></tr> <tr><td class="r1">&nbsp;</td><td class="r1">&nbsp;</td></tr> <tr><td><input type='button' value='Submit' style='margin:4px;'></td><td></td></tr> </table> </div> <div id="p9" style="display:none"> <h1>IPv6 Network Settings</h1> <span id="TableIPv6SettingsSpan"></span> <table id="TableIPv6Settings" class="log1" cellpadding="0" cellspacing="0" style='width:100%;border-radius:8px;display:none'> <tr><td width='200px'><p></td><td></td></tr> <tr><td style='padding-left:15px' colspan='2'><br>Configure the managed device network settings for this computer.<br></td></tr> <tr><td style='padding-left:15px' colspan='2'><br>TCP/IPV6 settings for wired connection<br></td></tr> <tr><td style='padding-left:30px' colspan='2'><input type="checkbox" id='enableIpv6'>Enable IPv6<br><br></td></tr> <tr><td class="r1"></td><td class="r1"></td></tr> <tr><td style='padding-left:15px' colspan='2'><br>TCP/IPV6 alternate static configuration<br></td></tr> <tr><td style='padding-left:60px'><span>IPv6 address:</span></td><td>&nbsp;<input type='text' value='' size="24" maxlength="63"></td></tr> <tr><td style='padding-left:60px'><span>Gateway address:</span></td><td>&nbsp;<input type='text' value='' size="24" maxlength="63"></td></tr> <tr><td style='padding-left:60px'><span>Preferred DNS address:</span></td><td>&nbsp;<input type='text' value='' size="24" maxlength="63"></td></tr> <tr><td style='padding-left:60px'><span>Alternate DNS address:</span></td><td>&nbsp;<input type='text' value='' size="24" maxlength="63"></td></tr> <tr><td class="r1">&nbsp;</td><td class="r1">&nbsp;</td></tr> <tr><td><input type='button' value='Submit' style='margin:4px;'></td><td></td></tr> </table> </div> <div id="p10" style="display:none"> <h1>System Name Settings</h1> <span id="TableSysName"></span> </div> <div id="p11" style="display:none"> <h1>User Accounts</h1> <span id="TableUserAccounts"></span> </div> <div id="p12" style="display:none"> <h1>WSMAN Browser</h1> <div> <table class="log1" cellpadding="0" cellspacing="0" style='width:100%;border-radius:8px'> <tr> <td> <div style="padding:4px"> <select id="QuerySelect" multiple="multiple" style="width:100%;height:120px"></select> </div> </td> </tr> <tr> <td> <input id="p12querybutton" type="button" value="Query" style='margin:4px' onclick="wsmanQuery()"> <input type="button" value="Clear" style='margin:4px' onclick="QH('wsresults', '');"> <input id="browserFilter" type="Text" placeholder="Filter" style='margin:4px' onkeyup="wsmanFilter()"> </td> </tr> </table> </div> <br> <div class="us" id="wsresults"></div> </div> <div id="p13" style="display:none;min-width:780px"> <h1>Serial-over-LAN Terminal</h1> <br> <div id="p13warning" style='max-width:100%;display:none;cursor:pointer;margin-bottom:5px' onclick="showFeaturesDlg()"> <div class="icon2" style="float:left;margin:7px"></div><div style='width:auto;border-radius:8px;padding:8px;background-color:lightsalmon'>Intel&reg; AMT Redirection port or Serial-over-LAN feature is disabled, click here to enable it.</div> </div> <div id="p13warning2" style='max-width:100%;display:none;cursor:pointer;margin-bottom:5px' onclick="showPowerActionDlg()"> <div class="icon2" style="float:left;margin:7px"></div><div style='width:auto;border-radius:8px;padding:8px;background-color:lightsalmon'>Remote computer is not powered on, click here to issue a power command.</div> </div> <table cellpadding="0" cellspacing="0" style="width:100%;padding:0px;padding:0px;margin-top:0px;"> <tr> <td style="padding-top:2px;padding-bottom:2px;background:#C0C0C0;"> <div style="float:right;text-align:right"> <input type="text" id="Text1" onkeyup="sendTermInputKeys(event)" autocorrect="off" autocapitalize="off" style="opacity:0;width:0;height:0;font-size:1px" onblur="keyInputBlur()"> <span id="p13power"></span>&nbsp; <input type="button" onkeypress="return false" onkeydown="return false" class="cadbutton" value="Power Actions..." onclick="showPowerActionDlg()">&nbsp; </div> <div> &nbsp;<input type="button" id="connectbutton2" value="Connect" onclick="connectTerminal(event);" onkeypress="return false;" onkeydown="return false;" disabled="disabled"> &nbsp;<span id="termstatus">Disconnected.</span> </div> </td> </tr> <tr> <td style="background:#000000;text-align:center"><pre id="Term"></pre></td> </tr> <tr> <td style="padding-top:2px;padding-bottom:2px;background:#C0C0C0;"> <div> &nbsp; <input type="button" onkeypress="return false" onkeydown="return false" class="bottombutton" id="ctrlcbutton" value="Ctl-C" onclick="termSendKey(3)"> <input type="button" onkeypress="return false" onkeydown="return false" class="bottombutton" id="ctrlxbutton" value="Ctl-X" onclick="termSendKey(24)"> <input type="button" onkeypress="return false" onkeydown="return false" class="bottombutton" id="escbutton" value="ESC" onclick="termSendKey(27)"> <input type="button" onkeypress="return false" onkeydown="return false" class="bottombutton" id="bsbutton" value="Backspace" onclick="termSendKey(8)"> <input id="tpastebutton" type="button" onkeypress="return false" onkeydown="return false" class="cadbutton" value="Paste" disabled="disabled" onclick="setDialogMode(3, 'Paste', 3, termPaste)"> </div> </td> </tr> </table> </div> <div id="p14" style="display:none;min-width:780px"> <div id="rdheader"><h1>Remote Desktop</h1><br></div> <div id="p14warning" style='max-width:100%;display:none;cursor:pointer;margin-bottom:5px' onclick="showFeaturesDlg()"> <div class="icon2" style="float:left;margin:7px"></div><div style='width:auto;border-radius:8px;padding:8px;background-color:lightsalmon'>Intel&reg; AMT Redirection port or KVM feature is disabled, click here to enable it.</div> </div> <div id="p14warning2" style='max-width:100%;display:none;cursor:pointer;margin-bottom:5px' onclick="showPowerActionDlg()"> <div class="icon2" style="float:left;margin:7px"></div><div style='width:auto;border-radius:8px;padding:8px;background-color:lightsalmon'>Remote computer is not powered on, click here to issue a power command.</div> </div> <table cellpadding="0" cellspacing="0" style="width:100%;padding:0px;padding:0px;margin-top:0px;"> <tr> <td style="padding-top:2px;padding-bottom:2px;background:#C0C0C0;"> <div style="float:right;text-align:right"> <span id="p14power"></span>&nbsp; <div class='rb' title="Rotate Left" onclick="drotate(-1)">&olarr;</div> <div class='rb' title="Rotate Right" onclick="drotate(1)">&orarr;</div> <input id="deskFocusBtn" type="button" onkeypress="return false" onkeydown="return false" value="Focus All" onclick="deskToggleFocus()">&nbsp; <input id="deskFullBtn" type="button" onkeypress="return false" onkeydown="return false" value="Full" onclick="deskToggleFull()">&nbsp; <input type="button" value="Settings..." onkeypress="return false" onkeydown="return false" onclick="showDesktopSettings()">&nbsp; <input type="button" onkeypress="return false" onkeydown="return false" value="Power Actions..." onclick="showPowerActionDlg()">&nbsp; </div> <div> &nbsp;<input type="button" id="connectbutton1" value="Connect" onclick="connectDesktop(event);" onkeypress="return false" onkeydown="return false" disabled="disabled"> &nbsp;<span id="deskstatus">Disconnected.</span> </div> </td> </tr> <tr> <td style="background:black;text-align:center;height:400px;position:relative"> <div id="DeskFocus" style="color:transparent;border:3px dotted rgba(255,0,0,.2);position:absolute;border-radius:5px" oncontextmenu="return false" onmousedown="dmousedown(event)" onmouseup="dmouseup(event)" onmousemove="dmousemove(event)"></div> <canvas id="Desk" width="640" height="400" style="width:100%;-ms-touch-action:none;margin-left:0px;image-rendering:optimizeSpeed" oncontextmenu="return false" onmousedown="dmousedown(event)" onmouseup="dmouseup(event)" onmousemove="dmousemove(event)"></canvas> </td> </tr> <tr> <td style="padding-top:2px;padding-bottom:2px;background:#C0C0C0;"> <div> &nbsp; <input id="DeskCAD" type="button" value="Ctrl-Alt-Del" onkeypress="return false" onkeydown="return false" onclick="sendCAD()">&nbsp; </div> </td> </tr> </table> </div> <div id="p15" style="display:none"> <h1>Audit Log Settings</h1> <span id="TableAuditLog"></span> <h1>Audit Log</h1> <span id="TableAuditLog1"></span> <span id="TableAuditLog2"></span> </div> <div id="p16" style="display:none"> <h1>Certificates</h1> <span id="TableCerts"></span> </div> <div id="p17" style="display:none"> <span id="TableWifi1"></span> <span id="TableWifi2"></span> </div> </div> </div> <div id="dialog" style="z-index:1000;background-color:#EEEEEE;box-shadow:0px 0px 15px #666666;font-family:Arial, Helvetica, sans-serif;border-radius:5px;position:fixed;top:160px;width:400px;display:none"> <div style="width:100%;background-color:#003366;color:#FFFFFF;border-radius:5px 5px 0 0"> <div style="float:right;padding:5px;cursor:pointer;cursor:hand" onclick="setDialogMode(0)"><b>X</b></div> <div id='dialogtitle' style="padding:5px"></div> <div style="width:100%;margin:6px"></div> </div> <div style="margin-right:16px;margin-left:8px"> <div id="dialog1" style="margin:auto;text-align:center;margin:3px"> <div id="dialogMessage" style="padding:10px"></div> </div> <div id="dialog2" style="margin:auto;margin:3px"> <br> <div style='height:26px'><input id="d2username" type="text" value="" style="float:right;width:200px" onkeyup="updateAccountDialog()"><div>Username</div></div> <div style='height:26px'><input id="d2password1" type="password" value="" style="float:right;width:200px" onkeyup="updateAccountDialog()"><div>Password*</div></div> <div style='height:26px'><input id="d2password2" type="password" value="" style="float:right;width:200px" onkeyup="updateAccountDialog()"><div>Confirm Password</div></div> <div id="d2permissions"> <div style='height:26px'><select id="d2permission" style="float:right;width:200px"><option value="0">Local<option value="1">Network<option value="2">Any</select><div>Permission</div></div> <div>Granted Permissions</div> <ul id="d2realms" style="list-style-type:none;height:100px;overflow:auto;width:100%;border:1px solid #000;background-color:white;overflow-x:hidden;margin:0;padding:0"></ul> </div> <div style="font-size:10px"><br>*Minimum 8 characters with upper and lowercase, 0-9, and one of !@#$%^&*()</div> </div> <div id="dialog3" style="margin:auto;text-align:center;margin:3px"> <textarea id='d3pastetextarea' maxlength="4096" style="width:100%;height:200px;resize:none"></textarea> </div> <div id="dialog4" style="margin:auto;margin:3px"> <br> <div style='height:26px'><input id="d4hostname" type="text" value="" style="float:right;width:200px" onkeyup="updateComputerDialog()"><div>Hostname</div></div> <div style='height:26px'><input id="d4username" type="text" value="admin" style="float:right;width:200px" onkeyup="updateComputerDialog()"><div>Username</div></div> <div style='height:26px'><input id="d4password" type="password" value="" style="float:right;width:200px" onkeyup="updateComputerDialog()"><div>Password*</div></div> <div style='height:26px'><select id="d4security" style="float:right;width:200px"><option value="0">None<option value="1">TLS</select><div>Security</div></div> <div style="font-size:10px"><br>*Minimum 8 characters with upper and lowercase, 0-9, and one of !@#$%^&*()</div> </div> <div id="dialog5" style="margin:auto;margin:3px"> <br> <div style='height:26px'> <select id="d5actionSelect" style="float:right;width:200px"> <option value="2">Power up <option value="5">Power cycle <option value="8">Power down <option value="10">Reset <option value="11">Diagnostic <option id="pa9x1" value="12">Soft-off <option id="pa9x2" value="14">Soft-reset <option id="pa9x3" value="4">Sleep <option id="pa9x4" value="7">Hibernate <option value="100">Power up to BIOS <option value="101">Reset to BIOS <option value="102">Power up to BIOS (SOL) <option value="103">Reset to BIOS (SOL) </select> <div>Power Action</div> </div> </div> <div id="dialog6" style="margin:auto;margin:3px"> <br> <div style='height:26px'><input id="d6ConsentText" type="text" value="" style="float:right;width:200px" maxlength="6" onkeyup="consentChanged();"><div>Consent Code</div></div> <div style='height:26px'><select id="d6Display" onchange="changeConsentDisplay()" style="float:right;width:200px"><option value="0">Primary display<option value="1">Secondary display<option id="d6ThirdDisplay" value="2" style="display:none">Third display</select><div>Consent Display</div></div> </div> <div id="dialog7" style="margin:auto;margin:3px"> <br> <div style='height:26px'> <select id="d7desktopmode" style="float:right;width:200px"> <option value="1">RLE8, Fastest <option value="2">RLE16, Recommended <option value="3">RAW8, Slow <option value="4">RAW16, Very Slow </select> <div>Image Encoding</div> </div> <div style="height:60px"> <div style="float:right;border:1px solid #666;width:200px;height:60px;overflow-y:scroll;background-color:white"> <input type="checkbox" id='d7showfocus'>Show Focus Tool<br> <input type="checkbox" id='d7showcursor'>Show Local Mouse Cursor<br> <input type="checkbox" id='d7showcad'>Show Ctrl-Alt-Del<br> </div> <div>Other Settings</div> </div> </div> <div id="dialog8" style="display:table;margin:3px"> <div style="margin:3px 0 3px 0;padding-top:5px"> <input id="d8username" type="text" value="admin" style="float:right;width:220px;"> <div style="height:20px">Username</div> </div> <div style="margin:3px 0 3px 0"> <input id="d8password" type="password" autocomplete="off" style="float:right;width:220px;"> <div style="height:20px">Password</div> </div> </div> <div id="dialog9" style="margin:auto;margin:3px"> <input type="checkbox" id='d9redir'>Redirection Port<br> <input type="checkbox" id='d9kvm'>KVM Remote Desktop<br> <input type="checkbox" id='d9ider'>IDE-Redirection<br> <input type="checkbox" id='d9sol'>Serial-over-LAN<br> </div> <div id="dialog10" style="margin:auto;margin:3px"> <input type="radio" name="d10" id='d10none' value="0">Not Required<br> <input type="radio" name="d10" id='d10kvm' value="1">Required for KVM only<br> <input type="radio" name="d10" id='d10all' value="4294967295">Always Required<br> </div> <div id="dialog11" style="margin:auto;margin:3px"> <div id="dialogOptions"></div> </div> <div id="dialog12" style="margin:auto;margin:3px"> <br> <div style='height:26px'><input id="d12name" type="text" value="" style="float:right;width:200px" onkeyup="updateWifiDialog()"><div>Profile Name</div></div> <div style='height:26px'><input id="d12ssid" type="text" value="" style="float:right;width:200px" onkeyup="updateWifiDialog()"><div>SSID</div></div> <div style='height:26px'> <select id="d12pri" style="float:right;width:200px" onclick="updateWifiDialog()"></select> <div>Priority</div> </div> <div style='height:26px'> <select id="d12auth" style="float:right;width:200px" onclick="updateWifiDialog()"> <option value="4">WPA PSK <option value="6">WPA2 PSK </select> <div>Authentication</div> </div> <div style='height:26px'> <select id="d12enc" style="float:right;width:200px" onclick="updateWifiDialog()"> <option id="d12e4" value="4">CCMP-AES <option id="d12e3" value="3">TKIP-RC4 <option id="d12e2" value="2">WEP <option id="d12e5" value="5">None </select> <div>Encryption</div> </div> <div style='height:26px'><input id="d12password1" type="password" value="" style="float:right;width:200px" onkeyup="updateWifiDialog()"><div>Password*</div></div> <div style='height:26px'><input id="d12password2" type="password" value="" style="float:right;width:200px" onkeyup="updateWifiDialog()"><div>Confirm Password</div></div> </div> </div> <div style="padding:10px;margin-bottom:4px"> <input id="dlgCancelButton" type="button" value="Cancel" style="float:right;width:80px;margin-left:5px" onclick="dialogclose(0)"> <input id="dlgOkButton" type="button" value="OK" style="float:right;width:80px" onclick="dialogclose(1)"> <div>&nbsp;</div> </div> </div> </body> </html><script type="text/javascript">/** 
* @description WSMAN communication using websocket
* @author Ylian Saint-Hilaire
* @version v0.1.1
*/

// Construct a WSMAN communication object
var CreateWsmanComm = function (host, port, user, pass, tls) {
    var obj = {};
    obj.PendingAjax = [];               // List of pending AJAX calls. When one frees up, another will start.
    obj.ActiveAjaxCount = 0;            // Number of currently active AJAX calls
    obj.MaxActiveAjaxCount = 1;         // Maximum number of activate AJAX calls at the same time.
    obj.FailAllError = 0;               // Set this to non-zero to fail all AJAX calls with that error status.
    obj.challengeParams = null;
    obj.noncecounter = 1;
    obj.authcounter = 0;
    obj.socket = null;
    obj.socketState = 0;
    obj.host = host;
    obj.port = port;
    obj.user = user;
    obj.pass = pass;
    obj.tls = tls;
    obj.cnonce = 'ABCD';

    // Private method
    obj.Debug = function (msg) { /*console.log(msg);*/ }

    // Private method
    //   pri = priority, if set to 1, the call is high priority and put on top of the stack.
    obj.PerformAjax = function (postdata, callback, tag, pri) {
        if (obj.ActiveAjaxCount < obj.MaxActiveAjaxCount) {
            obj.PerformAjaxEx(postdata, callback, tag);
        } else {
            if (pri == 1) { obj.PendingAjax.unshift([postdata, callback, tag]); } else { obj.PendingAjax.push([postdata, callback, tag]); }
        }
    }

    // Private method
    obj.PerformNextAjax = function () {
        if (obj.ActiveAjaxCount >= obj.MaxActiveAjaxCount || obj.PendingAjax.length == 0) return;
        var x = obj.PendingAjax.shift();
        obj.PerformAjaxEx(x[0], x[1], x[2]);
        obj.PerformNextAjax();
    }

    // Private method
    obj.PerformAjaxEx = function (postdata, callback, tag) {
        if (obj.FailAllError != 0) { obj.gotNextMessagesError({ status: obj.FailAllError }, 'error', null, [postdata, callback, tag]); return; }
        if (!postdata) postdata = "";
        // console.log("SEND: " + postdata); // DEBUG

        // We are in a websocket relay environment 
        obj.ActiveAjaxCount++;
        return obj.PerformAjaxExNodeJS(postdata, callback, tag);
    }

    // Websocket relay specific private method
    obj.pendingAjaxCall = [];

    // Websocket relay specific private method
    obj.PerformAjaxExNodeJS = function (postdata, callback, tag) { obj.PerformAjaxExNodeJS2(postdata, callback, tag, 5); }

    // Websocket relay specific private method
    obj.PerformAjaxExNodeJS2 = function (postdata, callback, tag, retry) {
        if (retry <= 0) {
            // Too many retry, fail here.
            obj.ActiveAjaxCount--;
            obj.gotNextMessages(null, 'error', { status: 408 }, [postdata, callback, tag]); // 408 is timeout error
            obj.PerformNextAjax();
            return;
        }
        obj.pendingAjaxCall.push([postdata, callback, tag, retry]);
        if (obj.socketState == 0) { obj.xxConnectHttpSocket(); }
        else if (obj.socketState == 2) { obj.sendRequest(postdata); }
    }

    // Websocket relay specific private method
    obj.sendRequest = function (postdata) {
        var h = "POST /wsman HTTP/1.1\r\nConnection: keep-alive\r\nTransfer-Encoding: chunked\r\n";
        if (obj.challengeParams != null) {
            var response = hex_md5(hex_md5(obj.user + ':' + obj.challengeParams["realm"] + ':' + obj.pass) + ':' + obj.challengeParams["nonce"] + ':' + obj.noncecounter + ':' + obj.cnonce + ':' + obj.challengeParams["qop"] + ':' + hex_md5('POST:/wsman'));
            h += 'Authorization: ' + obj.renderDigest({ "username": obj.user, "realm": obj.challengeParams["realm"], "nonce": obj.challengeParams["nonce"], "uri": "/wsman", "qop": obj.challengeParams["qop"], "response": response, "nc": obj.noncecounter++, "cnonce": obj.cnonce }) + '\r\n';
        }
        h += "\r\n" + obj.xxEncodeChunk(postdata) + obj.xxEncodeChunk('');
        obj.xxSend(h);
        obj.Debug("SEND: " + h); // Display send packet
    }

    // Websocket relay specific private method
    obj.parseDigest = function (header) {
        var t = header.substring(7).split(',');
        for (i in t) t[i] = t[i].trim();
        return t.reduce(function (obj, s) { var parts = s.split('='); obj[parts[0]] = parts[1].replace(/"/g, ''); return obj; }, {})
    }

    // Websocket relay specific private method
    obj.renderDigest = function (params) {
        var paramsnames = [];
        for (i in params) { paramsnames.push(i); }
        return 'Digest ' + paramsnames.reduce(function (s1, ii) { return s1 + ', ' + ii + '="' + params[ii] + '"' }, '').substring(2);
    }

    // Websocket relay specific private method
    obj.xxConnectHttpSocket = function () {
        // obj.Debug("xxConnectHttpSocket");
        obj.socketParseState = 0;
        obj.socketAccumulator = '';
        obj.socketHeader = null;
        obj.socketData = '';
        obj.socketState = 1;

        obj.socket = new WebSocket(window.location.protocol.replace("http", "ws") + "//" + window.location.host + window.location.pathname.substring(0, window.location.pathname.lastIndexOf('/')) + "/webrelay.ashx?p=1&host=" + obj.host + "&port=" + obj.port + "&tls=" + obj.tls + ((user == '*') ? "&serverauth=1" : "")); // The "p=1" indicates to the relay that this is a WSMAN session
        obj.socket.onopen = obj.xxOnSocketConnected;
        obj.socket.onmessage = obj.xxOnMessage;
        obj.socket.onclose = obj.xxOnSocketClosed;
    }

    // Websocket relay specific private method
    obj.xxOnSocketConnected = function () {
        // obj.Debug("xxOnSocketConnected");
        obj.socketState = 2;
        for (i in obj.pendingAjaxCall) { obj.sendRequest(obj.pendingAjaxCall[i][0]); }
    }

    obj.xxOnMessage = function (e) {
        if (typeof e.data == 'object') {
            var f = new FileReader();
            if (f.readAsBinaryString) {
                // Chrome & Firefox (Draft)
                f.onload = function (e) { obj.xxOnSocketData(e.target.result); }
                f.readAsBinaryString(new Blob([e.data]));
            } else if (f.readAsArrayBuffer) {
                // Chrome & Firefox (Spec)
                f.onloadend = function (e) { obj.xxOnSocketData(e.target.result); }
                f.readAsArrayBuffer(e.data);
            } else {
                // IE10, readAsBinaryString does not exist, use an alternative.
                var binary = "";
                var bytes = new Uint8Array(e.data);
                var length = bytes.byteLength;
                for (var i = 0; i < length; i++) { binary += String.fromCharCode(bytes[i]); }
                obj.xxOnSocketData(binary);
            }
        } else {
            // If we get a string object, it maybe the WebRTC confirm. Ignore it.
            //obj.debug("MeshDataChannel - OnData - " + typeof e.data + " - " + e.data.length);
        }
    };

    // Websocket relay specific private method
    obj.xxOnSocketData = function (data) {
        // obj.Debug("xxOnSocketData (" + data.length + "): " + data);

        if (typeof data === 'object') {
            // This is an ArrayBuffer, convert it to a string array (used in IE)
            var binary = "";
            var bytes = new Uint8Array(data);
            var length = bytes.byteLength;
            for (var i = 0; i < length; i++) { binary += String.fromCharCode(bytes[i]); }
            data = binary;
        }
        else if (typeof data !== 'string') { return; }

        obj.socketAccumulator += data;
        while (true) {
            if (obj.socketParseState == 0) {
                var headersize = obj.socketAccumulator.indexOf("\r\n\r\n");
                if (headersize == -1) break;
                //obj.Debug(obj.socketAccumulator.substring(0, headersize)); // Display received HTTP header
                obj.socketHeader = obj.socketAccumulator.substring(0, headersize).split("\r\n");
                obj.socketAccumulator = obj.socketAccumulator.substring(headersize + 4);
                obj.socketParseState = 1;
                obj.socketData = '';
                obj.socketXHeader = { Directive: obj.socketHeader[0].split(' ') };
                for (i in obj.socketHeader) {
                    if (i == 0) continue;
                    var x2 = obj.socketHeader[i].indexOf(':');
                    obj.socketXHeader[obj.socketHeader[i].substring(0, x2).toLowerCase()] = obj.socketHeader[i].substring(x2 + 2);
                }
            }
            if (obj.socketParseState == 1) {
                var csize = -1;
                if (obj.socketXHeader["content-length"] != undefined) {
                    // The body length is specified by the content-length
                    csize = parseInt(obj.socketXHeader["content-length"]);
                    if (obj.socketAccumulator.length < csize) break;
                    var data = obj.socketAccumulator.substring(0, csize);
                    obj.socketAccumulator = obj.socketAccumulator.substring(csize);
                    obj.socketData = data;
                    csize = 0;
                } else {
                    // The body is chunked
                    var clen = obj.socketAccumulator.indexOf("\r\n");
                    if (clen == -1) break;
                    csize = parseInt(obj.socketAccumulator.substring(0, clen), 16);
                    if (obj.socketAccumulator.length < clen + 2 + csize) break;
                    var data = obj.socketAccumulator.substring(clen + 2, clen + 2 + csize);
                    obj.socketAccumulator = obj.socketAccumulator.substring(clen + 2 + csize + 2);
                    obj.socketData += data;
                }
                if (csize == 0) {
                    obj.Debug("xxOnSocketData DONE: (" + obj.socketData.length + "): " + obj.socketData);
                    obj.xxProcessHttpResponse(obj.socketXHeader, obj.socketData);
                    obj.socketParseState = 0;
                    obj.socketHeader = null;
                }
            }
        }
    }

    // Websocket relay specific private method
    obj.xxProcessHttpResponse = function (header, data) {
        //obj.Debug("xxProcessHttpResponse: " + header.Directive[1]);

        var s = parseInt(header.Directive[1]);
        if (isNaN(s)) s = 500;
        if (s == 401 && ++(obj.authcounter) < 3) {
            obj.challengeParams = obj.parseDigest(header['www-authenticate']); // Set the digest parameters, after this, the socket will close and we will auto-retry
        } else {
            var r = obj.pendingAjaxCall.shift();
            // if (s != 200) { obj.Debug("Error, status=" + s + "\r\n\r\nreq=" + r[0] + "\r\n\r\nresp=" + data); } // Debug: Display the request & response if something did not work.
            obj.authcounter = 0;
            obj.ActiveAjaxCount--;
            obj.gotNextMessages(data, 'success', { status: s }, r);
            obj.PerformNextAjax();
        }
    }

    // Websocket relay specific private method
    obj.xxOnSocketClosed = function (data) {
        // obj.Debug("xxOnSocketClosed");
        obj.socketState = 0;
        if (obj.socket != null) { obj.socket.close(); obj.socket = null; }
        if (obj.pendingAjaxCall.length > 0) {
            var r = obj.pendingAjaxCall.shift();
            var retry = r[3];
            obj.PerformAjaxExNodeJS2(r[0], r[1], r[2], --retry);
        }
    }

    // Websocket relay specific private method
    obj.xxEncodeChunk = function (x) { return x.length.toString(16) + '\r\n' + x + '\r\n'; }

    // Websocket relay specific private method
    obj.xxSend = function (x) { if (obj.socketState == 2 && obj.socket != null && obj.socket.readyState == WebSocket.OPEN) { obj.socket.send(x); } }

    // Private method
    obj.gotNextMessages = function (data, status, request, callArgs) {
        if (request.status != 200) { callArgs[1](null, request.status, callArgs[2]); return; }
        callArgs[1](data, 200, callArgs[2]);
    }

    // Private method
    obj.gotNextMessagesError = function (request, status, errorThrown, callArgs) {
        if (obj.FailAllError != 999) { callArgs[1](obj, null, { Header: { HttpError: request.status } }, request.status, callArgs[2]); }
    }

    // Private method
    obj.gotAccessError = function (request, status, errorThrown) {
        alert("gotAccessError: " + status);
    }

    // Cancel all pending queries with given status
    obj.CancelAllQueries = function (s) {
        while (obj.PendingAjax.length > 0) { var x = obj.PendingAjax.shift(); x[1](null, s, x[2]); }
    }

    return obj;
}

/** 
* @description Intel AMT Redirection Transport Module - using websocket relay
* @author Ylian Saint-Hilaire
* @version v0.0.1
*/

// Construct a MeshServer object
var CreateAmtRedirect = function (module) {
    var obj = {};
    obj.m = module; // This is the inner module (Terminal or Desktop)
    module.parent = obj;
    obj.State = 0;
    obj.socket = null;
    
    obj.host = null;
    obj.port = 0;
    obj.user = null;
    obj.pass = null;
    obj.authuri = "/RedirectionService";
    
    obj.connectstate = 0;
    obj.protocol = module.protocol; // 1 = SOL, 2 = KVM

    obj.amtaccumulator = "";
    obj.amtsequence = 1;
    obj.amtkeepalivetimer = null;

    obj.onStateChanged = null;

    // Private method
    obj.Debug = function (msg) { console.log(msg); }

    
    obj.Start = function (host, port, user, pass, tls) {
        obj.host = host;
        obj.port = port;
        obj.user = user;
        obj.pass = pass;
        obj.socket = new WebSocket(window.location.protocol.replace("http", "ws") + "//" + window.location.host + window.location.pathname.substring(0, window.location.pathname.lastIndexOf('/')) + "/webrelay.ashx?p=2&host=" + host + "&port=" + port + "&tls=" + tls + ((user == '*') ? "&serverauth=1" : "")); // The "p=2" indicates to the relay that this is a REDIRECTION session
        obj.socket.onopen = obj.xxOnSocketConnected;
        obj.socket.onmessage = obj.xxOnMessage;
        obj.socket.onclose = obj.xxOnSocketClosed;
        obj.xxStateChange(1);
    }
    

    

    obj.xxOnSocketConnected = function() {
        // obj.Debug("Socket Connected");
        obj.xxStateChange(2);
        if (obj.protocol == 1) obj.xxSend(obj.RedirectStartSol); else obj.xxSend(obj.RedirectStartKvm);
    }

    obj.xxOnMessage = function (e) {
        if (typeof e.data == 'object') {
            var f = new FileReader();
            if (f.readAsBinaryString) {
                // Chrome & Firefox (Draft)
                f.onload = function (e) { obj.xxOnSocketData(e.target.result); }
                f.readAsBinaryString(new Blob([e.data]));
            } else if (f.readAsArrayBuffer) {
                // Chrome & Firefox (Spec)
                f.onloadend = function (e) { obj.xxOnSocketData(e.target.result); }
                f.readAsArrayBuffer(e.data);
            } else {
                // IE10, readAsBinaryString does not exist, use an alternative.
                var binary = "";
                var bytes = new Uint8Array(e.data);
                var length = bytes.byteLength;
                for (var i = 0; i < length; i++) { binary += String.fromCharCode(bytes[i]); }
                obj.xxOnSocketData(binary);
            }
        } else {
            // If we get a string object, it maybe the WebRTC confirm. Ignore it.
            // obj.debug("MeshDataChannel - OnData - " + typeof e.data + " - " + e.data.length);
        }
    };
   
    obj.xxOnSocketData = function (data) {
        if (!data) return;

        if (typeof data === 'object') {
            // This is an ArrayBuffer, convert it to a string array (used in IE)
            var binary = "";
            var bytes = new Uint8Array(data);
            var length = bytes.byteLength;
            for (var i = 0; i < length; i++) { binary += String.fromCharCode(bytes[i]); }
            data = binary;
        }
        else if (typeof data !== 'string') { return; }

        if (obj.protocol == 2 && obj.connectstate == 1) { return obj.m.ProcessData(data); } // KVM traffic, forward it directly.
        obj.amtaccumulator += data;
        // obj.Debug("Recv(" + obj.amtaccumulator.length + "): " + rstr2hex(obj.amtaccumulator));
        while (obj.amtaccumulator.length >= 1) {
            var cmdsize = 0;
            switch (obj.amtaccumulator.charCodeAt(0)) {
                case 0x11: // StartRedirectionSessionReply (17)
                    if (obj.amtaccumulator.length < 4) return;
                    var statuscode = obj.amtaccumulator.charCodeAt(1);
                    switch (statuscode) {
                        case 0: // STATUS_SUCCESS
                            if (obj.amtaccumulator.length < 13) return;
                            var oemlen = obj.amtaccumulator.charCodeAt(12);
                            if (obj.amtaccumulator.length < 13 + oemlen) return;
                            obj.xxSend(String.fromCharCode(0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00)); // Query authentication support
                            cmdsize = (13 + oemlen);
                            break;
                        default:
                            obj.Stop();
                            break;
                    }
                    break;
                case 0x14: // AuthenticateSessionReply (20)
                    if (obj.amtaccumulator.length < 9) return;
                    var authDataLen = ReadIntX(obj.amtaccumulator, 5);
                    if (obj.amtaccumulator.length < 9 + authDataLen) return;
                    var status = obj.amtaccumulator.charCodeAt(1);
                    var authType = obj.amtaccumulator.charCodeAt(4);
                    var authData = [];
                    for (i = 0; i < authDataLen; i++) { authData.push(obj.amtaccumulator.charCodeAt(9 + i)); }
                    var authDataBuf = obj.amtaccumulator.substring(9, 9 + authDataLen);
                    cmdsize = 9 + authDataLen;
                    if (authType == 0) {
                        // Query
                        
                        if (authData.indexOf(4) >= 0) {
                            // Good Digest Auth (With cnonce and all)
                            obj.xxSend(String.fromCharCode(0x13, 0x00, 0x00, 0x00, 0x04) + IntToStrX(obj.user.length + obj.authuri.length + 8) + String.fromCharCode(obj.user.length) + obj.user + String.fromCharCode(0x00, 0x00) + String.fromCharCode(obj.authuri.length) + obj.authuri + String.fromCharCode(0x00, 0x00, 0x00, 0x00));
                        }
                        else if (authData.indexOf(3) >= 0) {
                            // Bad Digest Auth (Not sure why this is supported, cnonce is not used!)
                            obj.xxSend(String.fromCharCode(0x13, 0x00, 0x00, 0x00, 0x03) + IntToStrX(obj.user.length + obj.authuri.length + 7) + String.fromCharCode(obj.user.length) + obj.user + String.fromCharCode(0x00, 0x00) + String.fromCharCode(obj.authuri.length) + obj.authuri + String.fromCharCode(0x00, 0x00, 0x00));
                        }
                        else if (authData.indexOf(1) >= 0) {
                            // Basic Auth (Probably a good idea to not support this unless this is an old version of Intel AMT)
                            obj.xxSend(String.fromCharCode(0x13, 0x00, 0x00, 0x00, 0x01) + IntToStrX(obj.user.length + obj.pass.length + 2) + String.fromCharCode(obj.user.length) + obj.user + String.fromCharCode(obj.pass.length) + obj.pass);
                        }
                        else obj.Stop();
                        
                        
                    }
                    
                    else if ((authType == 3 || authType == 4) && status == 1) {
                        var curptr = 0;

                        // Realm
                        var realmlen = authDataBuf.charCodeAt(curptr);
                        var realm = authDataBuf.substring(curptr + 1, curptr + 1 + realmlen);
                        curptr += (realmlen + 1);

                        // Nonce
                        var noncelen = authDataBuf.charCodeAt(curptr);
                        var nonce = authDataBuf.substring(curptr + 1, curptr + 1 + noncelen);
                        curptr += (noncelen + 1);

                        // QOP
                        var qoplen = 0;
                        var qop = null;
                        var cnonce = obj.xxRandomNonce(32);
                        var snc = '00000002';
                        var extra = '';
                        if (authType == 4) {
                            qoplen = authDataBuf.charCodeAt(curptr);
                            qop = authDataBuf.substring(curptr + 1, curptr + 1 + qoplen);
                            curptr += (qoplen + 1);
                            extra = snc + ":" + cnonce + ":" + qop + ":";
                        }

                        var digest = hex_md5(hex_md5(obj.user + ":" + realm + ":" + obj.pass) + ":" + nonce + ":" + extra + hex_md5("POST:" + obj.authuri));
                        var totallen = obj.user.length + realm.length + nonce.length + obj.authuri.length + cnonce.length + snc.length + digest.length + 7;
                        if (authType == 4) totallen += (qop.length + 1);
                        var buf = String.fromCharCode(0x13, 0x00, 0x00, 0x00, authType) + IntToStrX(totallen) + String.fromCharCode(obj.user.length) + obj.user + String.fromCharCode(realm.length) + realm + String.fromCharCode(nonce.length) + nonce + String.fromCharCode(obj.authuri.length) + obj.authuri + String.fromCharCode(cnonce.length) + cnonce + String.fromCharCode(snc.length) + snc + String.fromCharCode(digest.length) + digest;
                        if (authType == 4) buf += (String.fromCharCode(qop.length) + qop);
                        obj.xxSend(buf);
                    }
                    
                    else if (status == 0) { // Success
                        if (obj.protocol == 1) {
                            // Serial-over-LAN: Send Intel AMT serial settings...
                            var MaxTxBuffer = 10000;
                            var TxTimeout = 100;
                            var TxOverflowTimeout = 0;
                            var RxTimeout = 10000;
                            var RxFlushTimeout = 100;
                            var Heartbeat = 0;//5000;
                            obj.xxSend(String.fromCharCode(0x20, 0x00, 0x00, 0x00) + IntToStrX(obj.amtsequence++) + ShortToStrX(MaxTxBuffer) + ShortToStrX(TxTimeout) + ShortToStrX(TxOverflowTimeout) + ShortToStrX(RxTimeout) + ShortToStrX(RxFlushTimeout) + ShortToStrX(Heartbeat) + IntToStrX(0));
                        }
                        if (obj.protocol == 2) {
                            // Remote Desktop: Send traffic directly...
                            obj.xxSend(String.fromCharCode(0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00));
                        }
                    } else obj.Stop();
                    break;
                case 0x21: // Response to settings (33)
                    if (obj.amtaccumulator.length < 23) break;
                    cmdsize = 23;
                    obj.xxSend(String.fromCharCode(0x27, 0x00, 0x00, 0x00) + IntToStrX(obj.amtsequence++) + String.fromCharCode(0x00, 0x00, 0x1B, 0x00, 0x00, 0x00));
                    if (obj.protocol == 1) { obj.amtkeepalivetimer = setInterval(obj.xxSendAmtKeepAlive, 2000); }
                    obj.connectstate = 1;
                    obj.xxStateChange(3);
                    break;
                case 0x29: // Serial Settings (41)
                    if (obj.amtaccumulator.length < 10) break;
                    cmdsize = 10;
                    break;
                case 0x2A: // Incoming display data (42)
                    if (obj.amtaccumulator.length < 10) break;
                    var cs = (10 + ((obj.amtaccumulator.charCodeAt(9) & 0xFF) << 8) + (obj.amtaccumulator.charCodeAt(8) & 0xFF));
                    if (obj.amtaccumulator.length < cs) break;
                    obj.m.ProcessData(obj.amtaccumulator.substring(10, cs));
                    cmdsize = cs;
                    break;
                case 0x2B: // Keep alive message (43)
                    if (obj.amtaccumulator.length < 8) break;
                    cmdsize = 8;
                    break;
                case 0x41:
                    if (obj.amtaccumulator.length < 8) break;
                    obj.connectstate = 1;
                    obj.m.Start();
                    // KVM traffic, forward rest of accumulator directly.
                    if (obj.amtaccumulator.length > 8) { obj.m.ProcessData(obj.amtaccumulator.substring(8)); }
                    cmdsize = obj.amtaccumulator.length;
                    break;
                default:
                    console.log("Unknown Intel AMT command: " + obj.amtaccumulator.charCodeAt(0) + " acclen=" + obj.amtaccumulator.length);
                    obj.Stop();
                    return;
            }
            if (cmdsize == 0) return;
            obj.amtaccumulator = obj.amtaccumulator.substring(cmdsize);
        }
    }
    
    obj.xxSend = function (x) {
        // obj.Debug("Send(" + x.length + "): " + rstr2hex(x));
        if (obj.socket != null && obj.socket.readyState == WebSocket.OPEN) {
            var b = new Uint8Array(x.length);
            for (var i = 0; i < x.length; ++i) { b[i] = x.charCodeAt(i); }
            obj.socket.send(b.buffer);
        }
    }

    obj.Send = function (x) {
        if (obj.socket == null || obj.connectstate != 1) return;
        if (obj.protocol == 1) { obj.xxSend(String.fromCharCode(0x28, 0x00, 0x00, 0x00) + IntToStrX(obj.amtsequence++) + ShortToStrX(x.length) + x); } else { obj.xxSend(x); }
    }

    obj.xxSendAmtKeepAlive = function () {
        if (obj.socket == null) return;
        obj.xxSend(String.fromCharCode(0x2B, 0x00, 0x00, 0x00) + IntToStrX(obj.amtsequence++));
    }

    obj.xxRandomNonceX = "abcdef0123456789";
    obj.xxRandomNonce = function (length) {
        var r = "";
        for (var i = 0; i < length; i++) { r += obj.xxRandomNonceX.charAt(Math.floor(Math.random() * obj.xxRandomNonceX.length)); }
        return r;
    }

    obj.xxOnSocketClosed = function () {
        // obj.Debug("Socket Closed");
        obj.Stop();
    }

    obj.xxStateChange = function(newstate) {
        if (obj.State == newstate) return;
        obj.State = newstate;
        obj.m.xxStateChange(obj.State);
        if (obj.onStateChanged != null) obj.onStateChanged(obj, obj.State);
    }

    obj.Stop = function () {
        // obj.Debug("Socket Stopped");
        obj.xxStateChange(0);
        obj.connectstate = 0;
        obj.amtaccumulator = "";
        if (obj.socket != null) { obj.socket.close(); obj.socket = null; }
        if (obj.amtkeepalivetimer != null) { clearInterval(obj.amtkeepalivetimer); obj.amtkeepalivetimer = null; }
    }

    obj.RedirectStartIder = String.fromCharCode(0x10, 0x00, 0x00, 0x00, 0x52, 0x45, 0x44, 0x49);
    obj.RedirectStartSol = String.fromCharCode(0x10, 0x00, 0x00, 0x00, 0x53, 0x4F, 0x4C, 0x20);
    obj.RedirectStartKvm = String.fromCharCode(0x10, 0x01, 0x00, 0x00, 0x4b, 0x56, 0x4d, 0x52);

    return obj;
}
/** 
* @description WSMAN Stack
* @author Ylian Saint-Hilaire
* @version v0.0.11
*/

// Construct a MeshServer object
var WsmanStackCreateService = function (host, port, user, pass, tls, extra) {
    var obj = {};
    obj.onDebugMessage = null;          // Set to a function if you want to get debug messages.
    obj.NextMessageId = 1;              // Next message number, used to label WSMAN calls.
    obj.Address = '/wsman';
    obj.comm = CreateWsmanComm(host, port, user, pass, tls, extra);

    obj.PerformAjax = function (postdata, callback, tag, pri) {
        obj.comm.PerformAjax('<?xml version=\"1.0\" encoding=\"utf-8\"?><Envelope xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\" xmlns:a="http://schemas.xmlsoap.org/ws/2004/08/addressing" xmlns:w="http://schemas.dmtf.org/wbem/wsman/1/wsman.xsd" xmlns=\"http://www.w3.org/2003/05/soap-envelope\"><Header><a:Action>' + postdata, function (data, status, tag) {
            if (status != 200) { callback(obj, null, { Header: { HttpError: status } }, status, tag); return; }
            var wsresponse = obj.ParseWsman(data);
            if (!wsresponse || wsresponse == null) { callback(obj, null, { Header: { HttpError: status } }, 601, tag); } else { callback(obj, wsresponse.Header["ResourceURI"], wsresponse, 200, tag); }
        }, tag, pri);
    }

    // Private method
    obj.Debug = function (msg) { /*console.log(msg);*/ }

    // Cancel all pending queries with given status
    obj.CancelAllQueries = function (s) { obj.comm.CancelAllQueries(s); }

    // Get the last element of a URI string
    obj.GetNameFromUrl = function (resuri) {
        var x = resuri.lastIndexOf("/");
        return (x == -1)?resuri:resuri.substring(x + 1);
    }

    // Perform a WSMAN PUT operation
    obj.ExecPut = function (resuri, putobj, callback, tag, pri) {
        var objname = obj.GetNameFromUrl(resuri), selector = "";
        if (putobj.InstanceID) selector = "<w:SelectorSet><w:Selector Name=\"InstanceID\">" + putobj.InstanceID + "</w:Selector></w:SelectorSet>";
		else selector = obj.xxPutObjToSelectorsXml(putobj);
        var data = "http://schemas.xmlsoap.org/ws/2004/09/transfer/Put</a:Action><a:To>" + obj.Address + "</a:To><w:ResourceURI>" + resuri + "</w:ResourceURI><a:MessageID>" + (obj.NextMessageId++) + "</a:MessageID><a:ReplyTo><a:Address>http://schemas.xmlsoap.org/ws/2004/08/addressing/role/anonymous</a:Address></a:ReplyTo><w:OperationTimeout>PT60.000S</w:OperationTimeout>" + selector + '</Header><Body>' + obj.xxPutObjToBodyXml(resuri, putobj);
        obj.PerformAjax(data + "</Body></Envelope>", callback, tag, pri);
    }
		
    // Perform a WSMAN CREATE operation
    obj.ExecCreate = function (resuri, putobj, callback, tag, pri) {
        var objname = obj.GetNameFromUrl(resuri), selector = "";
        if (putobj.InstanceID) selector = "<w:SelectorSet><w:Selector Name=\"InstanceID\">" + putobj.InstanceID + "</w:Selector></w:SelectorSet>";
        var data = "http://schemas.xmlsoap.org/ws/2004/09/transfer/Create</a:Action><a:To>" + obj.Address + "</a:To><w:ResourceURI>" + resuri + "</w:ResourceURI><a:MessageID>" + (obj.NextMessageId++) + "</a:MessageID><a:ReplyTo><a:Address>http://schemas.xmlsoap.org/ws/2004/08/addressing/role/anonymous</a:Address></a:ReplyTo><w:OperationTimeout>PT60.000S</w:OperationTimeout>" + selector + "</Header><Body><g:" + objname + " xmlns:g=\"" + resuri + "\">";
        for (var n in putobj) { data += "<g:" + n + ">" + putobj[n] + "</g:" + n + ">" } 
        obj.PerformAjax(data + "</g:" + objname + "></Body></Envelope>", callback, tag, pri);
    }
	
    // Perform a WSMAN DELETE operation
    obj.ExecDelete = function (resuri, putobj, callback, tag, pri) {
        var objname = obj.GetNameFromUrl(resuri), selector = "";
        if (putobj.InstanceID) selector = "<w:SelectorSet><w:Selector Name=\"InstanceID\">" + putobj.InstanceID + "</w:Selector></w:SelectorSet>";
        var data = "http://schemas.xmlsoap.org/ws/2004/09/transfer/Delete</a:Action><a:To>" + obj.Address + "</a:To><w:ResourceURI>" + resuri + "</w:ResourceURI><a:MessageID>" + (obj.NextMessageId++) + "</a:MessageID><a:ReplyTo><a:Address>http://schemas.xmlsoap.org/ws/2004/08/addressing/role/anonymous</a:Address></a:ReplyTo><w:OperationTimeout>PT60.000S</w:OperationTimeout>" + selector + "</Header><Body /></Envelope>";
        obj.PerformAjax(data, callback, tag, pri);
    }

    // Perform a WSMAN GET operation
    obj.ExecGet = function (resuri, callback, tag, pri) {
        obj.PerformAjax("http://schemas.xmlsoap.org/ws/2004/09/transfer/Get</a:Action><a:To>" + obj.Address + "</a:To><w:ResourceURI>" + resuri + "</w:ResourceURI><a:MessageID>" + (obj.NextMessageId++) + "</a:MessageID><a:ReplyTo><a:Address>http://schemas.xmlsoap.org/ws/2004/08/addressing/role/anonymous</a:Address></a:ReplyTo><w:OperationTimeout>PT60.000S</w:OperationTimeout></Header><Body /></Envelope>", callback, tag, pri);
    }

	// Perform a WSMAN method call operation
    obj.ExecMethod = function (resuri, method, args, callback, tag, pri) {
        var argsxml = "";
        for (var i in args) { if (args[i] != null) { if (Array.isArray(args[i])) { for (var x in args[i]) { argsxml += "<r:" + i + ">" + args[i][x] + "</r:" + i + ">"; } } else { argsxml += "<r:" + i + ">" + args[i] + "</r:" + i + ">"; } } }
        obj.PerformAjax(resuri + "/" + method + "</a:Action><a:To>" + obj.Address + "</a:To><w:ResourceURI>" + resuri + "</w:ResourceURI><a:MessageID>" + (obj.NextMessageId++) + "</a:MessageID><a:ReplyTo><a:Address>http://schemas.xmlsoap.org/ws/2004/08/addressing/role/anonymous</a:Address></a:ReplyTo><w:OperationTimeout>PT60.000S</w:OperationTimeout></Header><Body><r:" + method + '_INPUT' + " xmlns:r=\"" + resuri + "\">" + argsxml + "</r:" + method + "_INPUT></Body></Envelope>", callback, tag, pri);
    }
	
    // Perform a WSMAN method call operation. The arguments are already formatted in XML.
    obj.ExecMethodXml = function (resuri, method, argsxml, callback, tag, pri) {
        obj.PerformAjax(resuri + "/" + method + "</a:Action><a:To>" + obj.Address + "</a:To><w:ResourceURI>" + resuri + "</w:ResourceURI><a:MessageID>" + (obj.NextMessageId++) + "</a:MessageID><a:ReplyTo><a:Address>http://schemas.xmlsoap.org/ws/2004/08/addressing/role/anonymous</a:Address></a:ReplyTo><w:OperationTimeout>PT60.000S</w:OperationTimeout></Header><Body><r:" + method + '_INPUT' + " xmlns:r=\"" + resuri + "\">" + argsxml + "</r:" + method + "_INPUT></Body></Envelope>", callback, tag, pri);
    }

    // Perform a WSMAN ENUM operation
    obj.ExecEnum = function (resuri, callback, tag, pri) {
        obj.PerformAjax("http://schemas.xmlsoap.org/ws/2004/09/enumeration/Enumerate</a:Action><a:To>" + obj.Address + "</a:To><w:ResourceURI>" + resuri + "</w:ResourceURI><a:MessageID>" + (obj.NextMessageId++) + "</a:MessageID><a:ReplyTo><a:Address>http://schemas.xmlsoap.org/ws/2004/08/addressing/role/anonymous</a:Address></a:ReplyTo><w:OperationTimeout>PT60.000S</w:OperationTimeout></Header><Body><Enumerate xmlns=\"http://schemas.xmlsoap.org/ws/2004/09/enumeration\" /></Body></Envelope>", callback, tag, pri);
    }

    // Perform a WSMAN PULL operation
    obj.ExecPull = function (resuri, enumctx, callback, tag, pri) {
        obj.PerformAjax("http://schemas.xmlsoap.org/ws/2004/09/enumeration/Pull</a:Action><a:To>" + obj.Address + "</a:To><w:ResourceURI>" + resuri + "</w:ResourceURI><a:MessageID>" + (obj.NextMessageId++) + "</a:MessageID><a:ReplyTo><a:Address>http://schemas.xmlsoap.org/ws/2004/08/addressing/role/anonymous</a:Address></a:ReplyTo><w:OperationTimeout>PT60.000S</w:OperationTimeout></Header><Body><Pull xmlns=\"http://schemas.xmlsoap.org/ws/2004/09/enumeration\"><EnumerationContext>" + enumctx + "</EnumerationContext><MaxElements>1000</MaxElements><MaxCharacters>5000000</MaxCharacters></Pull></Body></Envelope>", callback, tag, pri);
    }

    // Private method
    obj.ParseWsman = function (xml) {
        if (!xml.childNodes) xml = turnToXml(xml);
        var r = { Header:{} }, header = xml.getElementsByTagName("Header")[0], t;
        if (!header) header = xml.getElementsByTagName("a:Header")[0];
        if (!header) return null;
        for (var i = 0; i < header.childNodes.length; i++) {
            var child = header.childNodes[i];
            r.Header[child.localName] = child.textContent;
        }
        var body = xml.getElementsByTagName("Body")[0];
        if (!body) body = xml.getElementsByTagName("a:Body")[0];
        if (!body) return null;
        if (body.childNodes.length > 0) {
            t = body.childNodes[0].localName;
            if (t.indexOf("_OUTPUT") == t.length - 7) { t = t.substring(0, t.length - 7); }
            r.Header['Method'] = t;
            r.Body = obj.xxParseWsmanRec(body.childNodes[0]);
		}
        return r;
    }

    // Private method
    obj.xxParseWsmanRec = function (node) {
        var data, r = {};
        for (var i = 0; i < node.childNodes.length; i++) {
            var child = node.childNodes[i];
            if (child.childElementCount == 0) { data = child.textContent; } else { data = obj.xxParseWsmanRec(child); }
			
			var childObj = data;
			if(child.attributes.length > 0) {
				childObj = {'Value': data };
				for(var j=0; j<child.attributes.length; j++) {
					childObj['@' + child.attributes[j].name] = child.attributes[j].value;
				}
			}
			
            if (r[child.localName] instanceof Array) { r[child.localName].push( childObj ); }
            else if (r[child.localName] == undefined) { r[child.localName] = childObj; }
            else { r[child.localName] = [r[child.localName], childObj]; }
        }
        return r;
    }

	obj.xxPutObjToBodyXml = function(resuri, putObj) {
		if(!resuri || putObj === undefined || putObj === null) return '';
		
		var objname = obj.GetNameFromUrl(resuri);
		var result = '<r:' + objname + ' xmlns:r="' + resuri + '">';
		for(var prop in putObj) {
			if (!putObj.hasOwnProperty(prop) || prop.indexOf('__') === 0 || prop.indexOf('@') === 0) continue;
			
			if (putObj[prop] === undefined || putObj[prop] === null || typeof putObj[prop] === 'function' || Array.isArray(putObj[prop]) ) continue;
			
			if (typeof putObj[prop] === 'object' && putObj[prop].ReferenceParameters) {
				
				result += '<r:' + prop + '><a:Address>' + putObj[prop].Address + '</a:Address><a:ReferenceParameters><w:ResourceURI>' + putObj[prop].ReferenceParameters["ResourceURI"] + '</w:ResourceURI><w:SelectorSet>';
				var selectorArray = putObj[prop].ReferenceParameters.SelectorSet.Selector;
				if(Array.isArray(selectorArray)) {
					for(var i=0; i<selectorArray.length; i++) {
						result += '<w:Selector' + obj.xxObjectToXmlAttributes(selectorArray[i]) + '>'+selectorArray[i].Value+'</w:Selector>';
					}
				}
				else {
					result += '<w:Selector' + obj.xxObjectToXmlAttributes(selectorArray) + '>'+selectorArray.Value+'</w:Selector>';
				}
				result += '</w:SelectorSet></a:ReferenceParameters>';
				
				result += '</r:' + prop + '>';
			}
			else {
				result += '<r:' + prop +'>' + putObj[prop].toString() + '</r:' + prop +'>';
			}
		}
		result += '</r:' + objname + '>';
		return result;
	}

	/* 
	convert 
		{ @Name: 'InstanceID', @AttrName: 'Attribute Value'}
	into
		' Name="InstanceID" AttrName="Attribute Value" '
	*/
	obj.xxObjectToXmlAttributes = function(objWithAttributes) {
		if(!objWithAttributes) return '';
		var result = ' ';
		for(var propName in objWithAttributes) {
			if (!objWithAttributes.hasOwnProperty(propName) || propName.indexOf('@') !== 0) continue;
			result += propName.substring(1) + '="' + objWithAttributes[propName] + '" ';
		}
		return result;
	}

	obj.xxPutObjToSelectorsXml = function(selectorSet) {
		if(!selectorSet) return '';
		var result = '<w:SelectorSet>';
		for(var propName in selectorSet) {
			if (!selectorSet.hasOwnProperty(propName) || !selectorSet[propName].ReferenceParameters) continue;
			
			result += '<w:Selector Name="' + propName + '"><a:EndpointReference>';
			result += '<a:Address>' + selectorSet[propName].Address + '</a:Address><a:ReferenceParameters><w:ResourceURI>' + selectorSet[propName].ReferenceParameters["ResourceURI"] + '</w:ResourceURI><w:SelectorSet>';
			var selectorArray = selectorSet[propName].ReferenceParameters.SelectorSet.Selector;
			if(Array.isArray(selectorArray)) {
				for(var i=0; i<selectorArray.length; i++) {
					result += '<w:Selector' + obj.xxObjectToXmlAttributes(selectorArray[i]) + '>'+selectorArray[i].Value+'</w:Selector>';
				}
			}
			else {
				result += '<w:Selector' + obj.xxObjectToXmlAttributes(selectorArray) + '>'+selectorArray.Value+'</w:Selector>';
			}
			result += '</w:SelectorSet></a:ReferenceParameters></a:EndpointReference></w:Selector>';
		}
		result += '</w:SelectorSet>';
		return result;
	}


    // Print object
    obj.ObjectToStringEx = function (x, c) {
        var r = "";
        if (!x || x == null) return "(Null)";
        if (x instanceof Array) { for (var i in x) { r += '<br />' + obj.gap(c) + "Item #" + i + ": " + obj.ObjectToStringEx(x[i], c + 1); } }
        else if (x instanceof Object) { for (var i in x) { r += '<br />' + obj.gap(c) + i + " = " + obj.ObjectToStringEx(x[i], c + 1); } }
        else { r += x; }
        return r;
    }

    // Create an ident gap
    obj.gap = function (c) { var x = ''; for (var i = 0; i < (c * 4); i++) { x += '&nbsp;'; } return x; }

    // Print an object in html
    obj.ObjectToString = function (x) { return obj.ObjectToStringEx(x, 0); }


    return obj;
}

function ReadShort(v, p) { return (v.charCodeAt(p) << 8) + v.charCodeAt(p + 1); }
function ReadShortX(v, p) { return (v.charCodeAt(p + 1) << 8) + v.charCodeAt(p); }
function ReadInt(v, p) { return (v.charCodeAt(p) << 24) + (v.charCodeAt(p + 1) << 16) + (v.charCodeAt(p + 2) << 8) + v.charCodeAt(p + 3); }
function ReadIntX(v, p) { return (v.charCodeAt(p + 3) << 24) + (v.charCodeAt(p + 2) << 16) + (v.charCodeAt(p + 1) << 8) + v.charCodeAt(p); }
function ShortToStr(v) { return String.fromCharCode((v >> 8) & 0xFF, v & 0xFF); }
function ShortToStrX(v) { return String.fromCharCode(v & 0xFF, (v >> 8) & 0xFF); }
function IntToStr(v) { return String.fromCharCode((v >> 24) & 0xFF, (v >> 16) & 0xFF, (v >> 8) & 0xFF, v & 0xFF); }
function IntToStrX(v) { return String.fromCharCode(v & 0xFF, (v >> 8) & 0xFF, (v >> 16) & 0xFF, (v >> 24) & 0xFF); }

function turnToXml(text) {
    if (window.DOMParser) {
        return new DOMParser().parseFromString(text, "text/xml");
    }
    else // Internet Explorer
    {
        var xmlDoc = new ActiveXObject("Microsoft.XMLDOM");
        xmlDoc.async = false;
        xmlDoc.loadXML(text);
        return xmlDoc;
    }
}
/** 
* @description Intel(R) AMT Stack
* @author Ylian Saint-Hilaire
* @version v0.1.0
*/

// Construct a MeshServer object
var AmtStackCreateService = function (wsmanStack) {
    var obj = new Object();
    obj.wsman = wsmanStack;
    obj.pfx = ["http://intel.com/wbem/wscim/1/amt-schema/1/", "http://schemas.dmtf.org/wbem/wscim/1/cim-schema/2/", "http://intel.com/wbem/wscim/1/ips-schema/1/"];
    obj.PendingEnums = [];
    obj.PendingBatchOperations = 0;
    obj.ActiveEnumsCount = 0;
    obj.MaxActiveEnumsCount = 3;
    obj.onProcessChanged = null;
    obj.xxMaxProcess = 0;
    obj.xxLastProcess = 0;

    // Return the number of pending actions
    obj.GetPendingActions = function () { return (obj.PendingEnums.length * 2) + (obj.ActiveEnumsCount) + obj.wsman.comm.PendingAjax.length + obj.wsman.comm.ActiveAjaxCount + obj.PendingBatchOperations; }

    // Update the current processing status, this gives the application an idea of what progress is being done by the WSMAN stack
    obj.xxup = function () {
        var x = obj.GetPendingActions();
        if (obj.xxMaxProcess < x) obj.xxMaxProcess = x;
        if (obj.onProcessChanged != null && obj.xxLastProcess != x) {
            //console.log("Process Old=" + obj.xxLastProcess + ", New=" + x + ", PEnums=" + obj.PendingEnums.length + ", AEnums=" + obj.ActiveEnumsCount + ", PAjax=" + obj.wsman.comm.PendingAjax.length + ", AAjax=" + obj.wsman.comm.ActiveAjaxCount + ", PBatch=" + obj.PendingBatchOperations);
            obj.xxLastProcess = x;
            obj.onProcessChanged(x, obj.xxMaxProcess);
        }
        if (x == 0) obj.xxMaxProcess = 0;
    }

    // Perform a WSMAN "GET" operations.
    obj.Get = function (name, callback, tag, pri) { obj.wsman.ExecGet(obj.CompleteName(name), function (ws, resuri, response, xstatus) { obj.xxup(); callback(obj, name, response, xstatus, tag); }, 0, pri); obj.xxup(); }

    // Perform a WSMAN "PUT" operations.
    obj.Put = function (name, putobj, callback, tag, pri) { obj.wsman.ExecPut(obj.CompleteName(name), putobj, function (ws, resuri, response, xstatus) { obj.xxup(); callback(obj, name, response, xstatus, tag); }, 0, pri); obj.xxup(); }
	
    // Perform a WSMAN "CREATE" operations.
    obj.Create = function (name, putobj, callback, tag, pri) { obj.wsman.ExecCreate(obj.CompleteName(name), putobj, function (ws, resuri, response, xstatus) { obj.xxup(); callback(obj, name, response, xstatus, tag); }, 0, pri); obj.xxup(); }

    // Perform a WSMAN "DELETE" operations.
    obj.Delete = function (name, putobj, callback, tag, pri) { obj.wsman.ExecDelete(obj.CompleteName(name), putobj, function (ws, resuri, response, xstatus) { obj.xxup(); callback(obj, name, response, xstatus, tag); }, 0, pri); obj.xxup(); }

    // Perform a WSMAN method call operation.
    obj.Exec = function (name, method, args, callback, tag, pri) { obj.wsman.ExecMethod(obj.CompleteName(name), method, args, function (ws, resuri, response, xstatus) { obj.xxup(); callback(obj, name, obj.CompleteExecResponse(response), xstatus, tag); }, 0, pri); obj.xxup(); }
	
    // Perform a WSMAN method call operation.
    obj.ExecWithXml = function (name, method, args, callback, tag, pri) { obj.wsman.ExecMethodXml(obj.CompleteName(name), method, execArgumentsToXml(args), function (ws, resuri, response, xstatus) { obj.xxup(); callback(obj, name, obj.CompleteExecResponse(response), xstatus, tag); }, 0, pri); obj.xxup(); }
	
    // Perform a WSMAN "ENUMERATE" operations.
    obj.Enum = function (name, callback, tag, pri) {
        if (obj.ActiveEnumsCount < obj.MaxActiveEnumsCount) {
            obj.ActiveEnumsCount++; obj.wsman.ExecEnum(obj.CompleteName(name), function (ws, resuri, response, xstatus, tag0) { obj.xxup(); obj.EnumStartSink(name, response, callback, resuri, xstatus, tag0); }, tag, pri);
        } else {
            obj.PendingEnums.push([name, callback, tag, pri]);
        }
        obj.xxup();
    }

    // Private method
    obj.EnumStartSink = function (name, response, callback, resuri, status, tag, pri) {
        if (status != 200) { callback(obj, name, null, status, tag); obj.EnumDoNext(1); return; }
        if (response == null || response.Header["Method"] != "EnumerateResponse" || !response.Body["EnumerationContext"]) { callback(obj, name, null, 500, tag); obj.EnumDoNext(1); return; }
        var enumctx = response.Body["EnumerationContext"];
        obj.wsman.ExecPull(resuri, enumctx, function (ws, resuri, response, xstatus) { obj.EnumContinueSink(name, response, callback, resuri, [], xstatus, tag, pri); });
    }

    // Private method
    obj.EnumContinueSink = function (name, response, callback, resuri, items, status, tag, pri) {
        if (status != 200) { callback(obj, name, null, status, tag); obj.EnumDoNext(1); return; }
        if (response == null || response.Header["Method"] != "PullResponse") { callback(obj, name, null, 500, tag); obj.EnumDoNext(1); return; }
        for (var i in response.Body["Items"]) {
            if (response.Body["Items"][i] instanceof Array) {
                for (var j in response.Body["Items"][i]) { items.push(response.Body["Items"][i][j]); }
            } else {
                items.push(response.Body["Items"][i]);
            }
        }
        if (response.Body["EnumerationContext"]) {
            var enumctx = response.Body["EnumerationContext"];
            obj.wsman.ExecPull(resuri, enumctx, function (ws, resuri, response, xstatus) { obj.EnumContinueSink(name, response, callback, resuri, items, xstatus, tag, pri); });
        } else {
            obj.EnumDoNext(1);
            callback(obj, name, items, status, tag);
            obj.xxup();
        }
    }

    // Private method
    obj.EnumDoNext = function (dec) {
        obj.ActiveEnumsCount -= dec;
        if (obj.ActiveEnumsCount >= obj.MaxActiveEnumsCount || obj.PendingEnums.length == 0) return;
        var x = obj.PendingEnums.shift();
        obj.Enum(x[0], x[1], x[2]);
        obj.EnumDoNext(0);
    }

    // Perform a batch of WSMAN "ENUM" operations.
    obj.BatchEnum = function (batchname, names, callback, tag, continueOnError, pri) {
        obj.PendingBatchOperations += (names.length * 2);
        obj.xxBatchNextEnum(batchname, names, callback, tag, {}, continueOnError, pri); obj.xxup();
    }

    // Request each enum in the batch, stopping if something does not return status 200
    obj.xxBatchNextEnum = function (batchname, names, callback, tag, results, continueOnError, pri) {
        obj.PendingBatchOperations -= 2;
        var n = names.shift(), f = obj.Enum;
        if (n[0] == '*') { f = obj.Get; n = n.substring(1); } // If the name starts with a star, do a GET instead of an ENUM. This will reduce round trips.
        //console.log((f == obj.Get?'Get ':'Enum ') + n);
        // Perform a GET/ENUM action
        f(n, function (stack, name, responses, status, tag0) {
            tag0[2][name] = { response: (responses==null?null:responses.Body), responses: responses, status: status };
            if (tag0[1].length == 0 || status == 401 || (continueOnError == false && status != 200 && status != 400)) { obj.PendingBatchOperations -= (names.length * 2); obj.xxup(); callback(obj, batchname, tag0[2], status, tag0); }
            else { obj.xxup(); obj.xxBatchNextEnum(batchname, names, callback, tag, tag0[2], pri); }
        }, [batchname, names, results], pri);
        obj.xxup();
    }

    // Perform a batch of WSMAN "GET" operations.
    obj.BatchGet = function (batchname, names, callback, tag, pri) {
        obj.FetchNext({ name: batchname, names: names, callback: callback, current: 0, responses: {}, tag: tag, pri: pri }); obj.xxup();
    }

    // Private method
    obj.FetchNext = function (batch) {
        if (batch.names.length <= batch.current) {
            batch.callback(obj, batch.name, batch.responses, 200, batch.tag);
        } else {
            obj.wsman.ExecGet(obj.CompleteName(batch.names[batch.current]), function (ws, resuri, response, xstatus) { obj.Fetched(batch, response, xstatus); }, batch.pri);
            batch.current++;
        }
        obj.xxup();
    }

    // Private method
    obj.Fetched = function (batch, response, status) {
        if (response == null || status != 200) {
            batch.callback(obj, batch.name, null, status, batch.tag);
        } else {
            batch.responses[response.Header["Method"]] = response;
            obj.FetchNext(batch);
        }
    }

    // Private method
    obj.CompleteName = function (name) {
        if (name.indexOf("AMT_") == 0) return obj.pfx[0] + name;
        if (name.indexOf("CIM_") == 0) return obj.pfx[1] + name;
        if (name.indexOf("IPS_") == 0) return obj.pfx[2] + name;
    }

    obj.CompleteExecResponse = function (resp) {
        if (resp && resp != null && resp.Body && resp.Body["ReturnValue"]) resp.Body.ReturnValueStr = obj.AmtStatusToStr(resp.Body["ReturnValue"]);
        return resp;
    }

    obj.RequestPowerStateChange = function (PowerState, callback_func) {
        obj.CIM_PowerManagementService_RequestPowerStateChange(PowerState, "<Address xmlns=\"http://schemas.xmlsoap.org/ws/2004/08/addressing\">http://schemas.xmlsoap.org/ws/2004/08/addressing</Address><ReferenceParameters xmlns=\"http://schemas.xmlsoap.org/ws/2004/08/addressing\"><ResourceURI xmlns=\"http://schemas.dmtf.org/wbem/wsman/1/wsman.xsd\">http://schemas.dmtf.org/wbem/wscim/1/cim-schema/2/CIM_ComputerSystem</ResourceURI><SelectorSet xmlns=\"http://schemas.dmtf.org/wbem/wsman/1/wsman.xsd\"><Selector Name=\"CreationClassName\">CIM_ComputerSystem</Selector><Selector Name=\"Name\">ManagedSystem</Selector></SelectorSet></ReferenceParameters>", null, null, callback_func);
    }

    obj.SetBootConfigRole = function (Role, callback_func) {
        obj.CIM_BootService_SetBootConfigRole("<Address xmlns=\"http://schemas.xmlsoap.org/ws/2004/08/addressing\">http://schemas.xmlsoap.org/ws/2004/08/addressing</Address><ReferenceParameters xmlns=\"http://schemas.xmlsoap.org/ws/2004/08/addressing\"><ResourceURI xmlns=\"http://schemas.dmtf.org/wbem/wsman/1/wsman.xsd\">http://schemas.dmtf.org/wbem/wscim/1/cim-schema/2/CIM_BootConfigSetting</ResourceURI><SelectorSet xmlns=\"http://schemas.dmtf.org/wbem/wsman/1/wsman.xsd\"><Selector Name=\"InstanceID\">Intel(r) AMT: Boot Configuration 0</Selector></SelectorSet></ReferenceParameters>", Role, callback_func);
    }

    // Cancel all pending queries with given status
    obj.CancelAllQueries = function (s) {
        obj.wsman.CancelAllQueries(s);
    }

    // Auto generated methods
    obj.AMT_AgentPresenceWatchdog_RegisterAgent = function (callback_func) { obj.Exec("AMT_AgentPresenceWatchdog", "RegisterAgent", {}, callback_func); }
    obj.AMT_AgentPresenceWatchdog_AssertPresence = function (SequenceNumber, callback_func) { obj.Exec("AMT_AgentPresenceWatchdog", "AssertPresence", { "SequenceNumber": SequenceNumber }, callback_func); }
    obj.AMT_AgentPresenceWatchdog_AssertShutdown = function (SequenceNumber, callback_func) { obj.Exec("AMT_AgentPresenceWatchdog", "AssertShutdown", { "SequenceNumber": SequenceNumber }, callback_func); }
    obj.AMT_AgentPresenceWatchdog_AddAction = function (OldState, NewState, EventOnTransition, ActionSd, ActionEac, callback_func) { obj.Exec("AMT_AgentPresenceWatchdog", "AddAction", { "OldState": OldState, "NewState": NewState, "EventOnTransition": EventOnTransition, "ActionSd": ActionSd, "ActionEac": ActionEac }, callback_func); }
    obj.AMT_AgentPresenceWatchdog_DeleteAllActions = function (_method_dummy, callback_func) { obj.Exec("AMT_AgentPresenceWatchdog", "DeleteAllActions", { "_method_dummy": _method_dummy }, callback_func); }
    obj.AMT_AgentPresenceWatchdogAction_GetActionEac = function (callback_func) { obj.Exec("AMT_AgentPresenceWatchdogAction", "GetActionEac", {}, callback_func); }
    obj.AMT_AgentPresenceWatchdogVA_RegisterAgent = function (callback_func) { obj.Exec("AMT_AgentPresenceWatchdogVA", "RegisterAgent", {}, callback_func); }
    obj.AMT_AgentPresenceWatchdogVA_AssertPresence = function (SequenceNumber, callback_func) { obj.Exec("AMT_AgentPresenceWatchdogVA", "AssertPresence", { "SequenceNumber": SequenceNumber }, callback_func); }
    obj.AMT_AgentPresenceWatchdogVA_AssertShutdown = function (SequenceNumber, callback_func) { obj.Exec("AMT_AgentPresenceWatchdogVA", "AssertShutdown", { "SequenceNumber": SequenceNumber }, callback_func); }
    obj.AMT_AgentPresenceWatchdogVA_AddAction = function (OldState, NewState, EventOnTransition, ActionSd, ActionEac, callback_func) { obj.Exec("AMT_AgentPresenceWatchdogVA", "AddAction", { "OldState": OldState, "NewState": NewState, "EventOnTransition": EventOnTransition, "ActionSd": ActionSd, "ActionEac": ActionEac }, callback_func); }
    obj.AMT_AgentPresenceWatchdogVA_DeleteAllActions = function (_method_dummy, callback_func) { obj.Exec("AMT_AgentPresenceWatchdogVA", "DeleteAllActions", { "_method_dummy": _method_dummy }, callback_func); }
    obj.AMT_AuditLog_ClearLog = function (callback_func) { obj.Exec("AMT_AuditLog", "ClearLog", { }, callback_func); }
    obj.AMT_AuditLog_RequestStateChange = function (RequestedState, TimeoutPeriod, callback_func) { obj.Exec("AMT_AuditLog", "RequestStateChange", { "RequestedState": RequestedState, "TimeoutPeriod": TimeoutPeriod }, callback_func); }
    obj.AMT_AuditLog_ReadRecords = function (StartIndex, callback_func, tag) { obj.Exec("AMT_AuditLog", "ReadRecords", { "StartIndex": StartIndex }, callback_func, tag); }
    obj.AMT_AuditLog_SetAuditLock = function (LockTimeoutInSeconds, Flag, Handle, callback_func) { obj.Exec("AMT_AuditLog", "SetAuditLock", { "LockTimeoutInSeconds": LockTimeoutInSeconds, "Flag": Flag, "Handle": Handle }, callback_func); }
    obj.AMT_AuditLog_ExportAuditLogSignature = function (SigningMechanism, callback_func) { obj.Exec("AMT_AuditLog", "ExportAuditLogSignature", { "SigningMechanism": SigningMechanism }, callback_func); }
    obj.AMT_AuditLog_SetSigningKeyMaterial = function (SigningMechanismType, SigningKey, LengthOfCertificates, Certificates, callback_func) { obj.Exec("AMT_AuditLog", "SetSigningKeyMaterial", { "SigningMechanismType": SigningMechanismType, "SigningKey": SigningKey, "LengthOfCertificates": LengthOfCertificates, "Certificates": Certificates }, callback_func); }
    obj.AMT_AuditPolicyRule_SetAuditPolicy = function (Enable, AuditedAppID, EventID, PolicyType, callback_func) { obj.Exec("AMT_AuditPolicyRule", "SetAuditPolicy", { "Enable": Enable, "AuditedAppID": AuditedAppID, "EventID": EventID, "PolicyType": PolicyType }, callback_func); }
    obj.AMT_AuditPolicyRule_SetAuditPolicyBulk = function (Enable, AuditedAppID, EventID, PolicyType, callback_func) { obj.Exec("AMT_AuditPolicyRule", "SetAuditPolicyBulk", { "Enable": Enable, "AuditedAppID": AuditedAppID, "EventID": EventID, "PolicyType": PolicyType }, callback_func); }
    obj.AMT_AuthorizationService_AddUserAclEntryEx = function (DigestUsername, DigestPassword, KerberosUserSid, AccessPermission, Realms, callback_func) { obj.Exec("AMT_AuthorizationService", "AddUserAclEntryEx", { "DigestUsername": DigestUsername, "DigestPassword": DigestPassword, "KerberosUserSid": KerberosUserSid, "AccessPermission": AccessPermission, "Realms": Realms }, callback_func); }
    obj.AMT_AuthorizationService_EnumerateUserAclEntries = function (StartIndex, callback_func) { obj.Exec("AMT_AuthorizationService", "EnumerateUserAclEntries", { "StartIndex": StartIndex }, callback_func); }
    obj.AMT_AuthorizationService_GetUserAclEntryEx = function (Handle, callback_func, tag) { obj.Exec("AMT_AuthorizationService", "GetUserAclEntryEx", { "Handle": Handle }, callback_func, tag); }
    obj.AMT_AuthorizationService_UpdateUserAclEntryEx = function (Handle, DigestUsername, DigestPassword, KerberosUserSid, AccessPermission, Realms, callback_func) { obj.Exec("AMT_AuthorizationService", "UpdateUserAclEntryEx", { "Handle": Handle, "DigestUsername": DigestUsername, "DigestPassword": DigestPassword, "KerberosUserSid": KerberosUserSid, "AccessPermission": AccessPermission, "Realms": Realms }, callback_func); }
    obj.AMT_AuthorizationService_RemoveUserAclEntry = function (Handle, callback_func) { obj.Exec("AMT_AuthorizationService", "RemoveUserAclEntry", { "Handle": Handle }, callback_func); }
    obj.AMT_AuthorizationService_SetAdminAclEntryEx = function (Username, DigestPassword, callback_func) { obj.Exec("AMT_AuthorizationService", "SetAdminAclEntryEx", { "Username": Username, "DigestPassword": DigestPassword }, callback_func); }
    obj.AMT_AuthorizationService_GetAdminAclEntry = function (callback_func) { obj.Exec("AMT_AuthorizationService", "GetAdminAclEntry", {}, callback_func); }
    obj.AMT_AuthorizationService_GetAdminAclEntryStatus = function (callback_func) { obj.Exec("AMT_AuthorizationService", "GetAdminAclEntryStatus", {}, callback_func); }
    obj.AMT_AuthorizationService_GetAdminNetAclEntryStatus = function (callback_func) { obj.Exec("AMT_AuthorizationService", "GetAdminNetAclEntryStatus", {}, callback_func); }
    obj.AMT_AuthorizationService_SetAclEnabledState = function (Handle, Enabled, callback_func) { obj.Exec("AMT_AuthorizationService", "SetAclEnabledState", { "Handle": Handle, "Enabled": Enabled }, callback_func); }
    obj.AMT_AuthorizationService_GetAclEnabledState = function (Handle, callback_func) { obj.Exec("AMT_AuthorizationService", "GetAclEnabledState", { "Handle": Handle }, callback_func); }
    obj.AMT_EndpointAccessControlService_RequestStateChange = function (RequestedState, TimeoutPeriod, callback_func) { obj.Exec("AMT_EndpointAccessControlService", "RequestStateChange", { "RequestedState": RequestedState, "TimeoutPeriod": TimeoutPeriod }, callback_func); }
    obj.AMT_EndpointAccessControlService_GetPosture = function (PostureType, callback_func) { obj.Exec("AMT_EndpointAccessControlService", "GetPosture", { "PostureType": PostureType }, callback_func); }
    obj.AMT_EndpointAccessControlService_GetPostureHash = function (PostureType, callback_func) { obj.Exec("AMT_EndpointAccessControlService", "GetPostureHash", { "PostureType": PostureType }, callback_func); }
    obj.AMT_EndpointAccessControlService_UpdatePostureState = function (UpdateType, callback_func) { obj.Exec("AMT_EndpointAccessControlService", "UpdatePostureState", { "UpdateType": UpdateType }, callback_func); }
    obj.AMT_EndpointAccessControlService_GetEacOptions = function (callback_func) { obj.Exec("AMT_EndpointAccessControlService", "GetEacOptions", {}, callback_func); }
    obj.AMT_EndpointAccessControlService_SetEacOptions = function (EacVendors, PostureHashAlgorithm, callback_func) { obj.Exec("AMT_EndpointAccessControlService", "SetEacOptions", { "EacVendors": EacVendors, "PostureHashAlgorithm": PostureHashAlgorithm }, callback_func); }
    obj.AMT_EnvironmentDetectionSettingData_SetSystemDefensePolicy = function (Policy, callback_func) { obj.Exec("AMT_EnvironmentDetectionSettingData", "SetSystemDefensePolicy", { "Policy": Policy }, callback_func); }
    obj.AMT_EnvironmentDetectionSettingData_EnableVpnRouting = function (Enable, callback_func) { obj.Exec("AMT_EnvironmentDetectionSettingData", "EnableVpnRouting", { "Enable": Enable }, callback_func); }
    obj.AMT_EthernetPortSettings_SetLinkPreference = function (LinkPreference, Timeout, callback_func) { obj.Exec("AMT_EthernetPortSettings", "SetLinkPreference", { "LinkPreference": LinkPreference, "Timeout": Timeout }, callback_func); }
    obj.AMT_HeuristicPacketFilterStatistics_ResetSelectedStats = function (SelectedStatistics, callback_func) { obj.Exec("AMT_HeuristicPacketFilterStatistics", "ResetSelectedStats", { "SelectedStatistics": SelectedStatistics }, callback_func); }
    obj.AMT_KerberosSettingData_GetCredentialCacheState = function (callback_func) { obj.Exec("AMT_KerberosSettingData", "GetCredentialCacheState", {}, callback_func); }
    obj.AMT_KerberosSettingData_SetCredentialCacheState = function (Enable, callback_func) { obj.Exec("AMT_KerberosSettingData", "SetCredentialCacheState", { "Enable": Enable }, callback_func); }
    obj.AMT_MessageLog_CancelIteration = function (IterationIdentifier, callback_func) { obj.Exec("AMT_MessageLog", "CancelIteration", { "IterationIdentifier": IterationIdentifier }, callback_func); }
    obj.AMT_MessageLog_RequestStateChange = function (RequestedState, TimeoutPeriod, callback_func) { obj.Exec("AMT_MessageLog", "RequestStateChange", { "RequestedState": RequestedState, "TimeoutPeriod": TimeoutPeriod }, callback_func); }
    obj.AMT_MessageLog_ClearLog = function (callback_func) { obj.Exec("AMT_MessageLog", "ClearLog", { }, callback_func); }
    obj.AMT_MessageLog_GetRecords = function (IterationIdentifier, MaxReadRecords, callback_func, tag) { obj.Exec("AMT_MessageLog", "GetRecords", { "IterationIdentifier": IterationIdentifier, "MaxReadRecords": MaxReadRecords }, callback_func, tag); }
    obj.AMT_MessageLog_GetRecord = function (IterationIdentifier, PositionToNext, callback_func) { obj.Exec("AMT_MessageLog", "GetRecord", { "IterationIdentifier": IterationIdentifier, "PositionToNext": PositionToNext }, callback_func); }
    obj.AMT_MessageLog_PositionAtRecord = function (IterationIdentifier, MoveAbsolute, RecordNumber, callback_func) { obj.Exec("AMT_MessageLog", "PositionAtRecord", { "IterationIdentifier": IterationIdentifier, "MoveAbsolute": MoveAbsolute, "RecordNumber": RecordNumber }, callback_func); }
    obj.AMT_MessageLog_PositionToFirstRecord = function (callback_func, tag) { obj.Exec("AMT_MessageLog", "PositionToFirstRecord", {}, callback_func, tag); }
    obj.AMT_MessageLog_FreezeLog = function (Freeze, callback_func) { obj.Exec("AMT_MessageLog", "FreezeLog", { "Freeze": Freeze }, callback_func); }
    obj.AMT_PublicKeyManagementService_AddCRL = function (Url, SerialNumbers, callback_func) { obj.Exec("AMT_PublicKeyManagementService", "AddCRL", { "Url": Url, "SerialNumbers": SerialNumbers }, callback_func); }
    obj.AMT_PublicKeyManagementService_ResetCRLList = function (_method_dummy, callback_func) { obj.Exec("AMT_PublicKeyManagementService", "ResetCRLList", { "_method_dummy": _method_dummy }, callback_func); }
    obj.AMT_PublicKeyManagementService_AddCertificate = function (CertificateBlob, callback_func) { obj.Exec("AMT_PublicKeyManagementService", "AddCertificate", { "CertificateBlob": CertificateBlob }, callback_func); }
    obj.AMT_PublicKeyManagementService_AddTrustedRootCertificate = function (CertificateBlob, callback_func) { obj.Exec("AMT_PublicKeyManagementService", "AddTrustedRootCertificate", { "CertificateBlob": CertificateBlob }, callback_func); }
    obj.AMT_PublicKeyManagementService_AddKey = function (KeyBlob, callback_func) { obj.Exec("AMT_PublicKeyManagementService", "AddKey", { "KeyBlob": KeyBlob }, callback_func); }
    obj.AMT_PublicKeyManagementService_GeneratePKCS10Request = function (KeyPair, DNName, Usage, callback_func) { obj.Exec("AMT_PublicKeyManagementService", "GeneratePKCS10Request", { "KeyPair": KeyPair, "DNName": DNName, "Usage": Usage }, callback_func); }
    obj.AMT_PublicKeyManagementService_GeneratePKCS10RequestEx = function (KeyPair, SigningAlgorithm, NullSignedCertificateRequest, callback_func) { obj.Exec("AMT_PublicKeyManagementService", "GeneratePKCS10RequestEx", { "KeyPair": KeyPair, "SigningAlgorithm": SigningAlgorithm, "NullSignedCertificateRequest": NullSignedCertificateRequest }, callback_func); }
    obj.AMT_PublicKeyManagementService_GenerateKeyPair = function (KeyAlgorithm, KeyLength, callback_func) { obj.Exec("AMT_PublicKeyManagementService", "GenerateKeyPair", { "KeyAlgorithm": KeyAlgorithm, "KeyLength": KeyLength }, callback_func); }
    obj.AMT_RedirectionService_RequestStateChange = function (RequestedState, callback_func) { obj.Exec("AMT_RedirectionService", "RequestStateChange", { "RequestedState": RequestedState }, callback_func); }
    obj.AMT_RedirectionService_TerminateSession = function (SessionType, callback_func) { obj.Exec("AMT_RedirectionService", "TerminateSession", { "SessionType": SessionType }, callback_func); }
    obj.AMT_RemoteAccessService_AddMpServer = function (AccessInfo, InfoFormat, Port, AuthMethod, Certificate, Username, Password, CN, callback_func) { obj.Exec("AMT_RemoteAccessService", "AddMpServer", { "AccessInfo": AccessInfo, "InfoFormat": InfoFormat, "Port": Port, "AuthMethod": AuthMethod, "Certificate": Certificate, "Username": Username, "Password": Password, "CN": CN }, callback_func); }
    obj.AMT_RemoteAccessService_AddRemoteAccessPolicyRule = function (Trigger, TunnelLifeTime, ExtendedData, MpServer, callback_func) { obj.Exec("AMT_RemoteAccessService", "AddRemoteAccessPolicyRule", { "Trigger": Trigger, "TunnelLifeTime": TunnelLifeTime, "ExtendedData": ExtendedData, "MpServer": MpServer }, callback_func); }
    obj.AMT_RemoteAccessService_CloseRemoteAccessConnection = function (_method_dummy, callback_func) { obj.Exec("AMT_RemoteAccessService", "CloseRemoteAccessConnection", { "_method_dummy": _method_dummy }, callback_func); }
    obj.AMT_SetupAndConfigurationService_CommitChanges = function (_method_dummy, callback_func) { obj.Exec("AMT_SetupAndConfigurationService", "CommitChanges", { "_method_dummy": _method_dummy }, callback_func); }
    obj.AMT_SetupAndConfigurationService_Unprovision = function (ProvisioningMode, callback_func) { obj.Exec("AMT_SetupAndConfigurationService", "Unprovision", { "ProvisioningMode": ProvisioningMode }, callback_func); }
    obj.AMT_SetupAndConfigurationService_PartialUnprovision = function (_method_dummy, callback_func) { obj.Exec("AMT_SetupAndConfigurationService", "PartialUnprovision", { "_method_dummy": _method_dummy }, callback_func); }
    obj.AMT_SetupAndConfigurationService_ResetFlashWearOutProtection = function (_method_dummy, callback_func) { obj.Exec("AMT_SetupAndConfigurationService", "ResetFlashWearOutProtection", { "_method_dummy": _method_dummy }, callback_func); }
    obj.AMT_SetupAndConfigurationService_ExtendProvisioningPeriod = function (Duration, callback_func) { obj.Exec("AMT_SetupAndConfigurationService", "ExtendProvisioningPeriod", { "Duration": Duration }, callback_func); }
    obj.AMT_SetupAndConfigurationService_SetMEBxPassword = function (Password, callback_func) { obj.Exec("AMT_SetupAndConfigurationService", "SetMEBxPassword", { "Password": Password }, callback_func); }
    obj.AMT_SetupAndConfigurationService_SetTLSPSK = function (PID, PPS, callback_func) { obj.Exec("AMT_SetupAndConfigurationService", "SetTLSPSK", { "PID": PID, "PPS": PPS }, callback_func); }
    obj.AMT_SetupAndConfigurationService_GetProvisioningAuditRecord = function (callback_func) { obj.Exec("AMT_SetupAndConfigurationService", "GetProvisioningAuditRecord", {}, callback_func); }
    obj.AMT_SetupAndConfigurationService_GetUuid = function (callback_func) { obj.Exec("AMT_SetupAndConfigurationService", "GetUuid", {}, callback_func); }
    obj.AMT_SetupAndConfigurationService_GetUnprovisionBlockingComponents = function (callback_func) { obj.Exec("AMT_SetupAndConfigurationService", "GetUnprovisionBlockingComponents", {}, callback_func); }
    obj.AMT_SetupAndConfigurationService_GetProvisioningAuditRecordV2 = function (callback_func) { obj.Exec("AMT_SetupAndConfigurationService", "GetProvisioningAuditRecordV2", {}, callback_func); }
    obj.AMT_SystemDefensePolicy_GetTimeout = function (callback_func) { obj.Exec("AMT_SystemDefensePolicy", "GetTimeout", {}, callback_func); }
    obj.AMT_SystemDefensePolicy_SetTimeout = function (Timeout, callback_func) { obj.Exec("AMT_SystemDefensePolicy", "SetTimeout", { "Timeout": Timeout }, callback_func); }
    obj.AMT_SystemDefensePolicy_UpdateStatistics = function (NetworkInterface, ResetOnRead, callback_func) { obj.Exec("AMT_SystemDefensePolicy", "UpdateStatistics", { "NetworkInterface": NetworkInterface, "ResetOnRead": ResetOnRead }, callback_func); }
    obj.AMT_SystemPowerScheme_SetPowerScheme = function (callback_func) { obj.Exec("AMT_SystemPowerScheme", "SetPowerScheme", {}, callback_func); }
    obj.AMT_ThirdPartyDataStorageAdministrationService_GetGlobalStorageAttributes = function (callback_func) { obj.Exec("AMT_ThirdPartyDataStorageAdministrationService", "GetGlobalStorageAttributes", {}, callback_func); }
    obj.AMT_ThirdPartyDataStorageAdministrationService_SetGlobalStorageAttributes = function (MaxPartnerStorage, MaxNonPartnerTotalAllocationSize, callback_func) { obj.Exec("AMT_ThirdPartyDataStorageAdministrationService", "SetGlobalStorageAttributes", { "MaxPartnerStorage": MaxPartnerStorage, "MaxNonPartnerTotalAllocationSize": MaxNonPartnerTotalAllocationSize }, callback_func); }
    obj.AMT_ThirdPartyDataStorageAdministrationService_AdminGetRegisteredApplications = function (callback_func) { obj.Exec("AMT_ThirdPartyDataStorageAdministrationService", "AdminGetRegisteredApplications", {}, callback_func); }
    obj.AMT_ThirdPartyDataStorageAdministrationService_AdminGetApplicationAttributes = function (Handle, callback_func) { obj.Exec("AMT_ThirdPartyDataStorageAdministrationService", "AdminGetApplicationAttributes", { "Handle": Handle }, callback_func); }
    obj.AMT_ThirdPartyDataStorageAdministrationService_AdminRemoveApplication = function (Handle, callback_func) { obj.Exec("AMT_ThirdPartyDataStorageAdministrationService", "AdminRemoveApplication", { "Handle": Handle }, callback_func); }
    obj.AMT_ThirdPartyDataStorageAdministrationService_AddStorageEaclEntry = function (EnterpriseName, callback_func) { obj.Exec("AMT_ThirdPartyDataStorageAdministrationService", "AddStorageEaclEntry", { "EnterpriseName": EnterpriseName }, callback_func); }
    obj.AMT_ThirdPartyDataStorageAdministrationService_EnumerateStorageEaclEntries = function (callback_func) { obj.Exec("AMT_ThirdPartyDataStorageAdministrationService", "EnumerateStorageEaclEntries", {}, callback_func); }
    obj.AMT_ThirdPartyDataStorageAdministrationService_GetStorageEaclEntry = function (Handle, callback_func) { obj.Exec("AMT_ThirdPartyDataStorageAdministrationService", "GetStorageEaclEntry", { "Handle": Handle }, callback_func); }
    obj.AMT_ThirdPartyDataStorageAdministrationService_RemoveStorageEaclEntry = function (Handle, callback_func) { obj.Exec("AMT_ThirdPartyDataStorageAdministrationService", "RemoveStorageEaclEntry", { "Handle": Handle }, callback_func); }
    obj.AMT_ThirdPartyDataStorageAdministrationService_AddStorageFpaclEntry = function (AttrType, ApplicationName, VendorName, IsPartner, TotalAllocationSize, callback_func) { obj.Exec("AMT_ThirdPartyDataStorageAdministrationService", "AddStorageFpaclEntry", { "AttrType": AttrType, "ApplicationName": ApplicationName, "VendorName": VendorName, "IsPartner": IsPartner, "TotalAllocationSize": TotalAllocationSize }, callback_func); }
    obj.AMT_ThirdPartyDataStorageAdministrationService_EnumerateStorageAllocEntries = function (callback_func) { obj.Exec("AMT_ThirdPartyDataStorageAdministrationService", "EnumerateStorageAllocEntries", {}, callback_func); }
    obj.AMT_ThirdPartyDataStorageAdministrationService_GetStorageAllocEntry = function (Handle, callback_func) { obj.Exec("AMT_ThirdPartyDataStorageAdministrationService", "GetStorageAllocEntry", { "Handle": Handle }, callback_func); }
    obj.AMT_ThirdPartyDataStorageAdministrationService_UpdateStorageFpaclEntry = function (Handle, NewAllocationSize, callback_func) { obj.Exec("AMT_ThirdPartyDataStorageAdministrationService", "UpdateStorageFpaclEntry", { "Handle": Handle, "NewAllocationSize": NewAllocationSize }, callback_func); }
    obj.AMT_ThirdPartyDataStorageAdministrationService_RemoveStorageFpaclEntry = function (Handle, callback_func) { obj.Exec("AMT_ThirdPartyDataStorageAdministrationService", "RemoveStorageFpaclEntry", { "Handle": Handle }, callback_func); }
    obj.AMT_ThirdPartyDataStorageService_GetMTU = function (callback_func) { obj.Exec("AMT_ThirdPartyDataStorageService", "GetMTU", {}, callback_func); }
    obj.AMT_ThirdPartyDataStorageService_RegisterApplication = function (CallerUUID, VendorName, ApplicationName, EnterpriseName, callback_func) { obj.Exec("AMT_ThirdPartyDataStorageService", "RegisterApplication", { "CallerUUID": CallerUUID, "VendorName": VendorName, "ApplicationName": ApplicationName, "EnterpriseName": EnterpriseName }, callback_func); }
    obj.AMT_ThirdPartyDataStorageService_UnregisterApplication = function (SessionHandle, callback_func) { obj.Exec("AMT_ThirdPartyDataStorageService", "UnregisterApplication", { "SessionHandle": SessionHandle }, callback_func); }
    obj.AMT_ThirdPartyDataStorageService_GetRegisteredApplications = function (SessionHandle, callback_func) { obj.Exec("AMT_ThirdPartyDataStorageService", "GetRegisteredApplications", { "SessionHandle": SessionHandle }, callback_func); }
    obj.AMT_ThirdPartyDataStorageService_GetCurrentApplicationHandle = function (SessionHandle, callback_func) { obj.Exec("AMT_ThirdPartyDataStorageService", "GetCurrentApplicationHandle", { "SessionHandle": SessionHandle }, callback_func); }
    obj.AMT_ThirdPartyDataStorageService_GetApplicationAttributes = function (SessionHandle, ApplicationBeingRequested, callback_func) { obj.Exec("AMT_ThirdPartyDataStorageService", "GetApplicationAttributes", { "SessionHandle": SessionHandle, "ApplicationBeingRequested": ApplicationBeingRequested }, callback_func); }
    obj.AMT_ThirdPartyDataStorageService_RemoveApplication = function (SessionHandle, callback_func) { obj.Exec("AMT_ThirdPartyDataStorageService", "RemoveApplication", { "SessionHandle": SessionHandle }, callback_func); }
    obj.AMT_ThirdPartyDataStorageService_GetBytesAvailable = function (SessionHandle, callback_func) { obj.Exec("AMT_ThirdPartyDataStorageService", "GetBytesAvailable", { "SessionHandle": SessionHandle }, callback_func); }
    obj.AMT_ThirdPartyDataStorageService_AllocateBlock = function (SessionHandle, BytesRequested, BlockHidden, BlockName, callback_func) { obj.Exec("AMT_ThirdPartyDataStorageService", "AllocateBlock", { "SessionHandle": SessionHandle, "BytesRequested": BytesRequested, "BlockHidden": BlockHidden, "BlockName": BlockName }, callback_func); }
    obj.AMT_ThirdPartyDataStorageService_DeallocateBlock = function (SessionHandle, BlockHandle, callback_func) { obj.Exec("AMT_ThirdPartyDataStorageService", "DeallocateBlock", { "SessionHandle": SessionHandle, "BlockHandle": BlockHandle }, callback_func); }
    obj.AMT_ThirdPartyDataStorageService_RemovePermissionsGroup = function (SessionHandle, BlockHandle, GroupHandle, callback_func) { obj.Exec("AMT_ThirdPartyDataStorageService", "RemovePermissionsGroup", { "SessionHandle": SessionHandle, "BlockHandle": BlockHandle, "GroupHandle": GroupHandle }, callback_func); }
    obj.AMT_ThirdPartyDataStorageService_GetPermissionsGroupMembers = function (SessionHandle, BlockHandle, GroupHandle, callback_func) { obj.Exec("AMT_ThirdPartyDataStorageService", "GetPermissionsGroupMembers", { "SessionHandle": SessionHandle, "BlockHandle": BlockHandle, "GroupHandle": GroupHandle }, callback_func); }
    obj.AMT_ThirdPartyDataStorageService_GetAllocatedBlocks = function (SessionHandle, BlockOwnerApplication, callback_func) { obj.Exec("AMT_ThirdPartyDataStorageService", "GetAllocatedBlocks", { "SessionHandle": SessionHandle, "BlockOwnerApplication": BlockOwnerApplication }, callback_func); }
    obj.AMT_ThirdPartyDataStorageService_RemovePermissionsGroupMembers = function (SessionHandle, BlockHandle, GroupHandle, MemberHandles, callback_func) { obj.Exec("AMT_ThirdPartyDataStorageService", "RemovePermissionsGroupMembers", { "SessionHandle": SessionHandle, "BlockHandle": BlockHandle, "GroupHandle": GroupHandle, "MemberHandles": MemberHandles }, callback_func); }
    obj.AMT_ThirdPartyDataStorageService_GetBlockAttributes = function (SessionHandle, BlockHandle, callback_func) { obj.Exec("AMT_ThirdPartyDataStorageService", "GetBlockAttributes", { "SessionHandle": SessionHandle, "BlockHandle": BlockHandle }, callback_func); }
    obj.AMT_ThirdPartyDataStorageService_AddPermissionsGroupMembers = function (SessionHandle, BlockHandle, GroupHandle, MemberHandles, callback_func) { obj.Exec("AMT_ThirdPartyDataStorageService", "AddPermissionsGroupMembers", { "SessionHandle": SessionHandle, "BlockHandle": BlockHandle, "GroupHandle": GroupHandle, "MemberHandles": MemberHandles }, callback_func); }
    obj.AMT_ThirdPartyDataStorageService_UnlockBlock = function (SessionHandle, BlockHandle, callback_func) { obj.Exec("AMT_ThirdPartyDataStorageService", "UnlockBlock", { "SessionHandle": SessionHandle, "BlockHandle": BlockHandle }, callback_func); }
    obj.AMT_ThirdPartyDataStorageService_SetPermissionsGroupName = function (SessionHandle, BlockHandle, GroupHandle, GroupName, callback_func) { obj.Exec("AMT_ThirdPartyDataStorageService", "SetPermissionsGroupName", { "SessionHandle": SessionHandle, "BlockHandle": BlockHandle, "GroupHandle": GroupHandle, "GroupName": GroupName }, callback_func); }
    obj.AMT_ThirdPartyDataStorageService_GetTimeoutValues = function (callback_func) { obj.Exec("AMT_ThirdPartyDataStorageService", "GetTimeoutValues", {}, callback_func); }
    obj.AMT_ThirdPartyDataStorageService_ReadBlock = function (SessionHandle, BlockHandle, ByteOffset, ByteCount, callback_func) { obj.Exec("AMT_ThirdPartyDataStorageService", "ReadBlock", { "SessionHandle": SessionHandle, "BlockHandle": BlockHandle, "ByteOffset": ByteOffset, "ByteCount": ByteCount }, callback_func); }
    obj.AMT_ThirdPartyDataStorageService_WriteBlock = function (SessionHandle, BlockHandle, ByteOffset, Data, callback_func) { obj.Exec("AMT_ThirdPartyDataStorageService", "WriteBlock", { "SessionHandle": SessionHandle, "BlockHandle": BlockHandle, "ByteOffset": ByteOffset, "Data": Data }, callback_func); }
    obj.AMT_ThirdPartyDataStorageService_SetPermissionsGroupPermissions = function (SessionHandle, BlockHandle, GroupHandle, Permissions, callback_func) { obj.Exec("AMT_ThirdPartyDataStorageService", "SetPermissionsGroupPermissions", { "SessionHandle": SessionHandle, "BlockHandle": BlockHandle, "GroupHandle": GroupHandle, "Permissions": Permissions }, callback_func); }
    obj.AMT_ThirdPartyDataStorageService_SetBlockVisibility = function (SessionHandle, BlockHandle, BlockHidden, callback_func) { obj.Exec("AMT_ThirdPartyDataStorageService", "SetBlockVisibility", { "SessionHandle": SessionHandle, "BlockHandle": BlockHandle, "BlockHidden": BlockHidden }, callback_func); }
    obj.AMT_ThirdPartyDataStorageService_GetPermissionsGroupAttributes = function (SessionHandle, BlockHandle, GroupHandle, callback_func) { obj.Exec("AMT_ThirdPartyDataStorageService", "GetPermissionsGroupAttributes", { "SessionHandle": SessionHandle, "BlockHandle": BlockHandle, "GroupHandle": GroupHandle }, callback_func); }
    obj.AMT_ThirdPartyDataStorageService_GetPermissionsGroups = function (SessionHandle, BlockHandle, callback_func) { obj.Exec("AMT_ThirdPartyDataStorageService", "GetPermissionsGroups", { "SessionHandle": SessionHandle, "BlockHandle": BlockHandle }, callback_func); }
    obj.AMT_ThirdPartyDataStorageService_SetBlockName = function (SessionHandle, BlockHandle, BlockName, callback_func) { obj.Exec("AMT_ThirdPartyDataStorageService", "SetBlockName", { "SessionHandle": SessionHandle, "BlockHandle": BlockHandle, "BlockName": BlockName }, callback_func); }
    obj.AMT_ThirdPartyDataStorageService_AddPermissionsGroup = function (SessionHandle, BlockHandle, GroupPermissions, GroupName, callback_func) { obj.Exec("AMT_ThirdPartyDataStorageService", "AddPermissionsGroup", { "SessionHandle": SessionHandle, "BlockHandle": BlockHandle, "GroupPermissions": GroupPermissions, "GroupName": GroupName }, callback_func); }
    obj.AMT_ThirdPartyDataStorageService_LockBlock = function (SessionHandle, BlockHandle, callback_func) { obj.Exec("AMT_ThirdPartyDataStorageService", "LockBlock", { "SessionHandle": SessionHandle, "BlockHandle": BlockHandle }, callback_func); }
    obj.AMT_ThirdPartyDataStorageService_GetWriteEraseLimit = function (callback_func) { obj.Exec("AMT_ThirdPartyDataStorageService", "GetWriteEraseLimit", {}, callback_func); }
    obj.AMT_TimeSynchronizationService_GetLowAccuracyTimeSynch = function (callback_func) { obj.Exec("AMT_TimeSynchronizationService", "GetLowAccuracyTimeSynch", {}, callback_func); }
    obj.AMT_TimeSynchronizationService_SetHighAccuracyTimeSynch = function (Ta0, Tm1, Tm2, callback_func) { obj.Exec("AMT_TimeSynchronizationService", "SetHighAccuracyTimeSynch", { "Ta0": Ta0, "Tm1": Tm1, "Tm2": Tm2 }, callback_func); }
    obj.AMT_UserInitiatedConnectionService_RequestStateChange = function (RequestedState, TimeoutPeriod, callback_func) { obj.Exec("AMT_UserInitiatedConnectionService", "RequestStateChange", { "RequestedState": RequestedState, "TimeoutPeriod": TimeoutPeriod }, callback_func); }
    obj.AMT_WebUIService_RequestStateChange = function (RequestedState, TimeoutPeriod, callback_func) { obj.Exec("AMT_WebUIService", "RequestStateChange", { "RequestedState": RequestedState, "TimeoutPeriod": TimeoutPeriod }, callback_func); }
    obj.AMT_WiFiPortConfigurationService_AddWiFiSettings = function (WiFiEndpoint, WiFiEndpointSettingsInput, IEEE8021xSettingsInput, ClientCredential, CACredential, callback_func) { obj.ExecWithXml("AMT_WiFiPortConfigurationService", "AddWiFiSettings", { "WiFiEndpoint": WiFiEndpoint, "WiFiEndpointSettingsInput": WiFiEndpointSettingsInput, "IEEE8021xSettingsInput": IEEE8021xSettingsInput, "ClientCredential": ClientCredential, "CACredential": CACredential }, callback_func);  }
    obj.AMT_WiFiPortConfigurationService_UpdateWiFiSettings = function (WiFiEndpointSettings, WiFiEndpointSettingsInput, IEEE8021xSettingsInput, ClientCredential, CACredential, callback_func) { obj.ExecWithXml("AMT_WiFiPortConfigurationService", "UpdateWiFiSettings", { "WiFiEndpointSettings": WiFiEndpointSettings, "WiFiEndpointSettingsInput": WiFiEndpointSettingsInput, "IEEE8021xSettingsInput": IEEE8021xSettingsInput, "ClientCredential": ClientCredential, "CACredential": CACredential }, callback_func); }
    obj.AMT_WiFiPortConfigurationService_DeleteAllITProfiles = function (_method_dummy, callback_func) { obj.Exec("AMT_WiFiPortConfigurationService", "DeleteAllITProfiles", { "_method_dummy": _method_dummy }, callback_func); }
    obj.AMT_WiFiPortConfigurationService_DeleteAllUserProfiles = function (_method_dummy, callback_func) { obj.Exec("AMT_WiFiPortConfigurationService", "DeleteAllUserProfiles", { "_method_dummy": _method_dummy }, callback_func); }
    obj.CIM_Account_RequestStateChange = function (RequestedState, TimeoutPeriod, callback_func) { obj.Exec("CIM_Account", "RequestStateChange", { "RequestedState": RequestedState, "TimeoutPeriod": TimeoutPeriod }, callback_func); }
    obj.CIM_AccountManagementService_CreateAccount = function (System, AccountTemplate, callback_func) { obj.Exec("CIM_AccountManagementService", "CreateAccount", { "System": System, "AccountTemplate": AccountTemplate }, callback_func); }
    obj.CIM_BootConfigSetting_ChangeBootOrder = function (Source, callback_func) { obj.Exec("CIM_BootConfigSetting", "ChangeBootOrder", { "Source": Source }, callback_func); }
    obj.CIM_BootService_SetBootConfigRole = function (BootConfigSetting, Role, callback_func) { obj.Exec("CIM_BootService", "SetBootConfigRole", { "BootConfigSetting": BootConfigSetting, "Role": Role }, callback_func, 0, 1); }
    obj.CIM_Card_ConnectorPower = function (Connector, PoweredOn, callback_func) { obj.Exec("CIM_Card", "ConnectorPower", { "Connector": Connector, "PoweredOn": PoweredOn }, callback_func); }
    obj.CIM_Card_IsCompatible = function (ElementToCheck, callback_func) { obj.Exec("CIM_Card", "IsCompatible", { "ElementToCheck": ElementToCheck }, callback_func); }
    obj.CIM_Chassis_IsCompatible = function (ElementToCheck, callback_func) { obj.Exec("CIM_Chassis", "IsCompatible", { "ElementToCheck": ElementToCheck }, callback_func); }
    obj.CIM_Fan_SetSpeed = function (DesiredSpeed, callback_func) { obj.Exec("CIM_Fan", "SetSpeed", { "DesiredSpeed": DesiredSpeed }, callback_func); }
    obj.CIM_KVMRedirectionSAP_RequestStateChange = function (RequestedState, TimeoutPeriod, callback_func) { obj.Exec("CIM_KVMRedirectionSAP", "RequestStateChange", { "RequestedState": RequestedState/*, "TimeoutPeriod": TimeoutPeriod */}, callback_func); }
    obj.CIM_MediaAccessDevice_LockMedia = function (Lock, callback_func) { obj.Exec("CIM_MediaAccessDevice", "LockMedia", { "Lock": Lock }, callback_func); }
    obj.CIM_MediaAccessDevice_SetPowerState = function (PowerState, Time, callback_func) { obj.Exec("CIM_MediaAccessDevice", "SetPowerState", { "PowerState": PowerState, "Time": Time }, callback_func); }
    obj.CIM_MediaAccessDevice_Reset = function (callback_func) { obj.Exec("CIM_MediaAccessDevice", "Reset", {}, callback_func); }
    obj.CIM_MediaAccessDevice_EnableDevice = function (Enabled, callback_func) { obj.Exec("CIM_MediaAccessDevice", "EnableDevice", { "Enabled": Enabled }, callback_func); }
    obj.CIM_MediaAccessDevice_OnlineDevice = function (Online, callback_func) { obj.Exec("CIM_MediaAccessDevice", "OnlineDevice", { "Online": Online }, callback_func); }
    obj.CIM_MediaAccessDevice_QuiesceDevice = function (Quiesce, callback_func) { obj.Exec("CIM_MediaAccessDevice", "QuiesceDevice", { "Quiesce": Quiesce }, callback_func); }
    obj.CIM_MediaAccessDevice_SaveProperties = function (callback_func) { obj.Exec("CIM_MediaAccessDevice", "SaveProperties", {}, callback_func); }
    obj.CIM_MediaAccessDevice_RestoreProperties = function (callback_func) { obj.Exec("CIM_MediaAccessDevice", "RestoreProperties", {}, callback_func); }
    obj.CIM_MediaAccessDevice_RequestStateChange = function (RequestedState, TimeoutPeriod, callback_func) { obj.Exec("CIM_MediaAccessDevice", "RequestStateChange", { "RequestedState": RequestedState, "TimeoutPeriod": TimeoutPeriod }, callback_func); }
    obj.CIM_PhysicalFrame_IsCompatible = function (ElementToCheck, callback_func) { obj.Exec("CIM_PhysicalFrame", "IsCompatible", { "ElementToCheck": ElementToCheck }, callback_func); }
    obj.CIM_PhysicalPackage_IsCompatible = function (ElementToCheck, callback_func) { obj.Exec("CIM_PhysicalPackage", "IsCompatible", { "ElementToCheck": ElementToCheck }, callback_func); }
    obj.CIM_PowerManagementService_RequestPowerStateChange = function (PowerState, ManagedElement, Time, TimeoutPeriod, callback_func) { obj.Exec("CIM_PowerManagementService", "RequestPowerStateChange", { "PowerState": PowerState, "ManagedElement": ManagedElement, "Time": Time, "TimeoutPeriod": TimeoutPeriod }, callback_func, 0, 1); }
    obj.CIM_PowerSupply_SetPowerState = function (PowerState, Time, callback_func) { obj.Exec("CIM_PowerSupply", "SetPowerState", { "PowerState": PowerState, "Time": Time }, callback_func); }
    obj.CIM_PowerSupply_Reset = function (callback_func) { obj.Exec("CIM_PowerSupply", "Reset", {}, callback_func); }
    obj.CIM_PowerSupply_EnableDevice = function (Enabled, callback_func) { obj.Exec("CIM_PowerSupply", "EnableDevice", { "Enabled": Enabled }, callback_func); }
    obj.CIM_PowerSupply_OnlineDevice = function (Online, callback_func) { obj.Exec("CIM_PowerSupply", "OnlineDevice", { "Online": Online }, callback_func); }
    obj.CIM_PowerSupply_QuiesceDevice = function (Quiesce, callback_func) { obj.Exec("CIM_PowerSupply", "QuiesceDevice", { "Quiesce": Quiesce }, callback_func); }
    obj.CIM_PowerSupply_SaveProperties = function (callback_func) { obj.Exec("CIM_PowerSupply", "SaveProperties", {}, callback_func); }
    obj.CIM_PowerSupply_RestoreProperties = function (callback_func) { obj.Exec("CIM_PowerSupply", "RestoreProperties", {}, callback_func); }
    obj.CIM_PowerSupply_RequestStateChange = function (RequestedState, TimeoutPeriod, callback_func) { obj.Exec("CIM_PowerSupply", "RequestStateChange", { "RequestedState": RequestedState, "TimeoutPeriod": TimeoutPeriod }, callback_func); }
    obj.CIM_Processor_SetPowerState = function (PowerState, Time, callback_func) { obj.Exec("CIM_Processor", "SetPowerState", { "PowerState": PowerState, "Time": Time }, callback_func); }
    obj.CIM_Processor_Reset = function (callback_func) { obj.Exec("CIM_Processor", "Reset", {}, callback_func); }
    obj.CIM_Processor_EnableDevice = function (Enabled, callback_func) { obj.Exec("CIM_Processor", "EnableDevice", { "Enabled": Enabled }, callback_func); }
    obj.CIM_Processor_OnlineDevice = function (Online, callback_func) { obj.Exec("CIM_Processor", "OnlineDevice", { "Online": Online }, callback_func); }
    obj.CIM_Processor_QuiesceDevice = function (Quiesce, callback_func) { obj.Exec("CIM_Processor", "QuiesceDevice", { "Quiesce": Quiesce }, callback_func); }
    obj.CIM_Processor_SaveProperties = function (callback_func) { obj.Exec("CIM_Processor", "SaveProperties", {}, callback_func); }
    obj.CIM_Processor_RestoreProperties = function (callback_func) { obj.Exec("CIM_Processor", "RestoreProperties", {}, callback_func); }
    obj.CIM_Processor_RequestStateChange = function (RequestedState, TimeoutPeriod, callback_func) { obj.Exec("CIM_Processor", "RequestStateChange", { "RequestedState": RequestedState, "TimeoutPeriod": TimeoutPeriod }, callback_func); }
    obj.CIM_RecordLog_ClearLog = function (callback_func) { obj.Exec("CIM_RecordLog", "ClearLog", {}, callback_func); }
    obj.CIM_RecordLog_RequestStateChange = function (RequestedState, TimeoutPeriod, callback_func) { obj.Exec("CIM_RecordLog", "RequestStateChange", { "RequestedState": RequestedState, "TimeoutPeriod": TimeoutPeriod }, callback_func); }
    obj.CIM_RedirectionService_RequestStateChange = function (RequestedState, TimeoutPeriod, callback_func) { obj.Exec("CIM_RedirectionService", "RequestStateChange", { "RequestedState": RequestedState, "TimeoutPeriod": TimeoutPeriod }, callback_func); }
    obj.CIM_Sensor_SetPowerState = function (PowerState, Time, callback_func) { obj.Exec("CIM_Sensor", "SetPowerState", { "PowerState": PowerState, "Time": Time }, callback_func); }
    obj.CIM_Sensor_Reset = function (callback_func) { obj.Exec("CIM_Sensor", "Reset", {}, callback_func); }
    obj.CIM_Sensor_EnableDevice = function (Enabled, callback_func) { obj.Exec("CIM_Sensor", "EnableDevice", { "Enabled": Enabled }, callback_func); }
    obj.CIM_Sensor_OnlineDevice = function (Online, callback_func) { obj.Exec("CIM_Sensor", "OnlineDevice", { "Online": Online }, callback_func); }
    obj.CIM_Sensor_QuiesceDevice = function (Quiesce, callback_func) { obj.Exec("CIM_Sensor", "QuiesceDevice", { "Quiesce": Quiesce }, callback_func); }
    obj.CIM_Sensor_SaveProperties = function (callback_func) { obj.Exec("CIM_Sensor", "SaveProperties", {}, callback_func); }
    obj.CIM_Sensor_RestoreProperties = function (callback_func) { obj.Exec("CIM_Sensor", "RestoreProperties", {}, callback_func); }
    obj.CIM_Sensor_RequestStateChange = function (RequestedState, TimeoutPeriod, callback_func) { obj.Exec("CIM_Sensor", "RequestStateChange", { "RequestedState": RequestedState, "TimeoutPeriod": TimeoutPeriod }, callback_func); }
    obj.CIM_StatisticalData_ResetSelectedStats = function (SelectedStatistics, callback_func) { obj.Exec("CIM_StatisticalData", "ResetSelectedStats", { "SelectedStatistics": SelectedStatistics }, callback_func); }
    obj.CIM_Watchdog_KeepAlive = function (callback_func) { obj.Exec("CIM_Watchdog", "KeepAlive", {}, callback_func); }
    obj.CIM_Watchdog_SetPowerState = function (PowerState, Time, callback_func) { obj.Exec("CIM_Watchdog", "SetPowerState", { "PowerState": PowerState, "Time": Time }, callback_func); }
    obj.CIM_Watchdog_Reset = function (callback_func) { obj.Exec("CIM_Watchdog", "Reset", {}, callback_func); }
    obj.CIM_Watchdog_EnableDevice = function (Enabled, callback_func) { obj.Exec("CIM_Watchdog", "EnableDevice", { "Enabled": Enabled }, callback_func); }
    obj.CIM_Watchdog_OnlineDevice = function (Online, callback_func) { obj.Exec("CIM_Watchdog", "OnlineDevice", { "Online": Online }, callback_func); }
    obj.CIM_Watchdog_QuiesceDevice = function (Quiesce, callback_func) { obj.Exec("CIM_Watchdog", "QuiesceDevice", { "Quiesce": Quiesce }, callback_func); }
    obj.CIM_Watchdog_SaveProperties = function (callback_func) { obj.Exec("CIM_Watchdog", "SaveProperties", {}, callback_func); }
    obj.CIM_Watchdog_RestoreProperties = function (callback_func) { obj.Exec("CIM_Watchdog", "RestoreProperties", {}, callback_func); }
    obj.CIM_Watchdog_RequestStateChange = function (RequestedState, TimeoutPeriod, callback_func) { obj.Exec("CIM_Watchdog", "RequestStateChange", { "RequestedState": RequestedState, "TimeoutPeriod": TimeoutPeriod }, callback_func); }
    obj.CIM_WiFiPort_SetPowerState = function (PowerState, Time, callback_func) { obj.Exec("CIM_WiFiPort", "SetPowerState", { "PowerState": PowerState, "Time": Time }, callback_func); }
    obj.CIM_WiFiPort_Reset = function (callback_func) { obj.Exec("CIM_WiFiPort", "Reset", {}, callback_func); }
    obj.CIM_WiFiPort_EnableDevice = function (Enabled, callback_func) { obj.Exec("CIM_WiFiPort", "EnableDevice", { "Enabled": Enabled }, callback_func); }
    obj.CIM_WiFiPort_OnlineDevice = function (Online, callback_func) { obj.Exec("CIM_WiFiPort", "OnlineDevice", { "Online": Online }, callback_func); }
    obj.CIM_WiFiPort_QuiesceDevice = function (Quiesce, callback_func) { obj.Exec("CIM_WiFiPort", "QuiesceDevice", { "Quiesce": Quiesce }, callback_func); }
    obj.CIM_WiFiPort_SaveProperties = function (callback_func) { obj.Exec("CIM_WiFiPort", "SaveProperties", {}, callback_func); }
    obj.CIM_WiFiPort_RestoreProperties = function (callback_func) { obj.Exec("CIM_WiFiPort", "RestoreProperties", {}, callback_func); }
    obj.CIM_WiFiPort_RequestStateChange = function (RequestedState, TimeoutPeriod, callback_func) { obj.Exec("CIM_WiFiPort", "RequestStateChange", { "RequestedState": RequestedState, "TimeoutPeriod": TimeoutPeriod }, callback_func); }
    obj.IPS_HostBasedSetupService_Setup = function (NetAdminPassEncryptionType, NetworkAdminPassword, McNonce, Certificate, SigningAlgorithm, DigitalSignature, callback_func) { obj.Exec("IPS_HostBasedSetupService", "Setup", { "NetAdminPassEncryptionType": NetAdminPassEncryptionType, "NetworkAdminPassword": NetworkAdminPassword, "McNonce": McNonce, "Certificate": Certificate, "SigningAlgorithm": SigningAlgorithm, "DigitalSignature": DigitalSignature }, callback_func); }
    obj.IPS_HostBasedSetupService_AddNextCertInChain = function (NextCertificate, IsLeafCertificate, IsRootCertificate, callback_func) { obj.Exec("IPS_HostBasedSetupService", "AddNextCertInChain", { "NextCertificate": NextCertificate, "IsLeafCertificate": IsLeafCertificate, "IsRootCertificate": IsRootCertificate }, callback_func); }
    obj.IPS_HostBasedSetupService_AdminSetup = function (NetAdminPassEncryptionType, NetworkAdminPassword, McNonce, SigningAlgorithm, DigitalSignature, callback_func) { obj.Exec("IPS_HostBasedSetupService", "AdminSetup", { "NetAdminPassEncryptionType": NetAdminPassEncryptionType, "NetworkAdminPassword": NetworkAdminPassword, "McNonce": McNonce, "SigningAlgorithm": SigningAlgorithm, "DigitalSignature": DigitalSignature }, callback_func); }
    obj.IPS_HostBasedSetupService_UpgradeClientToAdmin = function (McNonce, SigningAlgorithm, DigitalSignature, callback_func) { obj.Exec("IPS_HostBasedSetupService", "UpgradeClientToAdmin", { "McNonce": McNonce, "SigningAlgorithm": SigningAlgorithm, "DigitalSignature": DigitalSignature }, callback_func); }
    obj.IPS_HostBasedSetupService_DisableClientControlMode = function (_method_dummy, callback_func) { obj.Exec("IPS_HostBasedSetupService", "DisableClientControlMode", { "_method_dummy": _method_dummy }, callback_func); }
    obj.IPS_KVMRedirectionSettingData_TerminateSession = function (callback_func) { obj.Exec("IPS_KVMRedirectionSettingData", "TerminateSession", {}, callback_func); }
    obj.IPS_OptInService_StartOptIn = function (callback_func) { obj.Exec("IPS_OptInService", "StartOptIn", {}, callback_func); }
    obj.IPS_OptInService_CancelOptIn = function (callback_func) { obj.Exec("IPS_OptInService", "CancelOptIn", {}, callback_func); }
    obj.IPS_OptInService_SendOptInCode = function (OptInCode, callback_func) { obj.Exec("IPS_OptInService", "SendOptInCode", { "OptInCode": OptInCode }, callback_func); }
    obj.IPS_OptInService_StartService = function (callback_func) { obj.Exec("IPS_OptInService", "StartService", {}, callback_func); }
    obj.IPS_OptInService_StopService = function (callback_func) { obj.Exec("IPS_OptInService", "StopService", {}, callback_func); }
    obj.IPS_OptInService_RequestStateChange = function (RequestedState, TimeoutPeriod, callback_func) { obj.Exec("IPS_OptInService", "RequestStateChange", { "RequestedState": RequestedState, "TimeoutPeriod": TimeoutPeriod }, callback_func); }
    obj.IPS_ProvisioningRecordLog_RequestStateChange = function (RequestedState, TimeoutPeriod, callback_func) { obj.Exec("IPS_ProvisioningRecordLog", "RequestStateChange", { "RequestedState": RequestedState, "TimeoutPeriod": TimeoutPeriod }, callback_func); }
    obj.IPS_ProvisioningRecordLog_ClearLog = function (_method_dummy, callback_func) { obj.Exec("IPS_ProvisioningRecordLog", "ClearLog", { "_method_dummy": _method_dummy }, callback_func); }
    obj.IPS_SecIOService_RequestStateChange = function (RequestedState, TimeoutPeriod, callback_func) { obj.Exec("IPS_SecIOService", "RequestStateChange", { "RequestedState": RequestedState, "TimeoutPeriod": TimeoutPeriod }, callback_func); }

    obj.AmtStatusToStr = function (code) { if (obj.AmtStatusCodes[code]) return obj.AmtStatusCodes[code]; else return "UNKNOWN_ERROR" }
    obj.AmtStatusCodes = {
        0x0000: "SUCCESS",
        0x0001: "INTERNAL_ERROR",
        0x0002: "NOT_READY",
        0x0003: "INVALID_PT_MODE",
        0x0004: "INVALID_MESSAGE_LENGTH",
        0x0005: "TABLE_FINGERPRINT_NOT_AVAILABLE",
        0x0006: "INTEGRITY_CHECK_FAILED",
        0x0007: "UNSUPPORTED_ISVS_VERSION",
        0x0008: "APPLICATION_NOT_REGISTERED",
        0x0009: "INVALID_REGISTRATION_DATA",
        0x000A: "APPLICATION_DOES_NOT_EXIST",
        0x000B: "NOT_ENOUGH_STORAGE",
        0x000C: "INVALID_NAME",
        0x000D: "BLOCK_DOES_NOT_EXIST",
        0x000E: "INVALID_BYTE_OFFSET",
        0x000F: "INVALID_BYTE_COUNT",
        0x0010: "NOT_PERMITTED",
        0x0011: "NOT_OWNER",
        0x0012: "BLOCK_LOCKED_BY_OTHER",
        0x0013: "BLOCK_NOT_LOCKED",
        0x0014: "INVALID_GROUP_PERMISSIONS",
        0x0015: "GROUP_DOES_NOT_EXIST",
        0x0016: "INVALID_MEMBER_COUNT",
        0x0017: "MAX_LIMIT_REACHED",
        0x0018: "INVALID_AUTH_TYPE",
        0x0019: "AUTHENTICATION_FAILED",
        0x001A: "INVALID_DHCP_MODE",
        0x001B: "INVALID_IP_ADDRESS",
        0x001C: "INVALID_DOMAIN_NAME",
        0x001D: "UNSUPPORTED_VERSION",
        0x001E: "REQUEST_UNEXPECTED",
        0x001F: "INVALID_TABLE_TYPE",
        0x0020: "INVALID_PROVISIONING_STATE",
        0x0021: "UNSUPPORTED_OBJECT",
        0x0022: "INVALID_TIME",
        0x0023: "INVALID_INDEX",
        0x0024: "INVALID_PARAMETER",
        0x0025: "INVALID_NETMASK",
        0x0026: "FLASH_WRITE_LIMIT_EXCEEDED",
        0x0027: "INVALID_IMAGE_LENGTH",
        0x0028: "INVALID_IMAGE_SIGNATURE",
        0x0029: "PROPOSE_ANOTHER_VERSION",
        0x002A: "INVALID_PID_FORMAT",
        0x002B: "INVALID_PPS_FORMAT",
        0x002C: "BIST_COMMAND_BLOCKED",
        0x002D: "CONNECTION_FAILED",
        0x002E: "CONNECTION_TOO_MANY",
        0x002F: "RNG_GENERATION_IN_PROGRESS",
        0x0030: "RNG_NOT_READY",
        0x0031: "CERTIFICATE_NOT_READY",
        0x0400: "DISABLED_BY_POLICY",
        0x0800: "NETWORK_IF_ERROR_BASE",
        0x0801: "UNSUPPORTED_OEM_NUMBER",
        0x0802: "UNSUPPORTED_BOOT_OPTION",
        0x0803: "INVALID_COMMAND",
        0x0804: "INVALID_SPECIAL_COMMAND",
        0x0805: "INVALID_HANDLE",
        0x0806: "INVALID_PASSWORD",
        0x0807: "INVALID_REALM",
        0x0808: "STORAGE_ACL_ENTRY_IN_USE",
        0x0809: "DATA_MISSING",
        0x080A: "DUPLICATE",
        0x080B: "EVENTLOG_FROZEN",
        0x080C: "PKI_MISSING_KEYS",
        0x080D: "PKI_GENERATING_KEYS",
        0x080E: "INVALID_KEY",
        0x080F: "INVALID_CERT",
        0x0810: "CERT_KEY_NOT_MATCH",
        0x0811: "MAX_KERB_DOMAIN_REACHED",
        0x0812: "UNSUPPORTED",
        0x0813: "INVALID_PRIORITY",
        0x0814: "NOT_FOUND",
        0x0815: "INVALID_CREDENTIALS",
        0x0816: "INVALID_PASSPHRASE",
        0x0818: "NO_ASSOCIATION",
        0x081B: "AUDIT_FAIL",
        0x081C: "BLOCKING_COMPONENT",
        0x0821: "USER_CONSENT_REQUIRED",
        0x1000: "APP_INTERNAL_ERROR",
        0x1001: "NOT_INITIALIZED",
        0x1002: "LIB_VERSION_UNSUPPORTED",
        0x1003: "INVALID_PARAM",
        0x1004: "RESOURCES",
        0x1005: "HARDWARE_ACCESS_ERROR",
        0x1006: "REQUESTOR_NOT_REGISTERED",
        0x1007: "NETWORK_ERROR",
        0x1008: "PARAM_BUFFER_TOO_SHORT",
        0x1009: "COM_NOT_INITIALIZED_IN_THREAD",
        0x100A: "URL_REQUIRED"
    }

    //
    // Methods used for getting the event log
    //

    obj.GetMessageLog = function (func, tag) {
        // obj.Enum("AMT_MessageLog", obj.xxGetMessageLog0, [func, tag, []]);
        obj.AMT_MessageLog_PositionToFirstRecord(obj.xxGetMessageLog0, [func, tag, []]);
    }
    obj.xxGetMessageLog0 = function (stack, name, responses, status, tag) {
        if (status != 200 || responses.Body["ReturnValue"] != '0') { tag[0](obj, null, tag[2]); return; }
        obj.AMT_MessageLog_GetRecords(responses.Body["IterationIdentifier"], 390, obj.xxGetMessageLog1, tag);
    }
    obj.xxGetMessageLog1 = function (stack, name, responses, status, tag) {
        if (status != 200 || responses.Body["ReturnValue"] != '0') { tag[0](obj, null, tag[2]); return; }
        var i, j, x, e, AmtMessages = tag[2], t = new Date(), TimeStamp;
        if (typeof responses.Body["RecordArray"] === 'string') { responses.Body["RecordArray"] = [responses.Body["RecordArray"]]; }

        for (i in responses.Body["RecordArray"]) {
            e = null;
            try {
                e = window.atob(responses.Body["RecordArray"][i]);
            } catch (e) {
                alert(e + " " + responses.Body["RecordArray"][i])
            }
            if ((TimeStamp = ReadIntX(e, 0)) != -1) {
                x = { DeviceAddress:e.charCodeAt(4), EventSensorType:e.charCodeAt(5), EventType:e.charCodeAt(6), EventOffset:e.charCodeAt(7), EventSourceType:e.charCodeAt(8), EventSeverity:e.charCodeAt(9), SensorNumber:e.charCodeAt(10), Entity:e.charCodeAt(11), EntityInstance:e.charCodeAt(12), EventData:[], TimeStamp:new Date((TimeStamp + (t.getTimezoneOffset() * 60)) * 1000) };
                for (j = 13; j < 21; j++) { x.EventData.push(e.charCodeAt(j)); }
                x.EntityStr = obj.xxSystemEntityTypes[x.Entity];
                x.DescriptionStr = obj.xxGetEventDetailStr(x.EventSensorType, x.EventOffset, x.EventData, x.Entity);
                if (!x.EntityStr) x.EntityStr = "Unknown";
                AmtMessages.push(x);
            }
        }

        if (responses.Body["NoMoreRecords"] !== "true") { obj.AMT_MessageLog_GetRecords(responses.Body["IterationIdentifier"], 390, obj.xxGetMessageLog1, [tag[0], AmtMessages, tag[2]]); } else { tag[0](obj, AmtMessages, tag[2]); }
    }

    obj.xxEventTrapSourceTypes = ["Platform firmware (e.g. BIOS)", "SMI handler", "ISV system management software", "Alert ASIC", "IPMI", "BIOS vendor", "System board set vendor", "System integrator", "Third party add-in", "OSV", "NIC", "System management card"];
    obj.xxSystemFirmwareError = [ "Unspecified.","No system memory is physically installed in the system.","No usable system memory, all installed memory has experienced an unrecoverable failure.","Unrecoverable hard-disk/ATAPI/IDE device failure.","Unrecoverable system-board failure.","Unrecoverable diskette subsystem failure.","Unrecoverable hard-disk controller failure.","Unrecoverable PS/2 or USB keyboard failure.","Removable boot media not found","Unrecoverable video controller failure","No video device detected","Firmware (BIOS) ROM corruption detected","CPU voltage mismatch (processors that share same supply have mismatched voltage requirements)","CPU speed matching failure" ];
    obj.xxSystemFirmwareProgress = [ "Unspecified.","Memory initialization.","Starting hard-disk initialization and test","Secondary processor(s) initialization","User authentication","User-initiated system setup","USB resource configuration","PCI resource configuration","Option ROM initialization","Video initialization","Cache initialization","SM Bus initialization","Keyboard controller initialization","Embedded controller/management controller initialization","Docking station attachment","Enabling docking station","Docking station ejection","Disabling docking station","Calling operating system wake-up vector","Starting operating system boot process","Baseboard or motherboard initialization","reserved","Floppy initialization","Keyboard test","Pointing device test","Primary processor initialization" ];
    obj.xxSystemEntityTypes = ["Unspecified", "Other", "Unknown", "Processor", "Disk", "Peripheral", "System management module", "System board", "Memory module", "Processor module", "Power supply", "Add in card", "Front panel board", "Back panel board", "Power system board", "Drive backplane", "System internal expansion board", "Other system board", "Processor board", "Power unit", "Power module", "Power management board", "Chassis back panel board", "System chassis", "Sub chassis", "Other chassis board", "Disk drive bay", "Peripheral bay", "Device bay", "Fan cooling", "Cooling unit", "Cable interconnect", "Memory device", "System management software", "BIOS", "Intel(r) AMT", "System bus", "Group", "Intel(r) AMT", "External environment", "Battery", "Processing blade", "Connectivity switch", "Processor/memory module", "I/O module", "Processor I/O module", "Management controller firmware", "IPMI channel", "PCI bus", "PCI express bus", "SCSI bus", "SATA/SAS bus", "Processor front side bus"];
    obj.xxRealmNames=["*Invalid", "*Reserved0", "Redirection", "PT Administration", "Hardware Asset", "Remote Control", "Storage", "Event Manager", "Storage Admin", "Agent Presence Local", "Agent Presence Remote", "Circuit Breaker", "Network Time", "General Information", "Firmware Update", "EIT", "LocalUN", "Endpoint Access Control", "Endpoint Access Control Admin", "Event Log Reader", "Audit Log", "ACL Realm", "*Reserved1", "*Reserved2", "Local System"];

    obj.xxGetEventDetailStr = function(eventSensorType, eventOffset, eventDataField, entity) {

        if (eventSensorType == 15)
        {
            if (eventDataField[0] == 235) return "Invalid Data";
            if (eventOffset == 0) return obj.xxSystemFirmwareError[eventDataField[1]];
            return obj.xxSystemFirmwareProgress[eventDataField[1]];
        }

        /*
        if (eventSensorType == 18) // System event
        {
            if (eventDataField[0] == 0xAA) // Watchdog
            {
                byte[] agent1 = new byte[4];
                byte[] agent2 = new byte[2];
                Array.Copy(eventDataField, 1, agent1, 0, 4);
                Array.Copy(eventDataField, 5, agent2, 0, 2);
                return string.Format("Agent {0}-{1}-... changed to {2}", Utils.BytesToHex(agent1), Utils.BytesToHex(agent2), AmtWatchdogRemote.TransitionStateToString((ushort)eventDataField[7]));
            }
        }

        if (eventSensorType == 5 && eventOffset == 0) // System chassis
        {
            return "Case intrusion";
        }

        if (eventSensorType == 192 && eventOffset == 0 && eventDataField[0] == 170 && eventDataField[1] == 48)
        {
            if (eventDataField[2] == 0) return "A remote Serial Over LAN session was established.";
            if (eventDataField[2] == 1) return "Remote Serial Over LAN session finished. User control was restored.";
            if (eventDataField[2] == 2) return "A remote IDE-Redirection session was established.";
            if (eventDataField[2] == 3) return "Remote IDE-Redirection session finished. User control was restored.";
        }

        if (eventSensorType == 36)
        {
            long handle = ((long)(eventDataField[1]) << 24) + ((long)(eventDataField[2]) << 16) + ((long)(eventDataField[3]) << 8) + (long)(eventDataField[4]);
            string nic = string.Format("#{0}", eventDataField[0]);
            if (eventDataField[0] == 0xAA) nic = "wired"; // TODO: Add wireless *****
            //if (eventDataField[0] == 0xAA) nic = "wireless";

            if (handle == 4294967293) { return string.Format("All received packet filter was matched on {0} interface.", nic); }
            if (handle == 4294967292) { return string.Format("All outbound packet filter was matched on {0} interface.", nic); }
            if (handle == 4294967290) { return string.Format("Spoofed packet filter was matched on {0} interface.", nic); }
            return string.Format("Filter {0} was matched on {1} interface.", handle, nic);
        }

        if (eventSensorType == 192)
        {
            if (eventDataField[2] == 0) return "Security policy invoked. Some or all network traffic (TX) was stopped.";
            if (eventDataField[2] == 2) return "Security policy invoked. Some or all network traffic (RX) was stopped.";
            return "Security policy invoked.";
        }

        if (eventSensorType == 193)
        {
            if (eventDataField[0] == 0xAA && eventDataField[1] == 0x30 && eventDataField[2] == 0x00 && eventDataField[3] == 0x00) { return "User request for remote connection."; }
            if (eventDataField[0] == 0xAA && eventDataField[1] == 0x20 && eventDataField[2] == 0x03 && eventDataField[3] == 0x01) { return "EAC error: attempt to get posture while NAC in Intel� AMT is disabled."; // eventDataField = 0xAA20030100000000 }
            if (eventDataField[0] == 0xAA && eventDataField[1] == 0x20 && eventDataField[2] == 0x04 && eventDataField[3] == 0x00) { return "Certificate revoked. "; }
        }
        */

        if (eventSensorType == 6) return "Authentication failed " + (eventDataField[1] + (eventDataField[2] << 8)) + " times. The system may be under attack.";
        if (eventSensorType == 30) return "No bootable media";
        if (eventSensorType == 32) return "Operating system lockup or power interrupt";
        if (eventSensorType == 35) return "System boot failure";
        if (eventSensorType == 37) return "System firmware started (at least one CPU is properly executing).";
        return "Unknown Sensor Type #" + eventSensorType;
    }



    obj.xxAmtAuditStringTable =
    {
        16:'SecurityAdmin',
        17:'RCO',
        18:'RedirectionManager',
        19:'FirmwareUpdateManager',
        20:'SecurityAuditLog',
        21:'NetworkTime',
        22:'NetworkAdministration',
        23:'StorageAdministration',
        24:'EventManager',
        25:'CircuitBreakerManager',
        26:'AgentPresenceManager',
        27:'WirelessConfiguration',
        28:'EAC',
        29:'KVM',
        1600:'AMTProvisioningStarted',
        1601:'AMTProvisioningCompleted',
        1602:'ACLEntryAdded',
        1603:'ACLEntryModified',
        1604:'ACLEntryRemoved',
        1605:'ACLAccessWithInvalidCredentials',
        1606:'ACLEntryEnabled',
        1607:'TLSStateChanged',
        1608:'TLSServerCertificateSet',
        1609:'TLSServerCertificateRemove',
        1610:'TLSTrustedRootCertificateAdded',
        1611:'TLSTrustedRootCertificateRemoved',
        1612:'TLSPresharedKeySet',
        1613:'KerberosSettingsModified',
        1614:'KerberosMasterKeyModified',
        1615:'FlashWearOutCountersReset',
        1616:'PowerPackageModified',
        1617:'SetRealmAuthenticationMode',
        1700:'PerformedPowerUp',
        1701:'PerformedPowerDown',
        1702:'PerformedPowerCycle',
        1703:'PerformedReset',
        1704:'SetBootOptions',
        1800:'IDERSessionOpened',
        1801:'IDERSessionClosed',
        1802:'IDEREnabled',
        1803:'IDERDisabled',
        1804:'SoLSessionOpened',
        1805:'SoLSessionClosed',
        1806:'SoLEnabled',
        1807:'SoLDisabled',
        1808:'KVMSessionStarted',
        1809:'KVMSessionEnded',
        1810:'KVMEnabled',
        1811:'KVMDisabled',
        1812:'VNCPasswordFailedThreeTimes',
        1900:'FirmwareUpdated',
        1901:'FirmwareUpdatedFailed',
        2000:'SecurityAuditLogCleared',
        2001:'SecurityAuditPolicyModified',
        2002:'SecurityAuditLogDisabled',
        2003:'SecurityAuditLogEnabled',
        2004:'SecurityAuditLogExported',
        2005:'SecurityAuditLogRecovered',
        2100:'AMTTimeSet',
        2200:'TCPIPParametersSet',
        2201:'HostNameSet',
        2202:'DomainNameSet',
        2203:'VLANParametersSet',
        2204:'LinkPolicySet',
        2205:'IPv6ParametersSet',
        2300:'GlobalStorageAttributesSet',
        2301:'StorageEACLModified',
        2302:'StorageFPACLModified',
        2303:'StorageWriteOperation',
        2400:'AlertSubscribed',
        2401:'AlertUnsubscribed',
        2402:'EventLogCleared',
        2403:'EventLogFrozen',
        2500:'CBFilterAdded',
        2501:'CBFilterRemoved',
        2502:'CBPolicyAdded',
        2503:'CBPolicyRemoved',
        2504:'CBDefaultPolicySet',
        2505:'CBHeuristicsOptionSet',
        2506:'CBheuristicsStateCleared',
        2600:'AgentWatchdogAdded',
        2601:'AgentWatchdogRemoved',
        2602:'AgentWatchdogActionSet',
        2700:'WirelessProfileAdded',
        2701:'WirelessProfileRemoved',
        2702:'WirelessProfileUpdated',
        2800:'EACPostureSignerSET',
        2801:'EACEnabled',
        2802:'EACDisabled',
        2803:'EACPostureState',
        2804:'EACSetOptions',
        2900:'KVMOptInEnabled',
        2901:'KVMOptInDisabled',
        2902:'KVMPasswordChanged',
        2903:'KVMConsentSucceeded',
        2904:'KVMConsentFailed'
    }

    obj.GetAuditLog = function (func) {
        obj.AMT_AuditLog_ReadRecords(1, obj.xxGetAuditLog0, [func, []]);
    }

    obj.xxGetAuditLog0 = function (stack, name, responses, status, tag) {
        if (status != 200) { tag[0](obj, [], status); return; }
        var ptr, i, e, x, r = tag[1], t = new Date(), TimeStamp;

        if (responses.Body.RecordsReturned > 0) {
            if (typeof (responses.Body.EventRecords) == 'string') responses.Body.EventRecords = [responses.Body.EventRecords];

            for (i in responses.Body.EventRecords) {
                e = null;
                try {
                    e = window.atob(responses.Body.EventRecords[i]);
                } catch (e) {
                    alert(e + " " + responses.Body.EventRecords[i])
                }
                x = { AuditAppID: ReadShort(e, 0), EventID: ReadShort(e, 2), InitiatorType: e.charCodeAt(4) };
                x.AuditApp = obj.xxAmtAuditStringTable[x.AuditAppID];
                x.Event = obj.xxAmtAuditStringTable[(x.AuditAppID * 100) + x.EventID];

                // Read and process the initiator
                if (x.InitiatorType == 0) {
                    // HTTP digest
                    var userlen = e.charCodeAt(5);
                    x.Initiator = e.substring(6, 6 + userlen);
                    ptr = 6 + userlen;
                }
                if (x.InitiatorType == 1) {
                    // Kerberos
                    x.KerberosUserInDomain = ReadInt(e, 5);
                    var userlen = e.charCodeAt(9);
                    x.Initiator = e.substring(10, 10 + userlen);
                    ptr = 10 + userlen;
                }
                if (x.InitiatorType == 2) {
                    // Local
                    x.Initiator = 'Local';
                    ptr = 5;
                }

                // Read timestamp
                TimeStamp = ReadInt(e, ptr);
                x.TimeStamp = new Date((TimeStamp + (t.getTimezoneOffset() * 60)) * 1000);
                ptr += 4;

                // Read network access
                x.MCLocationType = e.charCodeAt(ptr++);
                x.NetAddressLength = e.charCodeAt(ptr++);
                x.NetAddress = e.substring(ptr, ptr + x.NetAddressLength);

                // Read extended data
                ptr += x.NetAddressLength;
                x.ExtendedDataLength = e.charCodeAt(ptr++);
                x.ExtendedData = e.substring(ptr, ptr + x.ExtendedDataLength);

                r.push(x);
            }
        }
        if (responses.Body.TotalRecordCount > r.length) {
            obj.AMT_AuditLog_ReadRecords(r.length + 1, obj.xxGetAuditLog0, [tag[0], r]);
        } else {
            tag[0](obj, r, status);
        }
    }

    return obj;
}



// TinyMD5 from https://github.com/jbt/js-crypto

// Perform MD5 setup
var md5_k = [];
for (var i = 0; i < 64;) { md5_k[i] = 0 | (Math.abs(Math.sin(++i)) * 4294967296); }

// Perform MD5 on raw string and return hex
function hex_md5(str) {
    var b, c, d, j,
    x = [],
    str2 = unescape(encodeURI(str)),
    a = str2.length,
    h = [b = 1732584193, c = -271733879, ~b, ~c],
    i = 0;

    for (; i <= a;) x[i >> 2] |= (str2.charCodeAt(i) || 128) << 8 * (i++ % 4);

    x[str = (a + 8 >> 6) * 16 + 14] = a * 8;
    i = 0;

    for (; i < str; i += 16) {
        a = h; j = 0;
        for (; j < 64;) {
            a = [
              d = a[3],
              ((b = a[1] | 0) +
                ((d = (
                  (a[0] +
                    [
                      b & (c = a[2]) | ~b & d,
                      d & b | ~d & c,
                      b ^ c ^ d,
                      c ^ (b | ~d)
                    ][a = j >> 4]
                  ) +
                  (md5_k[j] +
                    (x[[
                      j,
                      5 * j + 1,
                      3 * j + 5,
                      7 * j
                    ][a] % 16 + i] | 0)
                  )
                )) << (a = [
                  7, 12, 17, 22,
                  5, 9, 14, 20,
                  4, 11, 16, 23,
                  6, 10, 15, 21
                ][4 * a + j++ % 4]) | d >>> 32 - a)
              ),
              b,
              c
            ];
        }
        for (j = 4; j;) h[--j] = h[j] + a[j];
    }

    str = '';
    for (; j < 32;) str += ((h[j >> 3] >> ((1 ^ j++ & 7) * 4)) & 15).toString(16);
    return str;
}

// Perform MD5 on raw string and return raw string result
function rstr_md5(str) { return hex2rstr(hex_md5(str)); }

// Convert a hex string to a raw string
function hex2rstr(d) {
    var r = '', m = ('' + d).match(/../g), t;
    while (t = m.shift()) r += String.fromCharCode('0x' + t);
    return r
}

// Convert a raw string to a hex string
function rstr2hex(input) {
    var hex_tab = "0123456789abcdef", r = "", x, i;
    for (i = 0; i < input.length; i++) { x = input.charCodeAt(i); r += hex_tab.charAt((x >>> 4) & 0x0F) + hex_tab.charAt(x & 0x0F); }
    return r;
}

/*
Convert arguments into selector set and body XML. Used by AMT_WiFiPortConfigurationService_UpdateWiFiSettings.
args = { 
	"WiFiEndpoint": {
		__parameterType: 'reference',
		__resourceUri: 'http://schemas.dmtf.org/wbem/wscim/1/cim-schema/2/CIM_WiFiEndpoint',
		Name: 'WiFi Endpoint 0'
	}, 
	"WiFiEndpointSettingsInput": 
	{
		__parameterType: 'instance',
		__namespace: 'http://schemas.dmtf.org/wbem/wscim/1/cim-schema/2/CIM_WiFiEndpointSettings',
		ElementName: document.querySelector('#editProfile-profileName').value,
		InstanceID: 'Intel(r) AMT:WiFi Endpoint Settings ' + document.querySelector('#editProfile-profileName').value,
		AuthenticationMethod: document.querySelector('#editProfile-networkAuthentication').value,
		//BSSType: 3, // Intel(r) AMT supports only infrastructure networks
		EncryptionMethod: document.querySelector('#editProfile-encryption').value,
		SSID: document.querySelector('#editProfile-networkName').value,
		Priority: 100,
		PSKPassPhrase: document.querySelector('#editProfile-passPhrase').value
	}, 
	"IEEE8021xSettingsInput": null, 
	"ClientCredential": null, 
	"CACredential": null 
}, 
*/
function execArgumentsToXml(args) {
	if(args === undefined || args === null) return null;
	
	var result = '';
	for(var argName in args) {
		var arg = args[argName];
		if(!arg) continue;
		if(arg['__parameterType'] === 'reference') result += referenceToXml(argName, arg);
		else result += instanceToXml(argName, arg);
		//if(arg['__isInstance']) result += instanceToXml(argName, arg);
	}
	return result;
}

/**
 * Convert JavaScript object into XML
 
	<r:WiFiEndpointSettingsInput xmlns:q="http://schemas.dmtf.org/wbem/wscim/1/cim-schema/2/CIM_WiFiEndpointSettings">
		<q:ElementName>Wireless-Profile-Admin</q:ElementName>
		<q:InstanceID>Intel(r) AMT:WiFi Endpoint Settings Wireless-Profile-Admin</q:InstanceID>
		<q:AuthenticationMethod>6</q:AuthenticationMethod>
		<q:EncryptionMethod>4</q:EncryptionMethod>
		<q:Priority>100</q:Priority>
		<q:PSKPassPhrase>P@ssw0rd</q:PSKPassPhrase>
	</r:WiFiEndpointSettingsInput>
 */
function instanceToXml(instanceName, inInstance) {
	if(inInstance === undefined || inInstance === null) return null;
	
	var hasNamespace = !!inInstance['__namespace'];
	var startTag = hasNamespace ? '<q:' : '<';
	var endTag = hasNamespace ? '</q:' : '</';
	var namespaceDef = hasNamespace ? (' xmlns:q="' + inInstance['__namespace'] + '"' ): '';
	var result = '<r:' + instanceName + namespaceDef + '>';
	for(var prop in inInstance) {
		if (!inInstance.hasOwnProperty(prop) || prop.indexOf('__') === 0) continue;
		
		if (typeof inInstance[prop] === 'function' || Array.isArray(inInstance[prop]) ) continue;
		
		if (typeof inInstance[prop] === 'object') {
			//result += startTag + prop +'>' + instanceToXml('prop', inInstance[prop]) + endTag + prop +'>';
			console.error('only convert one level down...');
		}
		else {
			result += startTag + prop +'>' + inInstance[prop].toString() + endTag + prop +'>';
		}
	}
	result += '</r:' + instanceName + '>';
	return result;
}


/**
 * Convert a selector set into XML. Expect no nesting.
 * {
 * 	selectorName : selectorValue,
 * 	selectorName : selectorValue,
 *	... ...
 * }
 
	<r:WiFiEndpoint>
		<a:Address>http://192.168.1.103:16992/wsman</a:Address>
		<a:ReferenceParameters>
			<w:ResourceURI>http://schemas.dmtf.org/wbem/wscim/1/cim-schema/2/CIM_WiFiEndpoint</w:ResourceURI>
			<w:SelectorSet>
				<w:Selector Name="Name">WiFi Endpoint 0</w:Selector>
			</w:SelectorSet>
		</a:ReferenceParameters>
	</r:WiFiEndpoint>
			
 */
function referenceToXml(referenceName, inReference) {
	if(inReference === undefined || inReference === null ) return null;
	
	var result = '<r:' + referenceName + '><a:Address>/wsman</a:Address><a:ReferenceParameters><w:ResourceURI>'+ inReference['__resourceUri']+'</w:ResourceURI><w:SelectorSet>';
	for(var selectorName in inReference) {
		if (!inReference.hasOwnProperty(selectorName) || selectorName.indexOf('__') === 0) continue;
		
		if (typeof inReference[selectorName] === 'function' || 
			typeof inReference[selectorName] === 'object' ||
			Array.isArray(inReference[selectorName]) )
			continue;
		
		result += '<w:Selector Name="' + selectorName +'">' + inReference[selectorName].toString() + '</w:Selector>';
	}
	
	result += '</w:SelectorSet></a:ReferenceParameters></r:' + referenceName + '>';
	return result;
}
/** 
* @description Remote Desktop
* @author Ylian Saint-Hilaire
* @version v0.0.2
*/

// Construct a MeshServer object
var CreateAmtRemoteDesktop = function (divid) {
    var obj = {};
    obj.canvasid = divid;
    obj.canvas = document.getElementById(divid).getContext("2d");
    obj.protocol = 2; // KVM
    obj.state = 0;
    obj.acc = "";
    obj.ScreenWidth = 960;
    obj.ScreenHeight = 700;
    obj.width = 0;
    obj.height = 0;
    obj.rwidth = 0;
    obj.rheight = 0;
    obj.bpp = 2; // Bytes per pixel (1 or 2 supported)
    obj.useZRLE = true;
    obj.showmouse = true;
    obj.timer = null;
    obj.reccount = 0;
    obj.buttonmask = 0;
    obj.inbytes = 0;
    obj.outbytes = 0;
    obj.spare = null;
    obj.sparew = 0;
    obj.spareh = 0;
    obj.sparew2 = 0;
    obj.spareh2 = 0;
    obj.ZRLEfirst = 1;

    obj.rotation = 0;



    obj.mx = 0; // Last mouse x position
    obj.my = 0; // Last mouse y position
    obj.ox = -1; // Old mouse x position
    obj.oy = -1; // Old mouse y position
    obj.focusmode = 0;


    // Private method
    obj.Debug = function (msg) { console.log(msg); }

    obj.xxStateChange = function (newstate) {
        if (newstate == 0) {
            if (obj.timer != null) { clearInterval(obj.timer); obj.timer = null; }
            obj.canvas.fillStyle = '#000000';
            obj.canvas.fillRect(0, 0, obj.width, obj.height);
            obj.canvas.canvas.width = obj.rwidth = obj.width = 640;
            obj.canvas.canvas.height = obj.rheight = obj.height = 400;
            QS(obj.canvasid).cursor = 'auto';
        } else {
            if (!obj.showmouse) { QS(obj.canvasid).cursor = 'none'; }
        }
    }

    obj.ProcessData = function (data) {
        if (!data) return;
        // obj.Debug("KRecv(" + data.length + "): " + rstr2hex(data));
        obj.inbytes += data.length;
        //obj.Debug("KRecv(" + obj.inbytes + ")");
        obj.acc += data;
        while (obj.acc.length > 0) {
            //obj.Debug("KAcc(" + obj.acc.length + "): " + rstr2hex(obj.acc));
            var cmdsize = 0;
            if (obj.state == 0 && obj.acc.length >= 12) {
                // Getting handshake & version
                cmdsize = 12;
                //if (obj.acc.substring(0, 4) != "RFB ") { return obj.Stop(); }
                //var version = parseFloat(obj.acc.substring(4, 11));
                //obj.Debug("KVersion: " + version);
                obj.Send("RFB 003.008\n");
                obj.state = 1;
            }
            else if (obj.state == 1 && obj.acc.length >= 1) {
                // Getting security options
                cmdsize = obj.acc.charCodeAt(0) + 1;
                obj.Send(String.fromCharCode(1)); // Send the "None" security type. Since we already authenticated using redirection digest auth, we don't need to do this again.
                obj.state = 2;
            }
            else if (obj.state == 2 && obj.acc.length >= 4) {
                // Getting security response
                cmdsize = 4;
                if (ReadInt(obj.acc, 0) != 0) { return obj.Stop(); }
                obj.Send(String.fromCharCode(1)); // Send share desktop flag
                obj.state = 3;
            }
            else if (obj.state == 3 && obj.acc.length >= 24) {
                // Getting server init
                var namelen = ReadInt(obj.acc, 20);
                if (obj.acc.length < 24 + namelen) return;
                cmdsize = 24 + namelen;
                obj.canvas.canvas.width = obj.rwidth = obj.width = obj.ScreenWidth = ReadShort(obj.acc, 0);
                obj.canvas.canvas.height = obj.rheight = obj.height = obj.ScreenHeight = ReadShort(obj.acc, 2);

                // These are all values we dont' really need, we are going to only run in RGB565 or RGB332 and not use the flexibility provided by these settings.
                // Makes the javascript code smaller and maybe a bit faster.
                /*
                obj.bpp = obj.acc.charCodeAt(4);
                obj.depth = obj.acc.charCodeAt(5);
                obj.bigend = obj.acc.charCodeAt(6);
                obj.truecolor = obj.acc.charCodeAt(7);
                obj.rmax = ReadShort(obj.acc, 8);
                obj.gmax = ReadShort(obj.acc, 10);
                obj.bmax = ReadShort(obj.acc, 12);
                obj.rsh = obj.acc.charCodeAt(14);
                obj.gsh = obj.acc.charCodeAt(15);
                obj.bsh = obj.acc.charCodeAt(16);

                var name = obj.acc.substring(24, 24 + namelen);
                obj.Debug("name: " + name);
                obj.Debug("width: " + obj.width + ", height: " + obj.height);
                obj.Debug("bits-per-pixel: " + obj.bpp);
                obj.Debug("depth: " + obj.depth);
                obj.Debug("big-endian-flag: " + obj.bigend);
                obj.Debug("true-colour-flag: " + obj.truecolor);
                obj.Debug("rgb max: " + obj.rmax + "," + obj.gmax + "," + obj.bmax);
                obj.Debug("rgb shift: " + obj.rsh + "," + obj.gsh + "," + obj.bsh);
                */

                obj.state = 4;
                obj.parent.xxStateChange(3);
                obj.timer = setInterval(obj.xxOnTimer, 50);

                // SetEncodings, with AMT we can't omit RAW, must be specified.
                // Intel AMT supports encodings: RAW (0), ZRLE (16), Desktop Size (-223)

                var supportedEncodings = '';
                if (obj.useZRLE) supportedEncodings += IntToStr(16);
                supportedEncodings += IntToStr(0);

                obj.Send(String.fromCharCode(2, 0) + ShortToStr((supportedEncodings.length / 4) + 1) + supportedEncodings + IntToStr(-223));          // Supported Encodings + Desktop Size

                // Set the pixel encoding to something much smaller
                // obj.Send(String.fromCharCode(0, 0, 0, 0, 16, 16, 0, 1) + ShortToStr(31) + ShortToStr(63) + ShortToStr(31) + String.fromCharCode(11, 5, 0, 0, 0, 0));   // Setup 16 bit color RGB565
                if (obj.bpp == 1) obj.Send(String.fromCharCode(0, 0, 0, 0, 8, 8, 0, 1) + ShortToStr(7) + ShortToStr(7) + ShortToStr(3) + String.fromCharCode(5, 2, 0, 0, 0, 0));           // Setup 8 bit color RGB332

                
                obj.ox = -1; // Old mouse x position
                
            }
            else if (obj.state == 4) {
                var c = obj.acc.charCodeAt(0);
                if (c == 2) {
                    cmdsize = 1;                                // This is the bell, do nothing.
                } else if (c == 0) {
                    if (obj.acc.length < 4) return;
                    obj.state = 100 + ReadShort(obj.acc, 2);    // Read the number of tiles that are going to be sent, add 100 and use that as our protocol state.
                    cmdsize = 4;
                }
            }
            else if (obj.state > 100 && obj.acc.length >= 12) {
                var x = ReadShort(obj.acc, 0),
                    y = ReadShort(obj.acc, 2),
                    width = ReadShort(obj.acc, 4),
                    height = ReadShort(obj.acc, 6),
                    s = width * height,
                    encoding = ReadInt(obj.acc, 8);

                
                if (obj.rotation == 1 || obj.rotation == 3) {
                    // Set the spare bitmap to the rigth size if it's not already. This allows us to recycle the spare most if not all the time.
                    if (obj.sparew != width || obj.spareh != height) { if (obj.spare != null) delete obj.spare; obj.spare = obj.canvas.createImageData(height, width); obj.sparew = obj.spareh2 = width; obj.spareh = obj.sparew2 = height; }
                } else {
                
                    // Set the spare bitmap to the rigth size if it's not already. This allows us to recycle the spare most if not all the time.
                    if (obj.sparew != width || obj.spareh != height) { if (obj.spare != null) delete obj.spare; obj.spare = obj.canvas.createImageData(width, height); obj.sparew = obj.sparew2 = width; obj.spareh = obj.spareh2 = height; }
                
                }
                

                obj.reccount++;
                if (encoding == -223) {
                    // Desktop Size (-223)
                    obj.canvas.canvas.width = obj.rwidth = obj.width = width;
                    obj.canvas.canvas.height = obj.rheight = obj.height = height;
                    obj.Send(String.fromCharCode(3, 0, 0, 0, 0, 0) + ShortToStr(obj.width) + ShortToStr(obj.height)); // FramebufferUpdateRequest
                    cmdsize = 12;
                    // obj.Debug("New desktop width: " + obj.width + ", height: " + obj.height);
                }
                else if (encoding == 0) {
                    // RAW encoding
                    var ptr = 12, cs = 12 + (s * obj.bpp);
                    if (obj.acc.length < cs) return; // Check we have all the data needed and we can only draw 64x64 tiles.
                    cmdsize = cs;

                    // CRITICAL LOOP, optimize this as much as possible
                    for (var i = 0; i < s; i++) { obj.setPixel(obj.acc.charCodeAt(ptr++) + ((obj.bpp == 2) ? (obj.acc.charCodeAt(ptr++) << 8) : 0), i); }
                    obj.putImage(obj.spare, x, y);
                }
                else if (encoding == 16) {
                    // ZRLE encoding
                    if (obj.acc.length < 16) return;
                    var datalen = ReadInt(obj.acc, 12);
                    if (obj.acc.length < (16 + datalen)) return;
                    //obj.Debug("RECT ZRLE (" + x + "," + y + "," + width + "," + height + ") LEN = " + datalen);
                    //obj.Debug("RECT ZRLE LEN: " + ReadShortX(obj.acc, 17) + ", DATA: " + rstr2hex(obj.acc.substring(16)));
                    
                    // Process the ZLib header if this is the first block
                    var ptr = 16, delta = 5, dx = 0;
                    if (obj.ZRLEfirst == 1) { if (ReadShortX(obj.acc, ptr) == 40056) { obj.ZRLEfirst = 0; ptr += 2; delta = 7; dx = 2; } else { return obj.Stop(); } } // If we don't see the ZLib header, disconnect.

                    if (datalen > 5 && obj.acc.charCodeAt(ptr) == 0 && ReadShortX(obj.acc, ptr + 1) == (datalen - delta)) {
                        // This is an uncompressed ZLib data block
                        obj.decodeLRE(obj.acc, ptr + 5, x, y, width, height, s, datalen);
                    }

                    else
                    {
                        // This is compressed ZLib data.

                        // Convert all data into an array (TODO: Fix ZLib library so we don't have to do this)
                        var strLen = datalen - dx, arr = new Uint8Array(new ArrayBuffer(strLen));
                        for (var i = 0; i < strLen; i++) { arr[i] = obj.acc.charCodeAt(ptr + i); }

                        // Decompress the data
                        arr = inflate(arr);

                        // Convert everything back to string & decode RLE
                        if (arr.length > 0) { obj.decodeLRE(String.fromCharCode.apply(null, new Uint8Array(arr)), 0, x, y, width, height, s, arr.length); } // TODO: Fix ZLib library so we don't have to do this
                    }


                    cmdsize = 16 + datalen;
                }
                else {
                    obj.Debug("Unknown Encoding: " + encoding);
                    return obj.Stop();
                }
                if (--obj.state == 100) obj.state = 4;
            }

            if (cmdsize == 0) return;
            obj.acc = obj.acc.substring(cmdsize);
        }
    }

    obj.decodeLRE = function (data, ptr, x, y, width, height, s, datalen) {
        var subencoding = data.charCodeAt(ptr++), index, v, runlengthdecode, palette = {}, rlecount = 0, runlength = 0, i;
        // obj.Debug("RECT RLE (" + (datalen - 5) + ", " + subencoding + "):" + rstr2hex(data.substring(21, 21 + (datalen - 5))));
        if (subencoding == 0) {
            // RAW encoding
            for (i = 0; i < s; i++) { obj.setPixel(data.charCodeAt(ptr++) + ((obj.bpp == 2) ? (data.charCodeAt(ptr++) << 8) : 0), i); }
            obj.putImage(obj.spare, x, y);
        }
        else if (subencoding == 1) {
            // Solid color tile
            v = data.charCodeAt(ptr++) + ((obj.bpp == 2) ? (data.charCodeAt(ptr++) << 8) : 0);
            obj.canvas.fillStyle = 'rgb(' + ((obj.bpp == 1) ? ((v & 224) + ',' + ((v & 28) << 3) + ',' + obj.fixColor((v & 3) << 6)) : (((v >> 8) & 248) + ',' + ((v >> 3) & 252) + ',' + ((v & 31) << 3))) + ')';

            
            var xx = obj.rotX(x, y);
            y = obj.rotY(x, y);
            x = xx;
            

            obj.canvas.fillRect(x, y, width, height);
        }
        else if (subencoding > 1 && subencoding < 17) { // Packed palette encoded tile
            // Read the palette
            var br = 4, bm = 15; // br is BitRead and bm is BitMask. By adjusting these two we can support all the variations in this encoding.
            for (i = 0; i < subencoding; i++) { palette[i] = data.charCodeAt(ptr++) + ((obj.bpp == 2) ? (data.charCodeAt(ptr++) << 8) : 0); }

            // Compute bits to read & bit mark
            if (subencoding == 2) { br = 1; bm = 1; } else if (subencoding <= 4) { br = 2; bm = 3; }

            // Display all the bits
            while (rlecount < s && ptr < data.length) { v = data.charCodeAt(ptr++); for (i = (8 - br) ; i >= 0; i -= br) { obj.setPixel(palette[(v >> i) & bm], rlecount++); } }
            obj.putImage(obj.spare, x, y);
        }
        else if (subencoding == 128) { // RLE encoded tile
            while (rlecount < s && ptr < data.length) {
                // Get the run color
                v = data.charCodeAt(ptr++) + ((obj.bpp == 2) ? (data.charCodeAt(ptr++) << 8) : 0);

                // Decode the run length. This is the fastest and most compact way I found to do this.
                runlength = 1; do { runlength += (runlengthdecode = data.charCodeAt(ptr++)); } while (runlengthdecode == 255);

                // Draw a run
                while (--runlength >= 0) { obj.setPixel(v, rlecount++); }
            }
            obj.putImage(obj.spare, x, y);
        }
        else if (subencoding > 129) { // Palette RLE encoded tile
            // Read the palette
            for (i = 0; i < (subencoding - 128) ; i++) { palette[i] = data.charCodeAt(ptr++) + ((obj.bpp == 2) ? (data.charCodeAt(ptr++) << 8) : 0); }

            // Decode RLE  on palette
            while (rlecount < s && ptr < data.length) {
                // Setup the run, get the color index and get the color from the palette.
                runlength = 1; index = data.charCodeAt(ptr++); v = palette[index % 128];

                // If the index starts with high order bit 1, this is a run and decode the run length.
                if (index > 127) { do { runlength += (runlengthdecode = data.charCodeAt(ptr++)); } while (runlengthdecode == 255); }

                // Draw a run
                while (--runlength >= 0) { obj.setPixel(v, rlecount++); }
            }
            obj.putImage(obj.spare, x, y);
        }
    }

    obj.putImage = function (i, x, y) {
        
        var xx = obj.arotX(x, y);
        y = obj.arotY(x, y);
        x = xx;
        
        obj.canvas.putImageData(i, x, y);
    }

    obj.setPixel = function (v, p) {
        var pp = p * 4;

        
        if (obj.rotation == 1) {
            var x = p % obj.sparew;
            var y = Math.floor(p / obj.sparew);
            p = (x * obj.sparew2) + (obj.sparew2 - 1 - y);
            pp = p * 4;
        }
        if (obj.rotation == 2) { pp = (obj.sparew * obj.spareh * 4) - 4 - pp; }
        if (obj.rotation == 3) {
            var x = p % obj.sparew;
            var y = Math.floor(p / obj.sparew);
            p = ((obj.sparew2 - 1 - x) * obj.sparew2) + (y);
            pp = p * 4;
        }
        

        if (obj.bpp == 1) {
            // Set 8bit color RGB332
            obj.spare.data[pp++] = v & 224;
            obj.spare.data[pp++] = (v & 28) << 3;
            obj.spare.data[pp++] = obj.fixColor((v & 3) << 6);
        } else {
            // Set 16bit color RGB565
            obj.spare.data[pp++] = (v >> 8) & 248;
            obj.spare.data[pp++] = (v >> 3) & 252;
            obj.spare.data[pp++] = (v & 31) << 3;
        }
        obj.spare.data[pp] = 0xFF; // Set alpha channel to opaque.
    }


    obj.arotX = function (x, y) {
        if (obj.rotation == 0) return x;
        if (obj.rotation == 1) return obj.canvas.canvas.width - obj.sparew2 - y;
        if (obj.rotation == 2) return obj.canvas.canvas.width - obj.sparew2 - x;
        if (obj.rotation == 3) return y;
        return 0;
    }

    obj.arotY = function (x, y) {
        if (obj.rotation == 0) return y;
        if (obj.rotation == 1) return x;
        if (obj.rotation == 2) return obj.canvas.canvas.height - obj.spareh2 - y;
        if (obj.rotation == 3) return obj.canvas.canvas.height - obj.spareh - x;
        return 0;
    }

    obj.crotX = function (x, y) {
        if (obj.rotation == 0) return x;
        if (obj.rotation == 1) return y;
        if (obj.rotation == 2) return obj.canvas.canvas.width - x;
        if (obj.rotation == 3) return obj.canvas.canvas.height - y;
        return 0;
    }

    obj.crotY = function (x, y) {
        if (obj.rotation == 0) return y;
        if (obj.rotation == 1) return obj.canvas.canvas.width - x;
        if (obj.rotation == 2) return obj.canvas.canvas.height - y;
        if (obj.rotation == 3) return x;
        return 0;
    }

    obj.rotX = function (x, y) {
        if (obj.rotation == 0) return x;
        if (obj.rotation == 1) return x;
        if (obj.rotation == 2) return x - obj.canvas.canvas.width;
        if (obj.rotation == 3) return x - obj.canvas.canvas.height;
        return 0;
    }

    obj.rotY = function (x, y) {
        if (obj.rotation == 0) return y;
        if (obj.rotation == 1) return y - obj.canvas.canvas.width;
        if (obj.rotation == 2) return y - obj.canvas.canvas.height;
        if (obj.rotation == 3) return y;
        return 0;
    }

    obj.tcanvas = null;
    obj.setRotation = function (x) {
        while (x < 0) { x += 4; }
        var newrotation = x % 4;
        if (newrotation == obj.rotation) return true;
        var rw = obj.canvas.canvas.width;
        var rh = obj.canvas.canvas.height;
        if (obj.rotation == 1 || obj.rotation == 3) { rw = obj.canvas.canvas.height; rh = obj.canvas.canvas.width; }

        // Copy the canvas, put it back in the correct direction
        if (obj.tcanvas == null) obj.tcanvas = document.createElement('canvas');
        var tcanvasctx = obj.tcanvas.getContext('2d');
        tcanvasctx.setTransform(1, 0, 0, 1, 0, 0);
        tcanvasctx.canvas.width = rw;
        tcanvasctx.canvas.height = rh;
        tcanvasctx.rotate((obj.rotation * -90) * Math.PI / 180);
        if (obj.rotation == 0) tcanvasctx.drawImage(obj.canvas.canvas, 0, 0);
        if (obj.rotation == 1) tcanvasctx.drawImage(obj.canvas.canvas, -obj.canvas.canvas.width, 0);
        if (obj.rotation == 2) tcanvasctx.drawImage(obj.canvas.canvas, -obj.canvas.canvas.width, -obj.canvas.canvas.height);
        if (obj.rotation == 3) tcanvasctx.drawImage(obj.canvas.canvas, 0, -obj.canvas.canvas.height);

        // Change the size and orientation and copy the canvas back into the rotation
        if (obj.rotation == 0 || obj.rotation == 2) { obj.canvas.canvas.height = rw; obj.canvas.canvas.width = rh; }
        if (obj.rotation == 1 || obj.rotation == 3) { obj.canvas.canvas.height = rh; obj.canvas.canvas.width = rw; }
        obj.canvas.setTransform(1, 0, 0, 1, 0, 0);
        obj.canvas.rotate((newrotation * 90) * Math.PI / 180);
        obj.rotation = newrotation;
        obj.canvas.drawImage(obj.tcanvas, obj.rotX(0, 0), obj.rotY(0, 0));

        obj.width = obj.canvas.canvas.width;
        obj.height = obj.canvas.canvas.height;
        if (obj.onScreenResize != null) obj.onScreenResize(obj, obj.width, obj.height, obj.CanvasId);
        return true;
    }


    obj.fixColor = function (c) { return (c > 127)?(c + 32):c; }

    obj.xxOnTimer = function () {
        // TODO: This timer function can probalby be adjusted a bunch.
        if (obj.reccount == 0 && obj.acc.length == 0) {

            if (obj.focusmode > 0) {
                // Request only pixels around the last mouse position
                var df = obj.focusmode * 2;
                obj.Send(String.fromCharCode(3, 1) + ShortToStr(Math.max(Math.min(obj.ox, obj.mx) - obj.focusmode, 0)) + ShortToStr(Math.max(Math.min(obj.oy, obj.my) - obj.focusmode, 0)) + ShortToStr(df + Math.abs(obj.ox - obj.mx)) + ShortToStr(df + Math.abs(obj.oy - obj.my))); // FramebufferUpdateRequest
                obj.ox = obj.mx;
                obj.oy = obj.my;
            } else

            {
                // Request the entire screen
                obj.Send(String.fromCharCode(3, 1, 0, 0, 0, 0) + ShortToStr(obj.rwidth) + ShortToStr(obj.rheight)); // FramebufferUpdateRequest
            }
        }
        obj.reccount = 0;
    }

    obj.Start = function () {
        //obj.Debug("KVM-Start");
        obj.state = 0;
        obj.acc = "";
        obj.ZRLEfirst = 1;
        obj.inbytes = 0;
        obj.outbytes = 0;
        
        inflate_start();
        
    }

    obj.Stop = function () {
        obj.UnGrabMouseInput();
        obj.UnGrabKeyInput();
        obj.parent.Stop();
    }

    obj.Send = function (x) {
        // obj.Debug("KSend(" + x.length + "): " + rstr2hex(x));
        obj.outbytes += x.length;
        obj.parent.Send(x);
    }

/*
Intel AMT only recognizes a small subset of keysym characters defined in the keysymdef.h so you don�t need to
implement all the languages (this is taken care by the USB Scancode Extension in RFB4.0 protocol).
The only subset recognized by the FW is the defined by the following sets : XK_LATIN1 , XK_MISCELLANY, XK_3270, XK_XKB_KEYS, XK_KATAKANA.
In addition to keysymdef.h symbols there are 6 japanese extra keys that we do support:

#define XK_Intel_EU_102kbd_backslash_pipe_45  0x17170056 // European 102-key: 45 (backslash/pipe),     usb Usage: 0x64
#define XK_Intel_JP_106kbd_yen_pipe           0x1717007d // Japanese 106-key: 14 (Yen/pipe),           usb Usage: 0x89
#define XK_Intel_JP_106kbd_backslash_underbar 0x17170073 // Japanese 106-key: 56 (backslash/underbar), usb Usage: 0x87
#define XK_Intel_JP_106kbd_NoConvert          0x1717007b // Japanese 106-key: 131 (NoConvert),         usb Usage: 0x8b
#define XK_Intel_JP_106kbd_Convert            0x17170079 // Japanese 106-key: 132 (Convert),           usb Usage: 0x8a
#define XK_Intel_JP_106kbd_Hirigana_Katakana  0x17170070 // Japanese 106-key: 133 (Hirigana/Katakana), usb Usage: 0x88
*/

    obj.keyevent = function (d, e)
    {
        if (!e) { e = window.event; }
        var k = e.keyCode;
        if (k == 173) k = 189; // '-' key (Firefox)
        if (k == 61) k = 187; // '=' key (Firefox)
        var kk = k;
        if (k == 0x3B) kk = 0xBA; // ';' key
        if (e.shiftKey == false && k >= 65 && k <= 90) kk = k + 32;
        if (k >= 112 && k <= 124) kk = k + 0xFF4E;
        if (k == 8) kk = 0xff08; // Backspace
        if (k == 9) kk = 0xff09; // Tab
        if (k == 13) kk = 0xff0d; // Return
        if (k == 16) kk = 0xffe1; // Shift (Left)
        if (k == 17) kk = 0xffe3; // Ctrl (Left)
        if (k == 18) kk = 0xffe9; // Alt (Left)
        if (k == 27) kk = 0xff1b; // ESC
        if (k == 33) kk = 0xff55; // PageUp
        if (k == 34) kk = 0xff56; // PageDown
        if (k == 35) kk = 0xff57; // End
        if (k == 36) kk = 0xff50; // Home
        if (k == 37) kk = 0xff51; // Left
        if (k == 38) kk = 0xff52; // Up
        if (k == 39) kk = 0xff53; // Right
        if (k == 40) kk = 0xff54; // Down
        if (k == 45) kk = 0xff63; // Insert
        if (k == 46) kk = 0xffff; // Delete
        if (k >= 96 && k <= 105) kk = k - 48; // Key pad numbers
        if (k == 106) kk = 42; // Pad *
        if (k == 107) kk = 43; // Pad +
        if (k == 109) kk = 45; // Pad -
        if (k == 110) kk = 46; // Pad .
        if (k == 111) kk = 47; // Pad /
        if (k == 187) kk = 61; // =
        if (k == 188) kk = 44; // ,
        if (k == 189) kk = 45; // -
        if (k == 190) kk = 46; // .
        if (k == 191) kk = 47; // /
        if (k == 192) kk = 96; // `
        if (k == 219) kk = 91; // [
        if (k == 220) kk = 92; // \
        if (k == 221) kk = 93; // ]
        // console.log('Key' + d + ": " + k + " = " + kk);
        obj.sendkey(kk, d);
        return obj.haltEvent(e);
    }

    obj.sendkey = function (k, d) { obj.Send(String.fromCharCode(4, d, 0, 0) + IntToStr(k)); }

    obj.SendCtrlAltDelMsg = function () { obj.sendcad(); }
    obj.sendcad = function () {
        obj.sendkey(0xFFE3, 1); // Control
        obj.sendkey(0xFFE9, 1); // Alt
        obj.sendkey(0xFFFF, 1); // Delete
        obj.sendkey(0xFFFF, 0); // Delete
        obj.sendkey(0xFFE9, 0); // Alt
        obj.sendkey(0xFFE3, 0); // Control
    }

    obj.xxMouseInputGrab = false;
    obj.xxKeyInputGrab = false;

    obj.GrabMouseInput = function () {
        if (obj.xxMouseInputGrab == true) return;
        var c = obj.canvas.canvas;
        c.onmouseup = obj.mouseup;
        c.onmousedown = obj.mousedown;
        c.onmousemove = obj.mousemove;
        //if (navigator.userAgent.match(/mozilla/i)) c.DOMMouseScroll = obj.xxDOMMouseScroll; else c.onmousewheel = obj.xxMouseWheel;
        obj.xxMouseInputGrab = true;
    }

    obj.UnGrabMouseInput = function () {
        if (obj.xxMouseInputGrab == false) return;
        var c = obj.canvas.canvas;
        c.onmousemove = null;
        c.onmouseup = null;
        c.onmousedown = null;
        //if (navigator.userAgent.match(/mozilla/i)) c.DOMMouseScroll = null; else c.onmousewheel = null;
        obj.xxMouseInputGrab = false;
    }

    obj.GrabKeyInput = function () {
        if (obj.xxKeyInputGrab == true) return;
        document.onkeyup = obj.handleKeyUp;
        document.onkeydown = obj.handleKeyDown;
        document.onkeypress = obj.handleKeys;
        obj.xxKeyInputGrab = true;
    }

    obj.UnGrabKeyInput = function () {
        if (obj.xxKeyInputGrab == false) return;
        document.onkeyup = null;
        document.onkeydown = null;
        document.onkeypress = null;
        obj.xxKeyInputGrab = false;
    }

    obj.handleKeys = function (e) { return obj.haltEvent(e); }
    obj.handleKeyUp = function (e) { return obj.keyevent(0, e); }
    obj.handleKeyDown = function (e) { return obj.keyevent(1, e); }
    obj.haltEvent = function(e) { if (e.preventDefault) e.preventDefault(); if (e.stopPropagation) e.stopPropagation(); return false; }

    // RFB "PointerEvent" and mouse handlers
    obj.mousedown = function (e) { obj.buttonmask |= (1 << e.button); return obj.mousemove(e); }
    obj.mouseup = function (e) { obj.buttonmask &= (0xFFFF - (1 << e.button)); return obj.mousemove(e); }
    obj.mousemove = function (e) {
        if (obj.state != 4) return true;
        var pos = obj.getPositionOfControl(Q(obj.canvasid));
        obj.mx = (e.pageX - pos[0]) * (obj.canvas.canvas.height / Q(obj.canvasid).offsetHeight);
        obj.my = (e.pageY - pos[1]) * (obj.canvas.canvas.width / Q(obj.canvasid).offsetWidth);


        obj.mx2 = obj.crotX(obj.mx, obj.my);
        obj.my = obj.crotY(obj.mx, obj.my);
        obj.mx = obj.mx2;


        obj.Send(String.fromCharCode(5, obj.buttonmask) + ShortToStr(obj.mx) + ShortToStr(obj.my));


        // Update focus area if we are in focus mode
        QV('DeskFocus', obj.focusmode);
        if (obj.focusmode != 0) {
            var x = Math.min(obj.mx, obj.canvas.canvas.width - obj.focusmode),
                y = Math.min(obj.my, obj.canvas.canvas.height - obj.focusmode),
                df = obj.focusmode * 2,
                c = Q(obj.canvasid),
                qx = c.offsetHeight / obj.canvas.canvas.height,
                qy = c.offsetWidth / obj.canvas.canvas.width,
                q = QS('DeskFocus');
            q.left = (Math.max(((x - obj.focusmode) * qx), 0)) + 'px';
            q.top = (Math.max(((y - obj.focusmode) * qy), 0)) + 'px';
            q.width = ((df * qx) - 6) + 'px';
            q.height = ((df * qx) - 6) + 'px';
        }


        return obj.haltEvent(e);
    }

    obj.getPositionOfControl = function (Control) {
        var Position = Array(2);
        Position[0] = Position[1] = 0;
        while (Control) {
            Position[0] += Control.offsetLeft;
            Position[1] += Control.offsetTop;
            Control = Control.offsetParent;
        }
        return Position;
    }

    return obj;
}
/** 
* @description Remote Terminal
* @author Ylian Saint-Hilaire
* @version v0.0.2b
*/

// Construct a MeshServer object
var CreateAmtRemoteTerminal = function (divid) {
    var obj = {};
    obj.DivId = divid;
    obj.DivElement = document.getElementById(divid);
    obj.protocol = 1; // SOL

    obj.Terminal_CellHeight = 21;
    obj.Terminal_CellWidth = 13;
    obj.TermColors = ['000000', 'BB0000', '00BB00', 'BBBB00', '0000BB', 'BB00BB', '00BBBB', 'BBBBBB', '555555', 'FF5555', '55FF55', 'FFFF55', '5555FF', 'FF55FF', '55FFFF', 'FFFFFF'];
    obj.TermCurrentReverse = 0;
    obj.TermCurrentFColor = 7;
    obj.TermCurrentBColor = 0;
    obj.TermLineWrap = true;
    obj.termx = 0;
    obj.termy = 0;
    obj.termstate = 0;
    obj.escNumber = [];
    obj.escNumberPtr = 0;
    obj.scratt = [];
    obj.tscreen = [];
    obj.VTUNDERLINE = 1;
    obj.VTREVERSE = 2;

    // Private method
    obj.Debug = function (msg) { console.log(msg); }

    obj.Start = function () { }

    obj.Init = function () {
        for (var y = 0; y < 25; y++) {
            obj.tscreen[y] = [];
            obj.scratt[y] = [];
            for (var x = 0; x < 80; x++) { obj.tscreen[y][x] = ' '; obj.scratt[y][x] = (7 << 6); }
        }
        obj.TermInit();
    }

    obj.xxStateChange = function(newstate) { }

    obj.ProcessData = function (str) { obj.ProcessVt100EscString(str); obj.TermDraw(); }

    obj.ProcessVt100EscString = function (str) { for (var i = 0; i < str.length; i++) obj.ProcessVt100EscChar(String.fromCharCode(str.charCodeAt(i)), str.charCodeAt(i)); }

    obj.ProcessVt100EscChar = function (b, c) {
        switch (obj.termstate) {
            case 0: // Normal Term State
                switch (c) {
                    case 27: // ESC
                        obj.termstate = 1;
                        break;
                    default:
                        // Process a single char
                        obj.ProcessVt100Char(b);
                        break;
                }
                break;
            case 1:
                switch (b) {
                    case '[':
                        obj.escNumberPtr = 0;
                        obj.escNumber = [];
                        obj.termstate = 2;
                        break;
                    case '(':
                        obj.termstate = 4;
                        break;
                    case ')':
                        obj.termstate = 5;
                        break;
                    default:
                        obj.termstate = 0;
                        break;
                }
                break;
            case 2:
                if (b >= '0' && b <= '9') {
                    // This is a number
                    if (!obj.escNumber[obj.escNumberPtr]) {
                        obj.escNumber[obj.escNumberPtr] = (b - '0');
                    }
                    else {
                        obj.escNumber[obj.escNumberPtr] = ((obj.escNumber[obj.escNumberPtr] * 10) + (b - '0'));
                    }
                    break;
                }
                else if (b == ';') {
                    // New number
                    obj.escNumberPtr++;
                    break;
                }
                else {
                    // Process Escape Sequence
                    if (!obj.escNumber[0]) obj.escNumber[0] = 0;
                    obj.ProcessEscapeHandler(b, obj.escNumber, obj.escNumberPtr + 1);
                    obj.termstate = 0;
                }
                break;
            case 4: // '(' Code
                obj.termstate = 0;
                break;
            case 5: // ')' Code
                obj.termstate = 0;
                break;
        }
    }

    obj.ProcessEscapeHandler = function (code, args, argslen) {
        var i;
        switch (code) {
            case 'c': // ResetDevice
                // Reset
                obj.TermResetScreen();
                break;
            case 'A': // Move cursor up n lines
                if (argslen == 1) {
                    obj.termy -= args[0];
                    if (obj.termy < 0) obj.termy = 0;
                }
                break;
            case 'B': // Move cursor down n lines
                if (argslen == 1) {
                    obj.termy += args[0];
                    if (obj.termy > 25) obj.termy = 25;
                }
                break;
            case 'C': // Move cursor right n lines
                if (argslen == 1) {
                    obj.termx += args[0];
                    if (obj.termx > 80) obj.termx = 80;
                }
                break;
            case 'D': // Move cursor left n lines
                if (argslen == 1) {
                    obj.termx -= args[0];
                    if (obj.termx < 0) obj.termx = 0;
                }
                break;
            case 'd': // Set cursor to line n
                if (argslen == 1) {
                    obj.termy = args[0] - 1;
                    if (obj.termy > 25) obj.termy = 25;
                    if (obj.termy < 0) obj.termy = 0;
                }
                break;
            case 'G': // Set cursor to col n
                if (argslen == 1) {
                    obj.termx = args[0] - 1;
                    if (obj.termx < 0) obj.termx = 0;
                    if (obj.termx > 79) obj.termx = 79;
                }
                break;
            case 'J': // ClearScreen:
                if (argslen == 1 && args[0] == 2) {
                    obj.TermClear((obj.TermCurrentBColor << 12) + (obj.TermCurrentFColor << 6)); // Erase entire screen
                    obj.termx = 0;
                    obj.termy = 0;
                }
                else if (argslen == 0 || argslen == 1 && args[0] == 0) // Erase cursor down
                {
                    obj.EraseCursorToEol();
                    for (i = obj.termy + 1; i < 25; i++) obj.EraseLine(i);
                }
                else if (argslen == 1 && args[0] == 1) // Erase cursor up
                {
                    obj.EraseCursorToEol();
                    for (i = 0; i < obj.termy - 1; i++) obj.EraseLine(i);
                }
                break;
            case 'H': // MoveCursor:
                if (argslen == 2) {
                    if (args[0] < 1) args[0] = 1;
                    if (args[1] < 1) args[1] = 1;
                    if (args[0] > 25) args[0] = 25;
                    if (args[1] > 80) args[1] = 80;
                    obj.termy = args[0] - 1;
                    obj.termx = args[1] - 1;
                }
                else {
                    obj.termy = 0;
                    obj.termx = 0;
                }
                break;
            case 'm': // ScreenAttribs:
                // Change attributes
                for (i = 0; i < argslen; i++) {
                    if (!args[i] || args[i] == 0) {
                        // Reset Attributes
                        obj.TermCurrentBColor = 0;
                        obj.TermCurrentFColor = 7;
                        obj.TermCurrentReverse = 0;
                    }
                    else if (args[i] == 1) {
                        // Bright
                        if (obj.TermCurrentFColor < 8) obj.TermCurrentFColor += 8;
                    }
                    else if (args[i] == 2 || args[i] == 22) {
                        // Dim
                        if (obj.TermCurrentFColor >= 8) obj.TermCurrentFColor -= 8;
                    }
                    else if (args[i] == 7) {
                        // Set Reverse attribute true
                        obj.TermCurrentReverse = 2;
                    }
                    else if (args[i] == 27) {
                        // Set Reverse attribute false
                        obj.TermCurrentReverse = 0;
                    }
                    else if (args[i] >= 30 && args[i] <= 37) {
                        // Set Foreground Color
                        var bright = (obj.TermCurrentFColor >= 8);
                        obj.TermCurrentFColor = (args[i] - 30);
                        if (bright && obj.TermCurrentFColor <= 8) obj.TermCurrentFColor += 8;
                    }
                    else if (args[i] >= 40 && args[i] <= 47) {
                        // Set Background Color
                        obj.TermCurrentBColor = (args[i] - 40);
                    }
                    else if (args[i] >= 90 && args[i] <= 99) {
                        // Set Bright Foreground Color
                        obj.TermCurrentFColor = (args[i] - 82);
                    }
                    else if (args[i] >= 100 && args[i] <= 109) {
                        // Set Bright Background Color
                        obj.TermCurrentBColor = (args[i] - 92);
                    }
                }
                break;
            case 'K': // EraseLine:
                if (argslen == 0 || (argslen == 1 && (!args[0] || args[0] == 0))) {
                    obj.EraseCursorToEol(); // Erase from the cursor to the end of the line
                }
                else if (argslen == 1) {
                    if (args[0] == 1) // Erase from the beginning of the line to the cursor
                    {
                        obj.EraseBolToCursor();
                    }
                    else if (args[0] == 2) // Erase the line with the cursor
                    {
                        obj.EraseLine(obj.termy);
                    }
                }
                break;
            case 'h': // EnableLineWrap:
                obj.TermLineWrap = true;
                break;
            case 'l': // DisableLineWrap:
                obj.TermLineWrap = false;
                break;
            default:
                //if (code != '@') alert(code);
                break;
        }
    }

    obj.ProcessVt100String = function (str) {
        for (var i = 0; i < str.length; i++) obj.ProcessVt100Char(String.fromCharCode(str.charCodeAt(i)));
    }

    obj.ProcessVt100Char = function (c) {
        // ANSI - Extended ASCII emulation.
        //if ((c & 0x80) != 0) c = AsciiToUnicode[c & 0x7F];

        if (c == '\0' || c.charCodeAt() == 7) return; // Ignore null & bell

        var ch = c.charCodeAt();
        //if (ch < 32 && ch != 10 && ch != 13) alert(ch);
        switch (ch) {
            case 24: { c = '↑'; break; }
            case 25: { c = '↓'; break; }
        }

        if (obj.termx > 80) obj.termx = 80;
        if (obj.termy > 24) obj.termy = 24;

        switch (c) {
            case '\b': // Backspace
                if (obj.termx > 0) {
                    obj.termx = obj.termx - 1;
                    obj.TermDrawChar(' ');
                }
                break;
            case '\t': // tab
                var tab = 8 - (obj.termx % 8)
                for (var x = 0; x < tab; x++) obj.ProcessVt100Char(" ");
                break;
            case '\n': // Linefeed
                obj.termy++;
                if (obj.termy > 24) {
                    // Move everything up one line
                    obj.TermMoveUp(1);
                    obj.termy = 24;
                }
                break;
            case '\r': // Carriage Return
                obj.termx = 0;
                break;
            default:
                if (obj.termx >= 80) {
                    obj.termx = 0;
                    if (obj.TermLineWrap) { obj.termy++; }
                    if (obj.termy >= 24) { obj.TermMoveUp(1); obj.termy = 24; }
                }
                obj.TermDrawChar(c);
                obj.termx++;
                break;
        }

    }

    obj.TermDrawChar = function(c) {
        obj.tscreen[obj.termy][obj.termx] = c;
        obj.scratt[obj.termy][obj.termx] = (obj.TermCurrentFColor << 6) + (obj.TermCurrentBColor << 12) + obj.TermCurrentReverse;
    }

    obj.TermClear = function(TermColor) {
        for (var y = 0; y < 25; y++) {
            for (var x = 0; x < 80; x++) {
                obj.tscreen[y][x] = ' ';
                obj.scratt[y][x] = TermColor;
            }
        }
    }

    obj.TermResetScreen = function () {
        obj.TermCurrentReverse = 0;
        obj.TermCurrentFColor = 7;
        obj.TermCurrentBColor = 0;
        obj.TermLineWrap = true;
        obj.termx = 0;
        obj.termy = 0;
        obj.TermClear(7 << 6);
    }

    obj.EraseCursorToEol = function () {
        var t = (obj.TermCurrentBColor << 12);
        for (var x = obj.termx; x < 80; x++) {
            obj.tscreen[obj.termy][x] = ' ';
            obj.scratt[obj.termy][x] = t;
        }
    }

    obj.EraseBolToCursor = function() {
        var t = (obj.TermCurrentBColor << 12);
        for (var x = 0; x < obj.termx; x++) {
            obj.tscreen[obj.termy][x] = ' ';
            obj.scratt[obj.termy][x] = t;
        }
    }

    obj.EraseLine = function (line) {
        var t = (obj.TermCurrentBColor << 12);
        for (var x = 0; x < 80; x++) {
            obj.tscreen[line][x] = ' ';
            obj.scratt[line][x] = t;
        }
    }

    obj.TermSendKeys = function(keys) { obj.parent.Send(keys); }
    obj.TermSendKey = function(key) { obj.parent.Send(String.fromCharCode(key)); }

    obj.TermMoveUp = function(linecount) {
        var x, y;
        for (y = 0; y < 25 - linecount; y++) {
            obj.tscreen[y] = obj.tscreen[y + linecount];
            obj.scratt[y] = obj.scratt[y + linecount];
        }
        for (y = 25 - linecount; y < 25; y++) {
            obj.tscreen[y] = [];
            obj.scratt[y] = [];
            for (x = 0; x < 80; x++) {
                obj.tscreen[y][x] = ' ';
                obj.scratt[y][x] = (7 << 6);
            }
        }
    }

    obj.TermHandleKeys = function(e) {
        if (!e.ctrlKey) {
            if (e.which == 127) obj.TermSendKey(8);
            else if (e.which == 13) obj.TermSendKeys("\r\n");
            else if (e.which != 0) obj.TermSendKey(e.which);
            return false;
        }
        if (e.preventDefault) e.preventDefault();
        if (e.stopPropagation) e.stopPropagation();
    }

    obj.TermHandleKeyUp = function(e) {
        if (e.which != 8 && e.which != 32) return true;
        if (e.preventDefault) e.preventDefault();
        if (e.stopPropagation) e.stopPropagation();
        return false;
    }

    obj.TermHandleKeyDown = function (e) {
        if (e.which >= 65 && e.ctrlKey <= 90 && e.ctrlKey) {
            obj.TermSendKey(e.which - 64);
            if (e.preventDefault) e.preventDefault();
            if (e.stopPropagation) e.stopPropagation();
            return;
        }
        if (e.which == 27) { obj.TermSendKeys(String.fromCharCode(27)); return true }; // ESC
        if (e.which == 37) { obj.TermSendKeys(String.fromCharCode(27, 91, 68)); return true }; // Left
        if (e.which == 38) { obj.TermSendKeys(String.fromCharCode(27, 91, 65)); return true }; // Up
        if (e.which == 39) { obj.TermSendKeys(String.fromCharCode(27, 91, 67)); return true }; // Right
        if (e.which == 40) { obj.TermSendKeys(String.fromCharCode(27, 91, 66)); return true }; // Down

        if (e.which != 8 && e.which != 32) return true;
        obj.TermSendKey(e.which);
        if (e.preventDefault) e.preventDefault();
        if (e.stopPropagation) e.stopPropagation();
        return false;
    }

    obj.TermDraw = function() {
        var c, buf = '', closetag = '', newat, oldat = 1, x1, x2;
        for (var y = 0; y < 25; ++y) {
            for (var x = 0; x < 80; ++x) {
                newat = obj.scratt[y][x];
                if (obj.termx == x && obj.termy == y) { newat |= obj.VTREVERSE; } // If this is the cursor location, reverse the color.
                if (newat != oldat) {
                    buf += closetag;
                    closetag = '';
                    x1 = 6; x2 = 12;
                    if (newat & obj.VTREVERSE) { x1 = 12; x2 = 6;}
                    buf += '<span style="color:#' + obj.TermColors[(newat >> x1) & 0x3F] + ';background-color:#' + obj.TermColors[(newat >> x2) & 0x3F];
                    if (newat & obj.VTUNDERLINE) buf += ';text-decoration:underline';
                    buf += ';">';
                    closetag = "</span>" + closetag;
                    oldat = newat;
                }

                c = obj.tscreen[y][x];
                switch (c) {
                    case '&':
                        buf += '&amp;'; break;
                    case '<':
                        buf += '&lt;'; break;
                    case '>':
                        buf += '&gt;'; break;
                    case ' ':
                        buf += '&nbsp;'; break;
                    default:
                        buf += c;
                        break;
                }
            }
            if (y != 24) buf += '<br>';
        }
        obj.DivElement.innerHTML = "<font size='4'><b>" + buf + closetag + "</b></font>";
    }

    obj.TermInit = function () { obj.TermResetScreen(); }
    
    obj.Init();
    obj.TermDraw();
    return obj;
}/*
 * $Id: rawinflate.js,v 0.2 2009/03/01 18:32:24 dankogai Exp $
 *
 * original:
 * http://www.onicos.com/staff/iz/amuse/javascript/expert/inflate.txt
 */

/* Copyright (C) 1999 Masanao Izumo <iz@onicos.co.jp>
 * Version: 1.0.0.1
 * LastModified: Dec 25 1999
 */

/* Interface:
 * data = inflate(src);
 */

/* constant parameters */
var WSIZE = 32768, // Sliding Window size
	STORED_BLOCK = 0,
	STATIC_TREES = 1,
	DYN_TREES = 2,

/* for inflate */
	lbits = 9, // bits in base literal/length lookup table
	dbits = 6, // bits in base distance lookup table

/* variables (inflate) */
	slide,
	wp, // current position in slide
	fixed_tl = null, // inflate static
	fixed_td, // inflate static
	fixed_bl, // inflate static
	fixed_bd, // inflate static
	bit_buf, // bit buffer
	bit_len, // bits in bit buffer
	method,
	eof,
	copy_leng,
	copy_dist,
	tl, // literal length decoder table
	td, // literal distance decoder table
	bl, // number of bits decoded by tl
	bd, // number of bits decoded by td

	inflate_data,
	inflate_pos,


/* constant tables (inflate) */
	MASK_BITS = [
		0x0000,
		0x0001, 0x0003, 0x0007, 0x000f, 0x001f, 0x003f, 0x007f, 0x00ff,
		0x01ff, 0x03ff, 0x07ff, 0x0fff, 0x1fff, 0x3fff, 0x7fff, 0xffff
	],
	// Tables for deflate from PKZIP's appnote.txt.
	// Copy lengths for literal codes 257..285
	cplens = [
		3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
		35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0
	],
/* note: see note #13 above about the 258 in this list. */
	// Extra bits for literal codes 257..285
	cplext = [
		0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2,
		3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 99, 99 // 99==invalid
	],
	// Copy offsets for distance codes 0..29
	cpdist = [
		1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
		257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
		8193, 12289, 16385, 24577
	],
	// Extra bits for distance codes
	cpdext = [
		0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6,
		7, 7, 8, 8, 9, 9, 10, 10, 11, 11,
		12, 12, 13, 13
	],
	// Order of the bit length code lengths
	border = [
		16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15
	];
/* objects (inflate) */

function HuftList() {
    this.next = null;
    this.list = null;
}

function HuftNode() {
    this.e = 0; // number of extra bits or operation
    this.b = 0; // number of bits in this code or subcode

    // union
    this.n = 0; // literal, length base, or distance base
    this.t = null; // (HuftNode) pointer to next level of table
}

/*
	* @param b-  code lengths in bits (all assumed <= BMAX)
	* @param n- number of codes (assumed <= N_MAX)
	* @param s- number of simple-valued codes (0..s-1)
	* @param d- list of base values for non-simple codes
	* @param e- list of extra bits for non-simple codes
	* @param mm- maximum lookup bits
	*/
function HuftBuild(b, n, s, d, e, mm) {
    this.BMAX = 16; // maximum bit length of any code
    this.N_MAX = 288; // maximum number of codes in any set
    this.status = 0; // 0: success, 1: incomplete table, 2: bad input
    this.root = null; // (HuftList) starting table
    this.m = 0; // maximum lookup bits, returns actual

    /* Given a list of code lengths and a maximum table size, make a set of
        tables to decode that set of codes. Return zero on success, one if
        the given code set is incomplete (the tables are still built in this
        case), two if the input is invalid (all zero length codes or an
        oversubscribed set of lengths), and three if not enough memory.
        The code with value 256 is special, and the tables are constructed
        so that no bits beyond that code are fetched when that code is
        decoded. */
    var a; // counter for codes of length k
    var c = [];
    var el; // length of EOB code (value 256)
    var f; // i repeats in table every f entries
    var g; // maximum code length
    var h; // table level
    var i; // counter, current code
    var j; // counter
    var k; // number of bits in current code
    var lx = [];
    var p; // pointer into c[], b[], or v[]
    var pidx; // index of p
    var q; // (HuftNode) points to current table
    var r = new HuftNode(); // table entry for structure assignment
    var u = [];
    var v = [];
    var w;
    var x = [];
    var xp; // pointer into x or c
    var y; // number of dummy codes added
    var z; // number of entries in current table
    var o;
    var tail; // (HuftList)

    tail = this.root = null;

    // bit length count table
    for (i = 0; i < this.BMAX + 1; i++) {
        c[i] = 0;
    }
    // stack of bits per table
    for (i = 0; i < this.BMAX + 1; i++) {
        lx[i] = 0;
    }
    // HuftNode[BMAX][]  table stack
    for (i = 0; i < this.BMAX; i++) {
        u[i] = null;
    }
    // values in order of bit length
    for (i = 0; i < this.N_MAX; i++) {
        v[i] = 0;
    }
    // bit offsets, then code stack
    for (i = 0; i < this.BMAX + 1; i++) {
        x[i] = 0;
    }

    // Generate counts for each bit length
    el = n > 256 ? b[256] : this.BMAX; // set length of EOB code, if any
    p = b; pidx = 0;
    i = n;
    do {
        c[p[pidx]]++; // assume all entries <= BMAX
        pidx++;
    } while (--i > 0);
    if (c[0] === n) { // null input--all zero length codes
        this.root = null;
        this.m = 0;
        this.status = 0;
        return;
    }

    // Find minimum and maximum length, bound *m by those
    for (j = 1; j <= this.BMAX; j++) {
        if (c[j] !== 0) {
            break;
        }
    }
    k = j; // minimum code length
    if (mm < j) {
        mm = j;
    }
    for (i = this.BMAX; i !== 0; i--) {
        if (c[i] !== 0) {
            break;
        }
    }
    g = i; // maximum code length
    if (mm > i) {
        mm = i;
    }

    // Adjust last length count to fill out codes, if needed
    for (y = 1 << j; j < i; j++, y <<= 1) {
        if ((y -= c[j]) < 0) {
            this.status = 2; // bad input: more codes than bits
            this.m = mm;
            return;
        }
    }
    if ((y -= c[i]) < 0) {
        this.status = 2;
        this.m = mm;
        return;
    }
    c[i] += y;

    // Generate starting offsets into the value table for each length
    x[1] = j = 0;
    p = c;
    pidx = 1;
    xp = 2;
    while (--i > 0) { // note that i == g from above
        x[xp++] = (j += p[pidx++]);
    }

    // Make a table of values in order of bit lengths
    p = b; pidx = 0;
    i = 0;
    do {
        if ((j = p[pidx++]) !== 0) {
            v[x[j]++] = i;
        }
    } while (++i < n);
    n = x[g]; // set n to length of v

    // Generate the Huffman codes and for each, make the table entries
    x[0] = i = 0; // first Huffman code is zero
    p = v; pidx = 0; // grab values in bit order
    h = -1; // no tables yet--level -1
    w = lx[0] = 0; // no bits decoded yet
    q = null; // ditto
    z = 0; // ditto

    // go through the bit lengths (k already is bits in shortest code)
    for (; k <= g; k++) {
        a = c[k];
        while (a-- > 0) {
            // here i is the Huffman code of length k bits for value p[pidx]
            // make tables up to required level
            while (k > w + lx[1 + h]) {
                w += lx[1 + h]; // add bits already decoded
                h++;

                // compute minimum size table less than or equal to *m bits
                z = (z = g - w) > mm ? mm : z; // upper limit
                if ((f = 1 << (j = k - w)) > a + 1) { // try a k-w bit table
                    // too few codes for k-w bit table
                    f -= a + 1; // deduct codes from patterns left
                    xp = k;
                    while (++j < z) { // try smaller tables up to z bits
                        if ((f <<= 1) <= c[++xp]) {
                            break; // enough codes to use up j bits
                        }
                        f -= c[xp]; // else deduct codes from patterns
                    }
                }
                if (w + j > el && w < el) {
                    j = el - w; // make EOB code end at table
                }
                z = 1 << j; // table entries for j-bit table
                lx[1 + h] = j; // set table size in stack

                // allocate and link in new table
                q = [];
                for (o = 0; o < z; o++) {
                    q[o] = new HuftNode();
                }

                if (!tail) {
                    tail = this.root = new HuftList();
                } else {
                    tail = tail.next = new HuftList();
                }
                tail.next = null;
                tail.list = q;
                u[h] = q; // table starts after link

                /* connect to last table, if there is one */
                if (h > 0) {
                    x[h] = i; // save pattern for backing up
                    r.b = lx[h]; // bits to dump before this table
                    r.e = 16 + j; // bits in this table
                    r.t = q; // pointer to this table
                    j = (i & ((1 << w) - 1)) >> (w - lx[h]);
                    u[h - 1][j].e = r.e;
                    u[h - 1][j].b = r.b;
                    u[h - 1][j].n = r.n;
                    u[h - 1][j].t = r.t;
                }
            }

            // set up table entry in r
            r.b = k - w;
            if (pidx >= n) {
                r.e = 99; // out of values--invalid code
            } else if (p[pidx] < s) {
                r.e = (p[pidx] < 256 ? 16 : 15); // 256 is end-of-block code
                r.n = p[pidx++]; // simple code is just the value
            } else {
                r.e = e[p[pidx] - s]; // non-simple--look up in lists
                r.n = d[p[pidx++] - s];
            }

            // fill code-like entries with r //
            f = 1 << (k - w);
            for (j = i >> w; j < z; j += f) {
                q[j].e = r.e;
                q[j].b = r.b;
                q[j].n = r.n;
                q[j].t = r.t;
            }

            // backwards increment the k-bit code i
            for (j = 1 << (k - 1) ; (i & j) !== 0; j >>= 1) {
                i ^= j;
            }
            i ^= j;

            // backup over finished tables
            while ((i & ((1 << w) - 1)) !== x[h]) {
                w -= lx[h]; // don't need to update q
                h--;
            }
        }
    }

    /* return actual size of base table */
    this.m = lx[1];

    /* Return true (1) if we were given an incomplete table */
    this.status = ((y !== 0 && g !== 1) ? 1 : 0);
}


/* routines (inflate) */

function GET_BYTE() {
    if (inflate_data.length === inflate_pos) {
        return -1;
    }
    return inflate_data[inflate_pos++] & 0xff;
}

function NEEDBITS(n) {
    while (bit_len < n) {
        bit_buf |= GET_BYTE() << bit_len;
        bit_len += 8;
    }
}

function GETBITS(n) {
    return bit_buf & MASK_BITS[n];
}

function DUMPBITS(n) {
    bit_buf >>= n;
    bit_len -= n;
}

function inflate_codes(buff, off, size) {
    // inflate (decompress) the codes in a deflated (compressed) block.
    // Return an error code or zero if it all goes ok.
    var e; // table entry flag/number of extra bits
    var t; // (HuftNode) pointer to table entry
    var n;

    if (size === 0) {
        return 0;
    }

    // inflate the coded data
    n = 0;
    for (; ;) { // do until end of block
        NEEDBITS(bl);
        t = tl.list[GETBITS(bl)];
        e = t.e;
        while (e > 16) {
            if (e === 99) {
                return -1;
            }
            DUMPBITS(t.b);
            e -= 16;
            NEEDBITS(e);
            t = t.t[GETBITS(e)];
            e = t.e;
        }
        DUMPBITS(t.b);

        if (e === 16) { // then it's a literal
            wp &= WSIZE - 1;
            buff[off + n++] = slide[wp++] = t.n;
            if (n === size) {
                return size;
            }
            continue;
        }

        // exit if end of block
        if (e === 15) {
            break;
        }

        // it's an EOB or a length

        // get length of block to copy
        NEEDBITS(e);
        copy_leng = t.n + GETBITS(e);
        DUMPBITS(e);

        // decode distance of block to copy
        NEEDBITS(bd);
        t = td.list[GETBITS(bd)];
        e = t.e;

        while (e > 16) {
            if (e === 99) {
                return -1;
            }
            DUMPBITS(t.b);
            e -= 16;
            NEEDBITS(e);
            t = t.t[GETBITS(e)];
            e = t.e;
        }
        DUMPBITS(t.b);
        NEEDBITS(e);
        copy_dist = wp - t.n - GETBITS(e);
        DUMPBITS(e);

        // do the copy
        while (copy_leng > 0 && n < size) {
            copy_leng--;
            copy_dist &= WSIZE - 1;
            wp &= WSIZE - 1;
            buff[off + n++] = slide[wp++] = slide[copy_dist++];
        }

        if (n === size) {
            return size;
        }
    }

    method = -1; // done
    return n;
}

function inflate_stored(buff, off, size) {
    /* "decompress" an inflated type 0 (stored) block. */
    var n;

    // go to byte boundary
    n = bit_len & 7;
    DUMPBITS(n);

    // get the length and its complement
    NEEDBITS(16);
    n = GETBITS(16);
    DUMPBITS(16);
    NEEDBITS(16);
    if (n !== ((~bit_buf) & 0xffff)) {
        return -1; // error in compressed data
    }
    DUMPBITS(16);

    // read and output the compressed data
    copy_leng = n;

    n = 0;
    while (copy_leng > 0 && n < size) {
        copy_leng--;
        wp &= WSIZE - 1;
        NEEDBITS(8);
        buff[off + n++] = slide[wp++] = GETBITS(8);
        DUMPBITS(8);
    }

    if (copy_leng === 0) {
        method = -1; // done
    }
    return n;
}

function inflate_fixed(buff, off, size) {
    // decompress an inflated type 1 (fixed Huffman codes) block.  We should
    // either replace this with a custom decoder, or at least precompute the
    // Huffman tables.

    // if first time, set up tables for fixed blocks
    if (!fixed_tl) {
        var i; // temporary variable
        var l = []; // 288 length list for huft_build (initialized below)
        var h; // HuftBuild

        // literal table
        for (i = 0; i < 144; i++) {
            l[i] = 8;
        }
        for (; i < 256; i++) {
            l[i] = 9;
        }
        for (; i < 280; i++) {
            l[i] = 7;
        }
        for (; i < 288; i++) { // make a complete, but wrong code set
            l[i] = 8;
        }
        fixed_bl = 7;

        h = new HuftBuild(l, 288, 257, cplens, cplext, fixed_bl);
        if (h.status !== 0) {
            console.error("HufBuild error: " + h.status);
            return -1;
        }
        fixed_tl = h.root;
        fixed_bl = h.m;

        // distance table
        for (i = 0; i < 30; i++) { // make an incomplete code set
            l[i] = 5;
        }
        fixed_bd = 5;

        h = new HuftBuild(l, 30, 0, cpdist, cpdext, fixed_bd);
        if (h.status > 1) {
            fixed_tl = null;
            console.error("HufBuild error: " + h.status);
            return -1;
        }
        fixed_td = h.root;
        fixed_bd = h.m;
    }

    tl = fixed_tl;
    td = fixed_td;
    bl = fixed_bl;
    bd = fixed_bd;
    return inflate_codes(buff, off, size);
}

function inflate_dynamic(buff, off, size) {
    // decompress an inflated type 2 (dynamic Huffman codes) block.
    var i; // temporary variables
    var j;
    var l; // last length
    var n; // number of lengths to get
    var t; // (HuftNode) literal/length code table
    var nb; // number of bit length codes
    var nl; // number of literal/length codes
    var nd; // number of distance codes
    var ll = [];
    var h; // (HuftBuild)

    // literal/length and distance code lengths
    for (i = 0; i < 286 + 30; i++) {
        ll[i] = 0;
    }

    // read in table lengths
    NEEDBITS(5);
    nl = 257 + GETBITS(5); // number of literal/length codes
    DUMPBITS(5);
    NEEDBITS(5);
    nd = 1 + GETBITS(5); // number of distance codes
    DUMPBITS(5);
    NEEDBITS(4);
    nb = 4 + GETBITS(4); // number of bit length codes
    DUMPBITS(4);
    if (nl > 286 || nd > 30) {
        return -1; // bad lengths
    }

    // read in bit-length-code lengths
    for (j = 0; j < nb; j++) {
        NEEDBITS(3);
        ll[border[j]] = GETBITS(3);
        DUMPBITS(3);
    }
    for (; j < 19; j++) {
        ll[border[j]] = 0;
    }

    // build decoding table for trees--single level, 7 bit lookup
    bl = 7;
    h = new HuftBuild(ll, 19, 19, null, null, bl);
    if (h.status !== 0) {
        return -1; // incomplete code set
    }

    tl = h.root;
    bl = h.m;

    // read in literal and distance code lengths
    n = nl + nd;
    i = l = 0;
    while (i < n) {
        NEEDBITS(bl);
        t = tl.list[GETBITS(bl)];
        j = t.b;
        DUMPBITS(j);
        j = t.n;
        if (j < 16) { // length of code in bits (0..15)
            ll[i++] = l = j; // save last length in l
        } else if (j === 16) { // repeat last length 3 to 6 times
            NEEDBITS(2);
            j = 3 + GETBITS(2);
            DUMPBITS(2);
            if (i + j > n) {
                return -1;
            }
            while (j-- > 0) {
                ll[i++] = l;
            }
        } else if (j === 17) { // 3 to 10 zero length codes
            NEEDBITS(3);
            j = 3 + GETBITS(3);
            DUMPBITS(3);
            if (i + j > n) {
                return -1;
            }
            while (j-- > 0) {
                ll[i++] = 0;
            }
            l = 0;
        } else { // j === 18: 11 to 138 zero length codes
            NEEDBITS(7);
            j = 11 + GETBITS(7);
            DUMPBITS(7);
            if (i + j > n) {
                return -1;
            }
            while (j-- > 0) {
                ll[i++] = 0;
            }
            l = 0;
        }
    }

    // build the decoding tables for literal/length and distance codes
    bl = lbits;
    h = new HuftBuild(ll, nl, 257, cplens, cplext, bl);
    if (bl === 0) { // no literals or lengths
        h.status = 1;
    }
    if (h.status !== 0) {
        if (h.status !== 1) {
            return -1; // incomplete code set
        }
        // **incomplete literal tree**
    }
    tl = h.root;
    bl = h.m;

    for (i = 0; i < nd; i++) {
        ll[i] = ll[i + nl];
    }
    bd = dbits;
    h = new HuftBuild(ll, nd, 0, cpdist, cpdext, bd);
    td = h.root;
    bd = h.m;

    if (bd === 0 && nl > 257) { // lengths but no distances
        // **incomplete distance tree**
        return -1;
    }
    /*
            if (h.status === 1) {
                // **incomplete distance tree**
            }
    */
    if (h.status !== 0) {
        return -1;
    }

    // decompress until an end-of-block code
    return inflate_codes(buff, off, size);
}

function inflate_start() {
    if (!slide) {
        slide = []; // new Array(2 * WSIZE); // slide.length is never called
    }
    wp = 0;
    bit_buf = 0;
    bit_len = 0;
    //method = -1;
    //eof = false;
    copy_leng = copy_dist = 0;
    tl = null;
}

function inflate_internal(buff, off, size) {
    // decompress an inflated entry
    var n, i;

    n = 0;
    while (n < size) {
        if (eof && method === -1) {
            return n;
        }

        if (copy_leng > 0) {
            if (method !== STORED_BLOCK) {
                // STATIC_TREES or DYN_TREES
                while (copy_leng > 0 && n < size) {
                    copy_leng--;
                    copy_dist &= WSIZE - 1;
                    wp &= WSIZE - 1;
                    buff[off + n++] = slide[wp++] = slide[copy_dist++];
                }
            } else {
                while (copy_leng > 0 && n < size) {
                    copy_leng--;
                    wp &= WSIZE - 1;
                    NEEDBITS(8);
                    buff[off + n++] = slide[wp++] = GETBITS(8);
                    DUMPBITS(8);
                }
                if (copy_leng === 0) {
                    method = -1; // done
                }
            }
            if (n === size) {
                return n;
            }
        }

        if (method === -1) {
            if (eof) {
                break;
            }

            // read in last block bit
            NEEDBITS(1);
            if (GETBITS(1) !== 0) {
                eof = true;
            }
            DUMPBITS(1);

            // read in block type
            NEEDBITS(2);
            method = GETBITS(2);
            DUMPBITS(2);
            tl = null;
            copy_leng = 0;
        }

        switch (method) {
            case STORED_BLOCK:
                i = inflate_stored(buff, off + n, size - n);
                break;

            case STATIC_TREES:
                if (tl) {
                    i = inflate_codes(buff, off + n, size - n);
                } else {
                    i = inflate_fixed(buff, off + n, size - n);
                }
                break;

            case DYN_TREES:
                if (tl) {
                    i = inflate_codes(buff, off + n, size - n);
                } else {
                    i = inflate_dynamic(buff, off + n, size - n);
                }
                break;

            default: // error
                i = -1;
                break;
        }

        if (i === -1) {
            if (eof) {
                return 0;
            }
            return -1;
        }
        n += i;
    }
    return n;
}

function inflate(arr) {
    var buff = [], i;

    // inflate_start();
    bit_buf = 0;
    bit_len = 0;
    method = -1;
    eof = false;

    inflate_data = arr;
    inflate_pos = 0;

    do {
        i = inflate_internal(buff, buff.length, 1024);
    } while (i > 0);
    inflate_data = null; // G.C.
    return buff;
}

        var version = '0.0.7';
        var urlvars = null;
        var amtstack = null;
        var wsstack = null;

        // var AllWsmanStr = "AMT_8021xCredentialContext,AMT_8021XProfile,AMT_ActiveFilterStatistics,AMT_AgentPresenceCapabilities,AMT_AgentPresenceInterfacePolicy,AMT_AgentPresenceService,AMT_AgentPresenceWatchdog,AMT_AgentPresenceWatchdogAction,AMT_AlarmClockService,AMT_AssetTable,AMT_AssetTableService,AMT_AuditLog,AMT_AuditPolicyRule,AMT_AuthorizationService,AMT_BootCapabilities,AMT_BootSettingData,AMT_ComplexFilterEntryBase,AMT_CRL,AMT_CryptographicCapabilities,AMT_EACCredentialContext,AMT_EndpointAccessControlService,AMT_EnvironmentDetectionInterfacePolicy,AMT_EnvironmentDetectionSettingData,AMT_EthernetPortSettings,AMT_EventLogEntry,AMT_EventManagerService,AMT_EventSubscriber,AMT_FilterEntryBase,AMT_FilterInSystemDefensePolicy,AMT_GeneralSettings,AMT_GeneralSystemDefenseCapabilities,AMT_Hdr8021Filter,AMT_HeuristicPacketFilterInterfacePolicy,AMT_HeuristicPacketFilterSettings,AMT_HeuristicPacketFilterStatistics,AMT_InterfacePolicy,AMT_IPHeadersFilter,AMT_KerberosSettingData,AMT_ManagementPresenceRemoteSAP,AMT_MessageLog,AMT_MPSUsernamePassword,AMT_NetworkFilter,AMT_NetworkPortDefaultSystemDefensePolicy,AMT_NetworkPortSystemDefenseCapabilities,AMT_NetworkPortSystemDefensePolicy,AMT_PCIDevice,AMT_PETCapabilities,AMT_PETFilterForTarget,AMT_PETFilterSetting,AMT_ProvisioningCertificateHash,AMT_PublicKeyCertificate,AMT_PublicKeyManagementCapabilities,AMT_PublicKeyManagementService,AMT_PublicPrivateKeyPair,AMT_RedirectionService,AMT_RemoteAccessCapabilities,AMT_RemoteAccessCredentialContext,AMT_RemoteAccessPolicyAppliesToMPS,AMT_RemoteAccessPolicyRule,AMT_RemoteAccessService,AMT_SetupAndConfigurationService,AMT_SNMPEventSubscriber,AMT_SOAPEventSubscriber,AMT_StateTransitionCondition,AMT_SystemDefensePolicy,AMT_SystemDefensePolicyInService,AMT_SystemDefenseService,AMT_SystemPowerScheme,AMT_ThirdPartyDataStorageAdministrationService,AMT_ThirdPartyDataStorageService,AMT_TimeSynchronizationService,AMT_TLSCredentialContext,AMT_TLSProtocolEndpoint,AMT_TLSProtocolEndpointCollection,AMT_TLSSettingData,AMT_TrapTargetForService,AMT_UserInitiatedConnectionService,AMT_WebUIService,AMT_WiFiPortConfigurationService,CIM_AbstractIndicationSubscription,CIM_Account,CIM_AccountManagementCapabilities,CIM_AccountManagementService,CIM_AccountOnSystem,CIM_AdminDomain,CIM_AlertIndication,CIM_AssignedIdentity,CIM_AssociatedPowerManagementService,CIM_AuthenticationService,CIM_AuthorizationService,CIM_AuthorizedPrivilege,CIM_BIOSElement,CIM_BIOSFeature,CIM_BIOSFeatureBIOSElements,CIM_BootConfigSetting,CIM_BootService,CIM_BootSettingData,CIM_BootSourceSetting,CIM_Capabilities,CIM_Card,CIM_Chassis,CIM_Chip,CIM_Collection,CIM_Component,CIM_ComputerSystem,CIM_ComputerSystemPackage,CIM_ConcreteComponent,CIM_ConcreteDependency,CIM_ConcreteJob,CIM_Controller,CIM_CoolingDevice,CIM_Credential,CIM_CredentialContext,CIM_CredentialManagementService,CIM_Dependency,CIM_DeviceSAPImplementation,CIM_ElementCapabilities,CIM_ElementConformsToProfile,CIM_ElementLocation,CIM_ElementSettingData,CIM_ElementSoftwareIdentity,CIM_ElementStatisticalData,CIM_EnabledLogicalElement,CIM_EnabledLogicalElementCapabilities,CIM_Error,CIM_EthernetPort,CIM_Fan,CIM_FilterCollection,CIM_FilterCollectionSubscription,CIM_HostedAccessPoint,CIM_HostedDependency,CIM_HostedService,CIM_Identity,CIM_IdentityManagementService,CIM_IEEE8021xCapabilities,CIM_IEEE8021xSettings,CIM_Indication,CIM_IndicationService,CIM_InstalledSoftwareIdentity,CIM_Job,CIM_KVMRedirectionSAP,CIM_LANEndpoint,CIM_ListenerDestination,CIM_ListenerDestinationWSManagement,CIM_Location,CIM_Log,CIM_LogEntry,CIM_LogicalDevice,CIM_LogicalElement,CIM_LogicalPort,CIM_LogicalPortCapabilities,CIM_LogManagesRecord,CIM_ManagedCredential,CIM_ManagedElement,CIM_ManagedSystemElement,CIM_MediaAccessDevice,CIM_MemberOfCollection,CIM_Memory,CIM_MessageLog,CIM_NetworkPort,CIM_NetworkPortCapabilities,CIM_NetworkPortConfigurationService,CIM_OrderedComponent,CIM_OwningCollectionElement,CIM_OwningJobElement,CIM_PCIController,CIM_PhysicalComponent,CIM_PhysicalConnector,CIM_PhysicalElement,CIM_PhysicalElementLocation,CIM_PhysicalFrame,CIM_PhysicalMemory,CIM_PhysicalPackage,CIM_Policy,CIM_PolicyAction,CIM_PolicyCondition,CIM_PolicyInSystem,CIM_PolicyRule,CIM_PolicyRuleInSystem,CIM_PolicySet,CIM_PolicySetAppliesToElement,CIM_PolicySetInSystem,CIM_PowerManagementCapabilities,CIM_PowerManagementService,CIM_PowerSupply,CIM_Privilege,CIM_PrivilegeManagementCapabilities,CIM_PrivilegeManagementService,CIM_ProcessIndication,CIM_Processor,CIM_ProtocolEndpoint,CIM_ProvidesServiceToElement,CIM_Realizes,CIM_RecordForLog,CIM_RecordLog,CIM_RedirectionService,CIM_ReferencedProfile,CIM_RegisteredProfile,CIM_RemoteAccessAvailableToElement,CIM_RemoteIdentity,CIM_RemotePort,CIM_RemoteServiceAccessPoint,CIM_Role,CIM_RoleBasedAuthorizationService,CIM_RoleBasedManagementCapabilities,CIM_RoleLimitedToTarget,CIM_SAPAvailableForElement,CIM_SecurityService,CIM_Sensor,CIM_Service,CIM_ServiceAccessBySAP,CIM_ServiceAccessPoint,CIM_ServiceAffectsElement,CIM_ServiceAvailableToElement,CIM_ServiceSAPDependency,CIM_ServiceServiceDependency,CIM_SettingData,CIM_SharedCredential,CIM_SoftwareElement,CIM_SoftwareFeature,CIM_SoftwareFeatureSoftwareElements,CIM_SoftwareIdentity,CIM_StatisticalData,CIM_StorageExtent,CIM_System,CIM_SystemBIOS,CIM_SystemComponent,CIM_SystemDevice,CIM_SystemPackaging,CIM_UseOfLog,CIM_Watchdog,CIM_WiFiEndpoint,CIM_WiFiEndpointCapabilities,CIM_WiFiEndpointSettings,CIM_WiFiPort,CIM_WiFiPortCapabilities,IPS_AdminProvisioningRecord,IPS_ClientProvisioningRecord,IPS_HostBasedSetupService,IPS_HostIPSettings,IPS_IderSessionUsingPort,IPS_IPv6PortSettings,IPS_KVMRedirectionSettingData,IPS_KvmSessionUsingPort,IPS_ManualProvisioningRecord,IPS_OptInService,IPS_ProvisioningAuditRecord,IPS_ProvisioningRecordLog,IPS_RasSessionUsingPort,IPS_SecIOService,IPS_SessionUsingPort,IPS_SolSessionUsingPort,IPS_TLSProvisioningRecord";
        var AllWsmanStr = "AMT_8021xCredentialContext,AMT_8021XProfile,AMT_ActiveFilterStatistics,AMT_AgentPresenceCapabilities,AMT_AgentPresenceInterfacePolicy,AMT_AgentPresenceService,AMT_AgentPresenceWatchdog,AMT_AgentPresenceWatchdogAction,AMT_AlarmClockService,AMT_AssetTable,AMT_AssetTableService,AMT_AuditLog,AMT_AuditPolicyRule,AMT_AuthorizationService,AMT_BootCapabilities,AMT_BootSettingData,AMT_ComplexFilterEntryBase,AMT_CRL,AMT_CryptographicCapabilities,AMT_EACCredentialContext,AMT_EndpointAccessControlService,AMT_EnvironmentDetectionInterfacePolicy,AMT_EnvironmentDetectionSettingData,AMT_EthernetPortSettings,AMT_EventLogEntry,AMT_EventManagerService,AMT_EventSubscriber,AMT_FilterEntryBase,AMT_FilterInSystemDefensePolicy,AMT_GeneralSettings,AMT_GeneralSystemDefenseCapabilities,AMT_Hdr8021Filter,AMT_HeuristicPacketFilterInterfacePolicy,AMT_HeuristicPacketFilterSettings,AMT_HeuristicPacketFilterStatistics,AMT_InterfacePolicy,AMT_IPHeadersFilter,AMT_KerberosSettingData,AMT_ManagementPresenceRemoteSAP,AMT_MessageLog,AMT_MPSUsernamePassword,AMT_NetworkFilter,AMT_NetworkPortDefaultSystemDefensePolicy,AMT_NetworkPortSystemDefenseCapabilities,AMT_NetworkPortSystemDefensePolicy,AMT_PCIDevice,AMT_PETCapabilities,AMT_PETFilterForTarget,AMT_PETFilterSetting,AMT_ProvisioningCertificateHash,AMT_PublicKeyCertificate,AMT_PublicKeyManagementCapabilities,AMT_PublicKeyManagementService,AMT_PublicPrivateKeyPair,AMT_RedirectionService,AMT_RemoteAccessCapabilities,AMT_RemoteAccessCredentialContext,AMT_RemoteAccessPolicyAppliesToMPS,AMT_RemoteAccessPolicyRule,AMT_RemoteAccessService,AMT_SetupAndConfigurationService,AMT_SNMPEventSubscriber,AMT_StateTransitionCondition,AMT_SystemDefensePolicy,AMT_SystemDefensePolicyInService,AMT_SystemDefenseService,AMT_SystemPowerScheme,AMT_ThirdPartyDataStorageAdministrationService,AMT_ThirdPartyDataStorageService,AMT_TimeSynchronizationService,AMT_TLSCredentialContext,AMT_TLSProtocolEndpoint,AMT_TLSProtocolEndpointCollection,AMT_TLSSettingData,AMT_TrapTargetForService,AMT_UserInitiatedConnectionService,AMT_WebUIService,AMT_WiFiPortConfigurationService,CIM_AbstractIndicationSubscription,CIM_Account,CIM_AccountManagementCapabilities,CIM_AccountManagementService,CIM_AccountOnSystem,CIM_AdminDomain,CIM_AlertIndication,CIM_AssignedIdentity,CIM_AssociatedPowerManagementService,CIM_AuthenticationService,CIM_AuthorizationService,CIM_BIOSElement,CIM_BIOSFeature,CIM_BIOSFeatureBIOSElements,CIM_BootConfigSetting,CIM_BootService,CIM_BootSettingData,CIM_BootSourceSetting,CIM_Capabilities,CIM_Card,CIM_Chassis,CIM_Chip,CIM_Collection,CIM_Component,CIM_ComputerSystem,CIM_ComputerSystemPackage,CIM_ConcreteComponent,CIM_ConcreteDependency,CIM_Controller,CIM_CoolingDevice,CIM_Credential,CIM_CredentialContext,CIM_CredentialManagementService,CIM_Dependency,CIM_DeviceSAPImplementation,CIM_ElementCapabilities,CIM_ElementConformsToProfile,CIM_ElementLocation,CIM_ElementSettingData,CIM_ElementSoftwareIdentity,CIM_ElementStatisticalData,CIM_EnabledLogicalElement,CIM_EnabledLogicalElementCapabilities,CIM_EthernetPort,CIM_Fan,CIM_FilterCollection,CIM_FilterCollectionSubscription,CIM_HostedAccessPoint,CIM_HostedDependency,CIM_HostedService,CIM_Identity,CIM_IEEE8021xCapabilities,CIM_IEEE8021xSettings,CIM_Indication,CIM_IndicationService,CIM_InstalledSoftwareIdentity,CIM_KVMRedirectionSAP,CIM_LANEndpoint,CIM_ListenerDestination,CIM_ListenerDestinationWSManagement,CIM_Location,CIM_Log,CIM_LogEntry,CIM_LogicalDevice,CIM_LogicalElement,CIM_LogicalPort,CIM_LogicalPortCapabilities,CIM_LogManagesRecord,CIM_ManagedCredential,CIM_ManagedElement,CIM_ManagedSystemElement,CIM_MediaAccessDevice,CIM_MemberOfCollection,CIM_Memory,CIM_MessageLog,CIM_NetworkPort,CIM_NetworkPortCapabilities,CIM_NetworkPortConfigurationService,CIM_OrderedComponent,CIM_OwningCollectionElement,CIM_OwningJobElement,CIM_PCIController,CIM_PhysicalComponent,CIM_PhysicalElement,CIM_PhysicalElementLocation,CIM_PhysicalFrame,CIM_PhysicalMemory,CIM_PhysicalPackage,CIM_Policy,CIM_PolicyAction,CIM_PolicyCondition,CIM_PolicyInSystem,CIM_PolicyRule,CIM_PolicyRuleInSystem,CIM_PolicySet,CIM_PolicySetAppliesToElement,CIM_PolicySetInSystem,CIM_PowerManagementCapabilities,CIM_PowerManagementService,CIM_PowerSupply,CIM_Privilege,CIM_PrivilegeManagementCapabilities,CIM_PrivilegeManagementService,CIM_ProcessIndication,CIM_Processor,CIM_ProtocolEndpoint,CIM_ProvidesServiceToElement,CIM_Realizes,CIM_RecordForLog,CIM_RecordLog,CIM_RedirectionService,CIM_ReferencedProfile,CIM_RegisteredProfile,CIM_RemoteAccessAvailableToElement,CIM_RemoteIdentity,CIM_RemotePort,CIM_RemoteServiceAccessPoint,CIM_Role,CIM_RoleBasedAuthorizationService,CIM_RoleBasedManagementCapabilities,CIM_RoleLimitedToTarget,CIM_SAPAvailableForElement,CIM_SecurityService,CIM_Sensor,CIM_Service,CIM_ServiceAccessBySAP,CIM_ServiceAccessPoint,CIM_ServiceAffectsElement,CIM_ServiceAvailableToElement,CIM_ServiceSAPDependency,CIM_ServiceServiceDependency,CIM_SettingData,CIM_SharedCredential,CIM_SoftwareElement,CIM_SoftwareFeature,CIM_SoftwareFeatureSoftwareElements,CIM_SoftwareIdentity,CIM_StatisticalData,CIM_StorageExtent,CIM_System,CIM_SystemBIOS,CIM_SystemComponent,CIM_SystemDevice,CIM_SystemPackaging,CIM_UseOfLog,CIM_Watchdog,CIM_WiFiEndpoint,CIM_WiFiEndpointCapabilities,CIM_WiFiEndpointSettings,CIM_WiFiPort,CIM_WiFiPortCapabilities,IPS_AdminProvisioningRecord,IPS_ClientProvisioningRecord,IPS_HostBasedSetupService,IPS_HostIPSettings,IPS_IderSessionUsingPort,IPS_IPv6PortSettings,IPS_KVMRedirectionSettingData,IPS_KvmSessionUsingPort,IPS_ManualProvisioningRecord,IPS_OptInService,IPS_ProvisioningAuditRecord,IPS_ProvisioningRecordLog,IPS_RasSessionUsingPort,IPS_SecIOService,IPS_SessionUsingPort,IPS_SolSessionUsingPort,IPS_TLSProvisioningRecord";
        var AllWsman = AllWsmanStr.split(',');


        var terminal = null;

        var currentView = 0;
        var LoadingHtml = "<div style='text-align:center;padding-top:20px'>Loading...<div>";
        var LockedPanels = [];
        var amtversion = 0;
        var amtversionmin = 0;
        var amtFirstPull = 0; // Bitmask, Set this when the first pull request is made on a device: 1 = HardwareInfo, 2 = WirelessInfo

        var desktop = null;
        var desktopsettings = { encoding:2, showfocus:false, showmouse:true, showcad:true };


        var webcompilerfeatures = ['AuditLog','Certificates','ComputerSelector','Desktop','DesktopFocus','DesktopRotation','EventLog','Inflate','Look-Commander','Mode-WebSite','Terminal','Wireless','WsmanBrowser'];
        var StatusStrs = ['Disconnected.', 'Connecting...', 'Setup...', 'Connected.'];

        function xx() {
            desktop.setRotation(desktop.rotation - 1);
        }

        function startup() {
            var t;
            urlvars = getUrlVars();

            var s = hex_md5("abc");
            //.toLowerCase() == "900150983cd24fb0d6963f7d28e17f72";





            // Add all WSMAN objects to WSMAN browser
            for (var w in AllWsman) { var option = document.createElement("option"); option.text = AllWsman[w]; option.id = 'WSB-' + AllWsman[w]; Q('QuerySelect').add(option); }



            // Setup the remote desktop
            
            
            desktop = CreateAmtRedirect(CreateAmtRemoteDesktop('Desk'));
            
            desktop.onStateChanged = onDesktopStateChange;
            QE('connectbutton1', true);
            t = localStorage.getItem('desktopsettings');
            if (t != null) { desktopsettings = JSON.parse(t); }
            applyDesktopSettings();
            var s = '';
            //for (var c = 1; c < 13; c++) s += "<option value='" + (0xffbd + c) + "'>F" + c + "</option>";
            //QH("specialkeylist", s);



            // Setup the terminal
            
            
            terminal = CreateAmtRedirect(CreateAmtRemoteTerminal('Term'));
            
            terminal.onStateChanged = onTerminalStateChange;
            QE('connectbutton2', true);



            // Setup the computer selector
            var ctext = localStorage.getItem('computers');
            if (ctext != null) { computerlist = JSON.parse(ctext); }
            go(101);
            // computerlist.push({ h: Math.random(), host: 'localhost', user: 'admin', pass: 'test', tls: 0 });
            updateComputerList();
            QH('computername', 'Web Based Remote Management Console v' + version);




            document.onkeyup = handleKeyUp;
            document.onkeydown = handleKeyDown;
            document.onkeypress = handleKeyPress;
            window.onresize = center;
            center();
        }



        function cleanup() {
            
            terminal.Stop();
            
            
            desktop.Stop();
            
        }

        function handleKeyUp(e) {
            if (xxdialogMode != 0) return;
            
            if (currentView == 14 && desktop.State == 3) return desktop.m.handleKeyUp(e);
            
            
            if (currentView == 13 && terminal.State == 3) return terminal.m.TermHandleKeyUp(e);
            
        }

        function handleKeyDown(e) {
            if (xxdialogMode != 0) return;
            
            if (currentView == 14 && desktop.State == 3) return desktop.m.handleKeyDown(e);
            
            
            if (currentView == 13 && terminal.State == 3) return terminal.m.TermHandleKeyDown(e);
            
        }

        function handleKeyPress(e) {
            if (xxdialogMode != 0) return;
            
            if (currentView == 14 && desktop.State == 3) return desktop.m.handleKeys(e);
            
            
            if (currentView == 13 && terminal.State == 3) return terminal.m.TermHandleKeys(e);
            
        }

        function connect(host, port, user, pass, tls) {
            go(0);
            
            
            wsstack = WsmanStackCreateService(host, port, user, pass, tls);
            
            amtstack = AmtStackCreateService(wsstack);
            amtstack.onProcessChanged = onProcessChanged;

            // Clear everything, make sure all connection state is reset.
            amtversion = 0;
            amtversionmin = 0;
            amtFirstPull = 0;
            amttime = null;
            amtsysstate = null;
            xxAccountFetch = 999;
            amtPowerPollTimer = setInterval(PullPowerState, 10000);

            xxAccountAdminName = null;
            xxAccountRealmInfo = {};
            QH('TableUserAccounts', '');
            
            xxWireless = null;
            QH('TableWifi1', '<div style="text-align:center;padding-top:20px">Loading...<div>');
            QH('TableWifi2', '');
            
            
            eventmessages = null;
            QH('TableEventLog','');
            QH('TableEventLog2','');
            
            
            auditLog = null;
            QH('TableAuditLog', '');
            QH('TableAuditLog2', '');
            
            
            xxCertificates = null;
            QH('TableCerts', '');
            
            
            QH('wsresults', '');
            

            // Start pulling Intel AMT information
            PullSystemStatus();
            amtstack.Enum("CIM_LogicalElement", processSystemVersion); // Get Intel AMT version information
            PullPowerPolicy();
            //PullNetInfo();
            PullUserInfo();
            
            PullEventLog();
            
            
            PullAuditLog();
            
            
            PullCertificates();
            
        }

        function disconnect() {
            if (amtPowerPollTimer != null) { clearInterval(amtPowerPollTimer); amtPowerPollTimer = null; }
            dialogclose(0);
            
            QH('computername', '');
            
            if (amtstack != null) amtstack.CancelAllQueries(999); // Fail all pending WSMAN calls. Set to 999 to indicate not to call back any of the pending calls with errors.
            cleanup();
            wsstack = null;
            amtstack = null;
            onProcessChanged(0, 1);
            go(101);
            
            QH('computername', 'Web Based Remote Management Console v' + version);
            
        }

        function onProcessChanged(a, b) {
            QS('progressbar').width = ((a * 100) / b) + "%";
            
            // If there is nothing being done now, see if we can pull more information
            if (a != 0 || amtstack == null) return;
            if ((amtFirstPull & 1) == 0) { PullHardware(); return; }
        }





        var computerlist = [];
        var currentcomputer = null;

        function computerFilter() {
            var filter = Q('computerFilter').value.toLowerCase();
            for (var w in computerlist) { QV('CI-' + computerlist[w].h, filter == '' || computerlist[w].host.toLowerCase().indexOf(filter) >= 0); }
        }

        function addComputer() {
            if (xxdialogMode != 0) return;
            setDialogMode(4, "Add Computer", 3, function () { addComputerButton(); });
            updateComputerDialog();
        }

        function updateComputerDialog() {
            QE('dlgOkButton', Q('d4hostname').value.length > 0 && Q('d4username').value.length > 0 && (Q('d4username').value == '*' || passwordcheck(Q('d4password').value)));
        }

        function addComputerButton() {
            computerlist.push({ "h": Math.random(), "host": Q('d4hostname').value, "user": Q('d4username').value, "pass": Q('d4password').value, "tls": Q('d4security').value });
            localStorage.setItem('computers', JSON.stringify(computerlist));
            updateComputerList();
        }

        function updateComputerList() {
            QV('noKnownComputers', computerlist.length == 0);
            computerlist.sort(function (a, b) { if (a["host"] > b["host"]) { return 1; } if (a["host"] < b["host"]) { return -1; } return 0; });
            var x = "";
            for (y in computerlist) {
                var computer = computerlist[y];
                var extra = computer["user"] + ", ";
                extra += (computer["tls"] == 0)?"No Security":"TLS"
                x += "<div class='computeritem' id='CI-" + computer["h"] + "' ondblclick='computerConnect(" + computer["h"] + ")'><div style='float:right'><span style='font-size:14px'>" + extra + "</span>&nbsp;" + AddButton2("Connect", "computerConnect(" + computer["h"] + ")") + "&nbsp;" + AddButton2("Remove", "computerRemove(" + computer["h"] + ")") + "&nbsp;</div><div style='padding-top:2px'>&nbsp;<b>" + computer["host"] + "</b></div></div>";
            }
            QH('computerList', x);
        }

        function computerConnect(h) {
            if (xxdialogMode != 0) return;
            currentcomputer = getComputer(h);
            if (currentcomputer == null) return;

            connect(currentcomputer["host"], currentcomputer["tls"]==0?16992:16993, currentcomputer["user"], currentcomputer["pass"], currentcomputer["tls"]);
        }

        function computerRemove(h) {
            if (xxdialogMode != 0) return;
            var computer = getComputer(h);
            if (computer == null) return;
            QH('dialogMessage', "Remove computer \"" + computer.host + "\"?");
            setDialogMode(1, "Remove Computer", 3, function () { computerRemoveEx(h); });
        }

        function computerRemoveEx(h) {
            for (x = 0; x < computerlist.length; x++) { if (computerlist[x]["h"] == h) { computerlist.splice(x, 1); } }
            localStorage.setItem('computers', JSON.stringify(computerlist));
            updateComputerList();
        }

        function getComputer(h) { for (var i in computerlist) { if (computerlist[i]["h"] == h) return computerlist[i]; } return null; }



        //
        // BOTTOM INFORMATION STRING
        //

        function processSystemVersion(stack, name, responses, status) {
            if (errcheck(status)) return;
            if (status == 200) {
                var v = getInstance(responses, "AMT")["VersionString"];
                amtversion = parseInt(v.split('.')[0]);
                amtversionmin = parseInt(v.split('.')[1]);
            }
        }

        //
        // SYSTEM STATUS PANEL
        //

        function PullPowerState() {
            if (amtstack != null && amtstack.GetPendingActions() == 0 && amtsysstate != null) { amtstack.Enum('CIM_ServiceAvailableToElement', function(stack, name, responses, status) { if (errcheck(status)) return; amtsysstate['CIM_ServiceAvailableToElement'].responses = responses; updateSystemStatus(); }); }
        }

        function PullSystemStatus() {
            QH('TableSysStatus', '<div style="text-align:center;padding-top:20px">Loading...<div>');
            amtstack.BatchEnum("", ["CIM_ServiceAvailableToElement", "*AMT_GeneralSettings", "AMT_EthernetPortSettings", "IPS_IPv6PortSettings", "*CIM_ComputerSystemPackage", "*AMT_RedirectionService", "*CIM_KVMRedirectionSAP", "*IPS_OptInService"], processSystemStatus);
            amtstack.AMT_TimeSynchronizationService_GetLowAccuracyTimeSynch(processSystemTime);
        }

        function processSystemTime(stack, name, responses, status) {
            if (errcheck(status)) return;
            amttime = null;
            if (status == 200) {
                // Convert ms to time and adjust for the timezone
                amttime = new Date();
                amttime.setTime(responses.Body["Ta0"] * 1000 + (amttime.getTimezoneOffset() * 60 * 1000));
                updateSystemStatus();
            }
        }

        var amttime = null;
        var amtsysstate = null;
        function processSystemStatus(stack, name, responses, status) {
            if (errcheck(status)) return;
            amtsysstate = responses;
            updateSystemStatus();
            processSystemName(stack, '', responses, 200);
        }

        var DMTFPowerStates = ["", "", "Power On", "Light Sleep", "Deep Sleep", "Power Cycle (Soft Off)", "Off - Hard", "Hibernate (Off Soft)", "Soft Off", "Power Cycle (Off-Hard)", "Master Bus Reset", "Diagnostic Interrupt (NMI)", "Not Applicable", "Off - Soft Graceful", "Off - Hard Graceful", "Master Bus Reset Graceful", "Power Cycle (Off - Soft Graceful)", "Power Cycle (Off - Hard Graceful)", "Diagnostic Interrupt (INIT)"];
        function updateSystemStatus() {
            
            // System Status Table
            var t, y, x = TableStart(), features = '';
            if (amtsysstate != null) {
                t = DMTFPowerStates[amtsysstate['CIM_ServiceAvailableToElement'].responses[0]["PowerState"]];
                
                QH('p13power', t); // Display the power state on the terminal form
                
                
                QH('p14power', t); // Display the power state on the desktop form
                
                x += TableEntry("Power", addLink(t, "showPowerActionDlg()"));

                t = amtsysstate['AMT_GeneralSettings'].response["HostName"];
                y = amtsysstate['AMT_GeneralSettings'].response["DomainName"];
                if (y != null && y.length > 0) t += "." + y;
                if (t.length == 0) t = "<i>None</i>";
                x += TableEntry("Name & Domain", addLink(t, 'showEditNameDlg()'));
                x += TableEntry("System ID", guidToStr(amtsysstate['CIM_ComputerSystemPackage'].response["PlatformGUID"].toLowerCase()));

                
                QH('computername', 'Computer: ' + amtsysstate['AMT_GeneralSettings'].response["HostName"]);
                

                // Intel AMT power state warning. If computer is not powered on, display a warning in terminal and desktop panels.
                QV('p13warning2', amtsysstate['CIM_ServiceAvailableToElement'].responses[0]["PowerState"] != 2);
                QV('p14warning2', amtsysstate['CIM_ServiceAvailableToElement'].responses[0]["PowerState"] != 2);

                // Intel AMT Features
                var redir = (amtsysstate['AMT_RedirectionService'].response["ListenerEnabled"] == 'true'), sol = (amtsysstate['AMT_RedirectionService'].response["EnabledState"] & 2), ider = (amtsysstate['AMT_RedirectionService'].response["EnabledState"] & 1), kvm = ((amtsysstate['CIM_KVMRedirectionSAP'].response["EnabledState"] == 6 && amtsysstate['CIM_KVMRedirectionSAP'].response["RequestedState"] == 2) || amtsysstate['CIM_KVMRedirectionSAP'].response["EnabledState"] == 2);
                if (redir) features += ", Redirection Port";
                if (sol) features += ", Serial-over-LAN";
                if (ider) features += ", IDE-Redirect";
                if (kvm) features += ", KVM";
                if (features == '') features = "  None";
                x += TableEntry("Active Features", addLink(features.substring(2), 'showFeaturesDlg()'));
                QV('p13warning', !redir || !sol); // Show the warning box on top of the terminal if redirection or sol is disabled.
                QV('p14warning', !redir || !kvm); // Show the warning box on top of the remote desktop viewer if redirection or kvm is disabled.
                Q('d9redir').checked = redir, Q('d9kvm').checked = kvm, Q('d9ider').checked = ider, Q('d9sol').checked = sol;

                // Intel AMT user Consent
                features = "Unknown state";
                if (amtsysstate['IPS_OptInService'].response["OptInRequired"] == 0) { features = "Not Required"; Q('d10none').checked = true; }
                if (amtsysstate['IPS_OptInService'].response["OptInRequired"] == 1) { features = "Required for KVM only"; Q('d10kvm').checked = true; }
                if (amtsysstate['IPS_OptInService'].response["OptInRequired"] == 0xFFFFFFFF) { features = "Always Required"; Q('d10all').checked = true; }
                if (amtsysstate['IPS_OptInService'].response["CanModifyOptInPolicy"] == true) features = addLink(features, 'showConsentDlg()'); // If we can modify user consent settings, add the link to do it.
                x += TableEntry("User Consent", features);

                if (currentView == 0) go(1);
            }
            if (amttime != null) { x += TableEntry("Date & Time", amttime.toLocaleDateString() + " &nbsp; " + amttime.toLocaleTimeString()); }
            x += TableEnd(AddButton("Refresh", "PullSystemStatus()") + " " + AddButton("Power Actions...", "showPowerActionDlg()"));

            if (amtsysstate != null) {
                var ifname = { 0 : 'Wired', 1 : 'Wireless' };
                for (y in amtsysstate['AMT_EthernetPortSettings'].responses) {
                    x += "<h2>" + ifname[y] + " Interface</h2>";
                    x += TableStart();
                    x += TableEntry("MAC address", amtsysstate['AMT_EthernetPortSettings'].responses[y]["MACAddress"]);
                    x += TableEntry("IP address", filterIpAddress(amtsysstate['AMT_EthernetPortSettings'].responses[y]["IPAddress"]));
                    x += TableEntry("Gateway / Mask", filterIpAddress(amtsysstate['AMT_EthernetPortSettings'].responses[y]["DefaultGateway"]) + " / " + filterIpAddress(amtsysstate['AMT_EthernetPortSettings'].responses[y]["SubnetMask"]));
                    x += TableEntry("Primary DNS", filterIpAddress(amtsysstate['AMT_EthernetPortSettings'].responses[y]["PrimaryDNS"]));
                    x += TableEntry("IPv6 address", filterIpAddress(amtsysstate['IPS_IPv6PortSettings'].responses[y]["IPv6Address"]));
                    x += TableEnd('');
                }
                
                // If there is a wireless interface, get the data for it. If not, show that there is not.
                if (y == 0) { QH('TableWifi1', '<div style="text-align:center;padding-top:20px">No Wireless Interface Found<div>'); } else { if ((amtFirstPull & 2) == 0) { PullWireless(); }  }
                
            }

            QH('TableSysStatus', x);
        }

        function filterIpAddress(t) { return (!t || t == null || t.length == 0 || t == '::')?"None":t; }

        function processSystemName(stack, name, responses, status) {
            if (errcheck(status)) return;
            var g = amtsysstate['AMT_GeneralSettings'].response;
            var ddns = "";
            if (g["DDNSUpdateEnabled"] == "true") ddns = "checked";
            var sharedFqdn = "";
            if (g["SharedFQDN"] == "true") sharedFqdn = "checked";

            var x = TableStart();
            x += "<tr><td style='padding-left:15px' colspan='2'><br />Configure the managed device FQDN settings for this computer.<br /><br /></td></tr>";
            x += "<tr><td style='padding-left:30px'><span>Computer host name:</span></td><td>&nbsp;<input type='text' value='" + g["HostName"] + "' size=24 maxlength=63 /></td></tr>";
            x += "<tr><td style='padding-left:30px'><span>Domain name:</span></td><td>&nbsp;<input type='text' value='" + g["DomainName"] + "' size=24 maxlength=191 /></td></tr>";
            x += "<tr style='height:10px'><td></td></tr>";
            x += "<tr><td style='padding-left:30px' colspan='2'><input type=checkbox id='sharedFqdnCheck' " + sharedFqdn + " />Shared FQDN</td></tr>";
            x += "<tr><td style='padding-left:30px' colspan='2'><input type=checkbox id='DDNSCheck' " + ddns + " />Use Dynamic DNS update client</td></tr>";
            x += "<tr style='height:10px'><td></td></tr>";
            x += "<tr><td style='padding-left:30px'><span>Dynamic DNS Update Periodic Update interval:</span></td><td>&nbsp;<input type='text' value='" + g["DDNSPeriodicUpdateInterval"] + "' size=24 maxlength=222 /></td></tr>";
            x += "<tr style='height:10px'><td></td></tr>";
            x += TableEnd(AddButton("Submit", "SubmitSystemName()"));
            QH('TableSysName', x);
        }



        //
        // EVENT LOG PANEL
        //

        function PullEventLog() {
            QH('TableEventLog2', LoadingHtml);
            amtstack.Enum("AMT_MessageLog", processMessageLog0);
            amtstack.GetMessageLog(processMessageLog1);
        }

        function processMessageLog0(stack, name, responses, status) {
            if (errcheck(status, 6)) return;
            var x = "<table class=log1 cellpadding=0 cellspacing=0 style='width:100%;border-radius:8px'>";
            var fr = ((responses[0]["IsFrozen"] == 'true') ? AddButton("Start Logging", "FreezeLog(0)") : AddButton("Stop Logging", "FreezeLog(1)"));
            x += TableEnd("<div style='float:right'><input id='eventFilter' type='Text' placeholder='Filter' style='margin:4px' onkeyup='eventFilter()' />&nbsp;</div><div>&nbsp;" + AddButton("Refresh", "PullEventLog()") + fr + AddButton("Clear Log", "ClearLog()")) + "<br />";
            QH('TableEventLog', x);
        }

        var eventmessages = null;
        function processMessageLog1(stack, messages) {
            eventmessages = messages;
            var i, y = 0, x = "<table class=log1 cellpadding=0 cellspacing=0 style='width:100%;border-radius:8px'><tr><td width='80px'><p></p></td><td></td><td></td><td></td></tr>";
            x += "<tr><td class=r1 style='width:90px'><b>&nbsp;&nbsp;Event</b></td><td class=r1 style='width:110px'><b>Time</b></td><td class=r1 style='width:160px'><b>Source</b></td><td class=r1><b>Description</b></td></tr>";
            for (i in messages) {
                y++;
                var icon = 1, m = messages[i];
                if (m.EventSeverity >= 8) { icon = 2; } if (m.EventSeverity >= 16) { icon = 3; }
                x += "<tr id='xamtevent" + i + "' class=r3 onclick='showEventDetails(" + i + ")'><td class=r1><p><div class='icon" + icon + "' style='display:block;float:left;margin-left:5px;margin-right:5px'></div>" + (parseInt(i) + 1) + "</p></td><td class=r1>" + m.TimeStamp.toLocaleDateString() + "<br />" + m.TimeStamp.toLocaleTimeString() + "</td><td class=r1>" + m.EntityStr.replace("(r)", "&reg;") + "</td><td class=r1>" + m.DescriptionStr + "</td></tr>";
            }
            x += TableEnd(y == 0 ? "&nbsp;" : "");
            QH('TableEventLog2', x);
        }

        function FreezeLog(x) { amtstack.AMT_MessageLog_FreezeLog(x, function () { amtstack.Enum("AMT_MessageLog", processMessageLog0); }) }
        function ClearLog(x) { QH('dialogMessage', 'Clear event log?'); setDialogMode(1, "Event Log", 3, ClearLogEx); }
        function ClearLogEx() { amtstack.AMT_MessageLog_ClearLog(function () { PullEventLog(); }) }

        function showEventDetails(h) {
            if (xxdialogMode != 0) return;
            var m = eventmessages[h];
            var x = '<div style="text-align:left">';
            x += addHtmlValue("Time", m.TimeStamp.toLocaleString());
            x += addHtmlValue("Source", m.EntityStr.replace("(r)", "&reg;"));
            x += addHtmlValue("Description", m.DescriptionStr);
            x += MoreStart();
            x += addHtmlValue("Device Address", m.DeviceAddress);
            x += addHtmlValue("Entity", m.Entity);
            x += addHtmlValue("Entity Instance", m.EntityInstance);
            var e = '';
            for (var i in m.EventData) { if (e.length > 0) e +=','; e += m.EventData[i]; }
            x += addHtmlValue("Data", e);
            x += addHtmlValue("Offset", m.EventOffset);
            x += addHtmlValue("Sensor Type", m.EventSensorType);
            x += addHtmlValue("Severity", m.EventSeverity);
            x += addHtmlValue("Source Type", m.EventSourceType);
            x += addHtmlValue("Type", m.EventType);
            x += addHtmlValue("Sensor Number", m.SensorNumber);
            x += MoreEnd();
            x += "</div>";
            QH('dialogMessage', x);
            setDialogMode(1, "Event #" + (h + 1) + " Details", 1);
        }

        function addHtmlValue(t, v) { return '<div style="height:20px"><div style="float:right;width:220px"><b>' + v + '</b></div><div>' + t + '</div></div>'; }

        function eventFilter() {
            var filter = Q('eventFilter').value.toLowerCase();
            for (var w in eventmessages) { QV('xamtevent' + w, filter == '' || eventmessages[w].DescriptionStr.toLowerCase().indexOf(filter) >= 0 || eventmessages[w].EntityStr.toLowerCase().indexOf(filter) >= 0); }
        }





        //
        // AUDIT LOG PANEL
        //

        function PullAuditLog() {
            QH('TableAuditLog2', LoadingHtml);
            amtstack.Enum("AMT_AuditLog", processAuditLog0);
            amtstack.GetAuditLog(processAuditLog1);
        }

        var auditLog = null;
        var auditLogEnabledStates = ["Unknown", "Other", "Enabled", "Disabled", "Shutting Down", "Not Applicable", "Enabled but Offline", "In Test", "Deferred", "Quiesce", "Starting"];

        function processAuditLog0(stack, name, responses, status) {
            if (errcheck(status, 6)) return;

            var auditstate = ((responses[0]["AuditState"] & 0x01) != 0) ? 'Disabled' : 'Enabled';
            if ((responses[0]["AuditState"] & 0x02) != 0) auditstate += ", Locked";
            if ((responses[0]["AuditState"] & 0x04) != 0) auditstate += ", Almost Full";
            if ((responses[0]["AuditState"] & 0x08) != 0) auditstate += ", Full";
            if ((responses[0]["AuditState"] & 0x10) != 0) auditstate += ", NoKey";

            var x = TableStart();
            //x += TableEntry("Enabled state", auditLogEnabledStates[responses[0]["EnabledState"]]);
            x += TableEntry("State", auditstate);
            x += TableEntry("Storage", responses[0]["CurrentNumberOfRecords"] + " record(s), " + responses[0]["PercentageFree"] + "% free");
            x += TableEntry("Overwrite policy", ((responses[0]["OverwritePolicy"] == 2) ? "Wraps when full" : "Never overwrites"));
            //x += TableEntry("Number of records", responses[0]["CurrentNumberOfRecords"]);
            x += TableEnd(AddButton("Refresh", "PullAuditLog()") /* + "&nbsp;" + AddButton("Settings...", "ShowAuditLogSettings()")*/);
            QH('TableAuditLog', x);
        }

        function processAuditLog1(stack, messages) {
            auditLog = messages;
            var i, x = "<table class=log1 cellpadding=0 cellspacing=0 style='width:100%;border-radius:8px'>";
            //x += TableEnd("<div style='float:right'></div>&nbsp;" + AddButton("Refresh", "PullAuditLog()") /*+ "&nbsp;" + AddButton("Clear Log", "ClearAuditLog()")*/) + "<br />";
            if (messages.length == 0) {
                x = "No audit log events found.";
            } else {
                var y = 0;
                x += "<table class=log1 cellpadding=0 cellspacing=0 style='width:100%;border-radius:8px'><tr><td width='80px'><p></p></td><td></td><td></td><td></td></tr>";
                x += "<tr><td class=r1 style='width:110px'>&nbsp;&nbsp;<b>Time</b></td><td class=r1 style='width:260px'><b>Initiator</b></td><td class=r1><b>Action</b></td></tr>";
                for (i in messages) {
                    var m = messages[i];
                    y++;
                    var addr = '';
                    if (m.NetAddress.length > 0) addr = ", " + m.NetAddress.replace('0000:0000:0000:0000:0000:0000:0000:0001','::1');
                    x += "<tr id='xamtevent" + i + "' class=r3 onclick='showAuditDetails(" + i + ")'><td class=r1>&nbsp;&nbsp;" + m.TimeStamp.toLocaleDateString() + "<br />&nbsp;&nbsp;" + m.TimeStamp.toLocaleTimeString() + "</td><td class=r1>" + m.Initiator + addr + "</td><td class=r1>" + m.AuditApp + ", " + m.Event + "</td></tr>";
                }
                x += TableEnd(y == 0 ? "&nbsp;" : "");
            }
            QH('TableAuditLog2', x);
        }

        function ClearAuditLog(x) { QH('dialogMessage', 'Clear audit log?'); setDialogMode(1, "Audit Log", 3, ClearAuditLogEx); }
        function ClearAuditLogEx() { amtstack.AMT_AuditLog_ClearLog(function () { PullAuditLog(); }) }

        function ShowAuditLogSettings() {
            amtstack.AMT_AuditLog_RequestStateChange(2, 0, AuditLogSettingsCompleted); // Enable
        }

        function AuditLogSettingsCompleted(stack, name, responses, status) {
            if (status == 200) PullAuditLog(); else messagebox("Audit Log", "Error: " + status);
        }

        function showAuditDetails(h) {
            if (xxdialogMode != 0) return;
            var i, m = auditLog[h];
            var x = '<div style="text-align:left">';
            x += addHtmlValue("Time", m.TimeStamp.toLocaleString());
            x += addHtmlValue("Initiator", m.Initiator);
            if (m.NetAddress != '') x += addHtmlValue("Address", m.NetAddress);
            x += addHtmlValue("Application", m.AuditApp);
            x += addHtmlValue("Event", m.Event);
            if (m.ExtendedDataLength > 0) {
                var e = '';
                for (i in m.ExtendedData) { if (e.length > 0) e += ','; e += m.ExtendedData.charCodeAt(i); }
                x += addHtmlValue("Data Values", e);
                x += addHtmlValue("Data String", m.ExtendedData);
            }
            x += "</div>";
            QH('dialogMessage', x);
            setDialogMode(1, "Audit Event #" + (h + 1) + " Details", 1);
        }





        //
        // Certificates
        //

        var xxCertificates = null;
        function PullCertificates() {
            if (xxCertificates == null) QH('TableCerts', '<div style="text-align:center;padding-top:20px">Loading...<div>');
            amtstack.Enum("AMT_PublicKeyCertificate", processCerts1);
        }

        function processCerts1(stack, name, responses, status) {
            if (errcheck(status, 6)) return;
            xxCertificates = responses;
            for (var i in xxCertificates) {
                xxCertificates[i].TrustedRootCertficate = (xxCertificates[i]["TrustedRootCertficate"] == 'true');
                xxCertificates[i].X509Certificate = window.atob(xxCertificates[i]["X509Certificate"]);
                xxCertificates[i].XIssuer = parseCertName(xxCertificates[i]["Issuer"]);
                xxCertificates[i].XSubject = parseCertName(xxCertificates[i]["Subject"]);
            }
            updateCertificates();
        }

        function parseCertName(x) {
            var j, r = {}, xx = x.split(',');
            for (var i in xx) { j = xx[i].indexOf('='); r[xx[i].substring(0, j)] = xx[i].substring(j + 1); }
            return r;
        }

        function updateCertificates() {
            if (xxCertificates == null) return;
            var a = '', b = '', x = TableStart2();
            if (xxCertificates.length == 0) {
                x += "<tr><td class=r2 style='padding-left:15px'><br />No certificates found.<br />";
            } else {
                for (var i in xxCertificates) {
                    var e = "<div class='itemBar' onclick='showCertDetails(" + i + ")'><div style='float:right'>" + /*AddButton2("Remove", "removeCertButton(" + i + ")") +*/ "&nbsp;</div><div style='padding-top:3px'><b>" + xxCertificates[i].XSubject["CN"] + "</b></div></div>";
                    if (xxCertificates[i].TrustedRootCertficate) {
                        if (a == '') a += "<tr><td class=r2 style='padding-left:15px'><br />Trusted Root Certificates<br /><br />";
                        a += e;
                    } else {
                        if (b == '') b += "<tr><td class=r2 style='padding-left:15px'><br />Certificates<br /><br />";
                        b += e;
                    }
                }
                x += a + b;
            }
            x += "<br /></td><td class=r2></td></tr>" + TableEnd(/*AddButton("Add Certificate...", "addCertButton()") + AddButton("Add Root Certificate...", "addRootCertButton()") +*/ AddButton("Refresh", "PullCertificates()"));
            QH('TableCerts', x);
        }

        function showCertDetails(h) {
            if (xxdialogMode != 0) return;
            var c = xxCertificates[h], x = '<div style="text-align:left">';
            x += addHtmlValue("Size", c.X509Certificate.length + " bytes");
            x += addHtmlValue("Trusted", c.TrustedRootCertficate);
            x += '<br />';
            for (var i in c.XSubject) { x += addHtmlValue("Subject " + i, c.XSubject[i]); }
            x += '<br />';
            for (var i in c.XIssuer) { x += addHtmlValue("Issuer " + i, c.XIssuer[i]); }
            x += "</div>";
            QH('dialogMessage', x);
            setDialogMode(1, "Certificate - " + c.XSubject["CN"], 1);
        }

        function removeCertButton(h) {
            if (xxdialogMode != 0) return;
            // TODO
        }

        function addCertButton() {
            if (xxdialogMode != 0) return;
            // TODO
        }

        function addRootCertButton() {
            if (xxdialogMode != 0) return;
            // TODO
        }





        //
        // WIRELESS SETTINGS PANEL
        //

        var xxWireless = null;
        function PullWireless() {
            QH('TableWifi1', '<div style="text-align:center;padding-top:20px">Loading...<div>');
            QH('TableWifi2', '');
            amtFirstPull |= 2;
            amtstack.BatchEnum("", ["*CIM_WiFiPortCapabilities", "*CIM_WiFiPort", "*CIM_WiFiEndpoint", "CIM_WiFiEndpointSettings"], processWireless);
        }

        function wifiRefresh() { if (xxdialogMode == 0) PullWireless(); }

        var xxWifiTypeMap = { 70: 'a', 71: 'b', 72: 'g', 73: 'n' };
        var xxWifiState = { 3: 'Disabled', 32768: 'Enabled in S0', 32769: 'Enabled in S0, Sx/AC' };
        var xxRadioState = 	{ 2: 'On, Connected', 3: 'Off', 6: 'On, Disconnected' };
        var xxWifiAuthenticationMethod= { 1: 'Other', 2: 'Open', 3: 'Shared Key', 4: 'WPA PSK', 5: 'WPA IEEE 802.1x', 6: 'WPA2 PSK', 7: 'WPA2 IEEE 802.1x' };
        var xxWifiEncryptionMethod = { 1: 'Other', 2: 'WEP', 3: 'TKIP-RC4', 4: 'CCMP-AES', 5: 'None' }; // For 2 & 5, AuthenticationMethod must be 2 or 3. For 3 & 4 AuthenticationMethod must be 4,5,6 or 7

        function processWireless(stack, name, responses, status) {
            if (errcheck(status)) return;
            xxWireless = responses;
            showWirelessInfo();
        }

        function showWirelessInfo() {
            var i, j, s = "", sc, x = "<h1>Wireless Settings</h1>";
            if (!(xxWireless['CIM_WiFiPortCapabilities'].response)) return;

            // Start and state
            x += TableStart();
            x += TableEntry("State", addLink(xxWifiState[xxWireless['CIM_WiFiPort'].response["EnabledState"]], 'showWifiStateDlg()'));

            // Capabilities
            sc = xxWireless['CIM_WiFiPortCapabilities'].response;
            for (i in sc["SupportedPortTypes"]) { s += ", 802.11" + xxWifiTypeMap[sc["SupportedPortTypes"][i]]; }
            x += TableEntry("Capabilites", s.substring(2));

            // Current radio state
            x += TableEntry("Radio State", xxRadioState[xxWireless['CIM_WiFiEndpoint'].response['EnabledState']]);
            s = xxWireless['CIM_WiFiEndpoint'].response['LANID'];
            x += TableEntry("Radio SSID", s?s:"<i>None</i>");

            // End of table
            x += TableEnd(AddButton("Refresh", "wifiRefresh()"));
            QH('TableWifi1', x);

            // Show WIFI profiles sorted by priority
            x = "<br />" + TableStart2();
            x += "<tr><td class=r1 style='padding-left:15px'><br />Wireless profiles that Intel&reg; AMT will use for network connectivity.<br /><br />";
            s = 0;
            for(i = 0; i < 256; i++) {
                for (j in xxWireless['CIM_WiFiEndpointSettings'].responses) {
                    sc = xxWireless['CIM_WiFiEndpointSettings'].responses[j];
                    if (sc['Priority'] == i) {
                        x += "<div class='itemBar' onclick='showWifiDetails(" + j + ")'><div style='float:right'>" + sc['SSID'] + ", " + xxWifiAuthenticationMethod[sc['AuthenticationMethod']] + ", " + xxWifiEncryptionMethod[sc['EncryptionMethod']] + " &nbsp; " + AddButton2("Remove", "wifiRemoveButton(\"" + j + "\")") + "</div><div style='padding-top:3px'><b>" + sc['ElementName'] + "</b></div></div>";
                        s++;
                    }
                }
            }
            if (s == 0) x += '<i>No Wireless Profiles Present</i><br />';

            // End of table
            x += "<br /></td><td class=r1></td></tr>" + TableEnd(AddButton("New Profile", "showWifiNewProfile()"));
            QH('TableWifi2', x);
        }
        
        function showWifiStateDlg() {
            if (xxdialogMode != 0) return;
            var s = "";
            for (var i in xxWifiState) { s += '<input type="radio" name="d11" id="wl' + i + '" value="' + i + '" ' + ((xxWireless['CIM_WiFiPort'].response["EnabledState"] == i)?"checked":"") + ' />' + xxWifiState[i] + '<br />'; }
            QH('dialogOptions', s);
            setDialogMode(11, 'Wireless State', 3, wifiStateDlg)
        }

        function wifiStateDlg() { amtstack.CIM_WiFiPort_RequestStateChange( document.querySelector('input[name="d11"]:checked').value, null, function() { amtstack.Get("CIM_WiFiPort", function(stack, name, response, status) { if (status == 200) { xxWireless['CIM_WiFiPort'].response = response.Body; showWirelessInfo(); } } ); } ); }

        function showWifiDetails(h) {
            if (xxdialogMode != 0) return;
            var i, sc = xxWireless['CIM_WiFiEndpointSettings'].responses[h], x = '<div style="text-align:left">';
            x += addHtmlValue("Profile Name", sc['ElementName']);
            x += addHtmlValue("SSID", sc['SSID']);
            x += addHtmlValue("Authentication", xxWifiAuthenticationMethod[sc['AuthenticationMethod']]);
            x += addHtmlValue("Encryption", xxWifiEncryptionMethod[sc['EncryptionMethod']]);
            x += addHtmlValue("Priority", sc['Priority']);
            x += "</div>";
            QH('dialogMessage', x);
            setDialogMode(1, "Wireless Profile", 1);
        }

        function wifiRemoveButton(h) {
            if (xxdialogMode != 0) return;
            var sc = xxWireless['CIM_WiFiEndpointSettings'].responses[h];
            QH('dialogMessage', 'Remove wireless profile \"' + sc["ElementName"] + '\"?');
            setDialogMode(1, "Wireless Profile", 3, function () { removeWifiButtonEx(h) });
        }

        function removeWifiButtonEx(h) {
            var sc = xxWireless['CIM_WiFiEndpointSettings'].responses[h];
            amtstack.Delete('CIM_WiFiEndpointSettings', {InstanceID: sc['InstanceID']}, removeWifiEntryResponse, 0, 1);
        }

        function removeWifiEntryResponse(stack, name, response, status, tag) {
            if (methodcheck(response)) return;
            amtstack.Enum("CIM_WiFiEndpointSettings", function(stack, name, responses, status) { if (status == 200) { xxWireless['CIM_WiFiEndpointSettings'].responses = responses; showWirelessInfo(); } } );
        }

        function showWifiNewProfile() {
            if (xxdialogMode != 0) return;
            var x = '', t;

            for(i = 1; i < 256; i++) {
                t = false;
                for (j in xxWireless['CIM_WiFiEndpointSettings'].responses) { if (xxWireless['CIM_WiFiEndpointSettings'].responses[j]['Priority'] == i) { t = true; break; } }
                if (t == false) { x += '<option value="'+ i +'">'+ i +'</option>'; }
            }
            QH('d12pri', x);

            setDialogMode(12, "Add Wireless Profile", 3, function () { addWifiProfile() });
            updateWifiDialog();
        }

        function addWifiProfile() {
            amtstack.AMT_WiFiPortConfigurationService_AddWiFiSettings(
				{
				    '__parameterType': 'reference',
				    '__resourceUri': amtstack.CompleteName('CIM_WiFiEndpoint'),
				    'Name': 'WiFi Endpoint 0'
				},
                {
				    '__parameterType': 'instance',
				    '__namespace': amtstack.CompleteName('CIM_WiFiEndpointSettings'),
				    'ElementName': Q('d12name').value,
				    'InstanceID': 'Intel(r) AMT:WiFi Endpoint Settings ' + Q('d12name').value,
				    'AuthenticationMethod': Q('d12auth').value,
				    'EncryptionMethod': Q('d12enc').value,
				    'SSID': Q('d12ssid').value,
				    'Priority': Q('d12pri').value,
				    'PSKPassPhrase': Q('d12password1').value
				},
				null, null, null, removeWifiEntryResponse
			);
        }

        function updateWifiDialog() {
            var r = true;
            var a = Q('d12auth').value;
            var e = Q('d12enc').value;
            QV('d12e2', a < 4);
            QV('d12e3', a > 3);
            QV('d12e4', a > 3);
            QV('d12e5', a < 4);
            if (a < 4 && (e == 3 || e == 4)) { Q('d12enc').value = 2; }
            if (a > 3 && (e == 2 || e == 5)) { Q('d12enc').value = 3; }

            // Check if there is already a profile with this name
            for (var j in xxWireless['CIM_WiFiEndpointSettings'].responses) { if (xxWireless['CIM_WiFiEndpointSettings'].responses[j]['ElementName'] == Q('d12name').value) { r = false; } }

            QE('dlgOkButton', r == true && Q('d12name').value.length > 0 && Q('d12ssid').value.length > 0 && Q('d12password1').value.length > 0 && Q('d12password1').value == Q('d12password2').value);
        }



        //
        // HARDWARE INFORMATION PANEL
        //

        function PullHardware() {
            amtstack.BatchEnum("", ["CIM_SystemPackaging", "CIM_Card", "*CIM_BIOSElement", "CIM_Processor", "CIM_PhysicalMemory", "CIM_MediaAccessDevice"], processHardware);
            amtFirstPull |= 1; // Set the hardware info bit on, indicates we are pulling this information.
        }

        var DMTFCPUStatus = ["Unknown", "Enabled", "Disabled by User", "Disabled By BIOS (POST Error)", "Idle", "Other"];
        var DMTFMemType = ["Unknown", "Other", "DRAM", "Synchronous DRAM", "Cache DRAM", "EDO", "EDRAM", "VRAM", "SRAM", "RAM", "ROM", "Flash", "EEPROM", "FEPROM", "EPROM", "CDRAM", "3DRAM", "SDRAM", "SGRAM", "RDRAM", "DDR", "DDR-2", "BRAM", "FB-DIMM", "DDR3", "FBD2", "DDR4", "LPDDR", "LPDDR2", "LPDDR3", "LPDDR4"];
        function processHardware(stack, name, responses, status) {
            if (errcheck(status)) return;
            var i, x = "<h2>Platform</h2>";
            x += TableStart();
            x += TableEntry("System ID", guidToStr(responses['CIM_SystemPackaging'].responses[0]["PlatformGUID"]));
            x += TableEnd("");
            x += "<h2>Baseboard</h2>";
            var bb = responses['CIM_Card'].responses[0];
            x += TableStart();
            x += TableEntry("Manufacturer", bb["Manufacturer"]);
            x += TableEntry("Product name", bb["Model"]);
            x += TableEntry("Version", bb["Version"]);
            x += TableEntry("Serial number", bb["SerialNumber"]);
            x += TableEntry("Asset tag", bb["Tag"]);
            x += TableEnd("");
            x += "<h2>BIOS</h2>";
            x += TableStart();
            var v = responses['CIM_BIOSElement'].response["SoftwareElementID"];
            x += TableEntry("Vendor", responses['CIM_BIOSElement'].response["Manufacturer"]);
            x += TableEntry("Version", v);
            x += TableEntry("Release date", v.substring(23,25) + "/" + v.substring(25,27) + "/" + v.substring(18,22));
            x += TableEnd("");
            QH('TableSysInfo', x);

            x = "";
            for (i in responses['CIM_Processor'].responses) {
                var p = responses['CIM_Processor'].responses[i];
                x += "<h2>Processor " + (parseInt(i) + 1) + "</h2>";
                x += TableStart();
                x += TableEntry("Maximum socket speed", p["MaxClockSpeed"]);
                x += TableEntry("Speed", p["CurrentClockSpeed"]);
                x += TableEntry("Status", DMTFCPUStatus[p["CPUStatus"]]);
                x += TableEnd("");
            }
            QH('TableProcInfo', x);

            x = "";
            for (i in responses['CIM_PhysicalMemory'].responses) {
                var m = responses['CIM_PhysicalMemory'].responses[i];
                x += "<h2>Module " + (parseInt(i) + 1) + "</h2>";
                x += TableStart();
                x += TableEntry("Manufacturer", m["Manufacturer"]);
                x += TableEntry("Serial Number", m["SerialNumber"]);
                x += TableEntry("Size", parseInt(m["Capacity"] / 1024) + " MB");
                x += TableEntry("Type", DMTFMemType[m["MemoryType"]]);
                x += TableEntry("Part number", m["PartNumber"]);
                x += TableEnd("");
            }
            QH('TableMemInfo', x);

            x = "";
            for (i in responses['CIM_MediaAccessDevice'].responses) {
                var m = responses['CIM_MediaAccessDevice'].responses[i];
                x += "<h2>Disk " + (parseInt(i) + 1) + "</h2>";
                x += TableStart();
                x += TableEntry("Model", "Unknown"); // TODO
                x += TableEntry("Serial number", "Unknown"); // TODO
                x += TableEntry("Size", parseInt(m["MaxMediaSize"] / 1024) + " MB");
                x += TableEnd("");
            }
            QH('TableDiskInfo', x);
        }


        //
        // NETWORK INFORMATION PANEL
        //

        function PullNetInfo() {
            QH('TableIPSettingsSpan', LoadingHtml);
            QV('TableIPSettings', false);
            QH('TableIPv6SettingsSpan', LoadingHtml);
            QV('TableIPv6Settings', false);
            amtstack.BatchEnum("", ["AMT_GeneralSettings"], processNetInfo);
        }

        function processNetInfo(stack, name, responses, status) {
            if (errcheck(status)) return;
            QH('TableIPSettingsSpan', '');
            QV('TableIPSettings', true);
            QH('TableIPv6SettingsSpan', '');
            QV('TableIPv6Settings', true);
        }


        //
        // POWER POLICY PANEL
        //

        function PullPowerPolicy() {
            QH('TablePowerPolicies', '<div style="text-align:center;padding-top:20px">Loading...<div>');
            amtstack.BatchEnum("Power", ["AMT_SystemPowerScheme"], powerPolicyResponse);
        }

        function powerPolicyResponse(stack, name, responses, status) {
            if (errcheck(status)) return;
            var x = TableStart2();
            x += "<tr><td class=r1 style='padding-left:15px'><br />Select a power policy for the managed device:<br /><br />";
            for (var i in responses['AMT_SystemPowerScheme'].responses) {
                var r = responses['AMT_SystemPowerScheme'].responses[i];
                x += "<input type='radio' name='powerpackage' value='" + r.SchemeGUID + "' style='margin:5px'>" + r.Description + "<br />";
            }
            x += "<br /></td><td class=r1></td></tr>" + TableEnd(AddButton("Submit", "SubmitNewPowerPolicy()"));
            QH('TablePowerPolicies', x);
        }

        //
        // USER INFORMATION PANEL
        //

        var xxAccountAdminName, xxAccountRealmInfo, xxAccountFetch;

        function PullUserInfo() {
            if (xxAccountFetch == 999) QH('TableUserAccounts', '<div style="text-align:center;padding-top:20px">Loading...<div>');
            xxAccountFetch = 1;
            xxAccountRealmInfo = {};
            amtstack.AMT_AuthorizationService_GetAdminAclEntry(getAdminAclEntryResponse);
            amtstack.AMT_AuthorizationService_EnumerateUserAclEntries(1, enumerateUserAclEntriesResponse);
        }

        function getAdminAclEntryResponse(stack, name, response, status) {
            if (errcheck(status, 11)) return;
            methodcheck(response);
            xxAccountRealmInfo[-1] = { "AccessPermission": 999, "DigestUsername": response.Body["Username"], "Realms":null };
            xxAccountAdminName = response.Body["Username"];
            xxAccountFetch++;
            updateAccounts();
        }

        function enumerateUserAclEntriesResponse(stack, name, response, status) {
            if (errcheck(status)) return;
            methodcheck(response);
            xxAccountFetch = response.Body["Handles"].length;
            for (var i in response.Body["Handles"]) { amtstack.AMT_AuthorizationService_GetUserAclEntryEx(response.Body["Handles"][i], getUserAclEntryExResponse, response.Body["Handles"][i]); }
        }

        function getUserAclEntryExResponse(stack, name, response, status, tag) {
            if (errcheck(status)) return;
            methodcheck(response);
            response.Body["Handle"] = tag;
            if (typeof response.Body["Realms"] == 'undefined') response.Body["Realms"] = [];
            else if (!Array.isArray(response.Body["Realms"])) response.Body["Realms"] = [response.Body["Realms"]]; // If "Realms" is not an array, it's because it's just one realm. Fix is so it's an array of one.
            xxAccountRealmInfo[tag] = response.Body;
            xxAccountFetch--;
            updateAccounts();
        }

        function updateAccounts() {
            if (xxAccountAdminName != null && xxAccountFetch == 0) {
                var x = TableStart2();
                x += "<tr><td class=r1 style='padding-left:15px'><br />Manage the managed device user accounts for this computer.<br /><br />";
                for (var i in xxAccountRealmInfo) {
                    var r = xxAccountRealmInfo[i];
                    if (r["DigestUsername"][0] != '$' || r["DigestUsername"][1] != '$') {
                        var rb = "";
                        if (r["AccessPermission"] != 999) {
                            var rc = r["Realms"].length;
                            if (r["Realms"].indexOf('20') >= 0) rb += "Auditor, ";
                            if (rc == 1) rb += "1 realm"; else rb += rc + " realms";
                            rb += " &nbsp; " + AddButton2("Remove", "removeAccountButton(\"" + r["Handle"] + "\")");
                        } else {
                            rb += "Administrator";
                            r["Handle"] = -1;
                        }
                        x += "<div class='itemBar' onclick='showUserDetails(" + r["Handle"] + ")'><div style='float:right'>" + rb + " &nbsp; " + AddButton2("Change", "changeAccountButton(\"" + r["Handle"] + "\")") + "</div><div style='padding-top:3px'><b>" + r["DigestUsername"] + "</b></div></div>";
                    }
                }
                x += "<br /></td><td class=r1></td></tr>" + TableEnd(AddButton("New Account", "newAccountButton()") + AddButton("Refresh", "xxAccountFetch=999;PullUserInfo()"));
                QH('TableUserAccounts', x);
            }
        }

        function removeAccountButton(h) {
            if (xxdialogMode != 0) return;
            QH('dialogMessage', 'Remove user account \"' + xxAccountRealmInfo[h]["DigestUsername"] + '\"?');
            setDialogMode(1, "Remove Account", 3, function () { removeAccountButtonEx(h) });
        }

        function removeAccountButtonEx(h) {
            amtstack.AMT_AuthorizationService_RemoveUserAclEntry(h, removeUserAclEntryResponse);
        }

        function removeUserAclEntryResponse(stack, name, response, status, tag) {
            if (methodcheck(response)) return;
            PullUserInfo();
        }

        function changeAccountButton(h) {
            if (xxdialogMode != 0) return;
            updateRealms(xxAccountRealmInfo[h]["Realms"]);
            Q('d2username').value = xxAccountRealmInfo[h]["DigestUsername"];
            Q('d2password1').value = Q('d2password2').value = '';
            Q('d2permission').value = xxAccountRealmInfo[h]["AccessPermission"];
            setDialogMode(2, "Change Account", 3, function () { changeAccountButtonEx(h); });
            updateAccountDialog();
        }

        function newAccountButton() {
            if (xxdialogMode != 0) return;
            updateRealms([]);
            Q('d2username').value = Q('d2password1').value = Q('d2password2').value = '';
            Q('d2permission').value = 2;
            setDialogMode(2, "New Account", 3, function () { changeAccountButtonEx(null); });
            updateAccountDialog();
        }

        function changeAccountButtonEx(h) {
            var realms = [], username = Q('d2username').value, permission = Q('d2permission').value, password = Q('d2password1').value;
            if (username.length == 0 || password != Q('d2password2').value) { messagebox("Account Error", "Invalid Parameters"); return; }
            var d = window.btoa(rstr_md5(username + ":" + amtsysstate['AMT_GeneralSettings'].response["DigestRealm"] + ":" + password));
            if (h != -1) { for (var y in amtstack.xxRealmNames) { if (!amtstack.xxRealmNames[y].startsWith('*') && Q('rx' + y).checked) { realms.push(y); } } }
            if (h == null) { amtstack.AMT_AuthorizationService_AddUserAclEntryEx(username, d, null, permission, realms, userAclEntryExResponse); }
            if (h == -1) { amtstack.AMT_AuthorizationService_SetAdminAclEntryEx(username, d, userAclEntryExResponse); }
            else { amtstack.AMT_AuthorizationService_UpdateUserAclEntryEx(h, username, d, null, permission, realms, userAclEntryExResponse); }
        }

        function userAclEntryExResponse(stack, name, response, status, tag) { if (methodcheck(response)) return; PullUserInfo(); }
        function updateRealms(r) { QV('d2permissions', r != null); if (r != null) { var x = ''; for (var y in amtstack.xxRealmNames) { var c = ''; if (r.indexOf(y) >= 0) c = ' checked'; if (!amtstack.xxRealmNames[y].startsWith('*')) x += '<li><label><input type="checkbox" id="rx' + y + '"' + c + ' />' + amtstack.xxRealmNames[y] + '</label></li>'; } QH('d2realms', x); } }

        function updateAccountDialog() {
            QE('dlgOkButton', Q('d2username').value.length > 0 && passwordcheck(Q('d2password1').value) && Q('d2password1').value == Q('d2password2').value);
        }

        var xxUserPermissions = [ 'Local only' , 'Network only', 'All (Local & Network)'];
        function showUserDetails(h) {
            if (xxdialogMode != 0) return;
            var a = xxAccountRealmInfo[h], x = '<div style="text-align:left">';
            var i, n = a["DigestUsername"];
            x += addHtmlValue("Name", n);
            if (n == xxAccountAdminName) {
                x += addHtmlValue("Permission", "Administrator");
            } else {
                x += addHtmlValue("Permission", xxUserPermissions[a["AccessPermission"]]);
                var y = '';
                for (i in xxAccountRealmInfo[h]["Realms"]) {
                    if (y.length > 0) y += ", ";
                    y += amtstack.xxRealmNames[a["Realms"][i]];
                }
                if (y.length == 0) y = 'None';
                x += addHtmlValue("Realms", "") + "<b>" + y + "</b>";
            }
            x += "</div>";
            QH('dialogMessage', x);
            setDialogMode(1, "Account " + n, 1);
        }

        //
        // WSMAN BROWSER PANEL
        //

        
        function wsmanQuery() {
            QH("wsresults", "");
            var selections = getSelectedOptions(Q("QuerySelect")), selections2 = [];
            for (var x in selections) { if (QS('WSB-' + selections[x]).display == '') selections2.push(selections[x]); }
            if (selections2.length == 0) return;
            QE("p12querybutton", false);
            if (selections2 && selections2.length > 0) { amtstack.BatchEnum("Browser", selections2, browserResponse, false); }
        }

        function browserResponse(stack, name, responses, status) {
            QE("p12querybutton", true);
            var h = "";
            for (var r in responses) {
                var response = responses[r];
                h += "<h2>" + r + "</h2><div style='margin-left:20px'>";
                if (response.status == 200) { if (response.responses.length == 0) { h += "<br />(Empty)"; } else { h += wsstack.ObjectToString(response.responses).replace(/Intel\(r\)/g, 'Intel&reg'); } } else { h += "<br /><div style='color:red'>Error #" + response.status + "</div>"; }
                h += "</div><br />";
            }
            QH("wsresults", h);
        }

        function wsmanFilter() {
            var filter = Q('browserFilter').value.toLowerCase();
            for (var w in AllWsman) { QV('WSB-' + AllWsman[w], filter == '' || AllWsman[w].toLowerCase().indexOf(filter) >= 0); }
        }
        

        
        function connectTerminal(e) {
            if (terminal == null) return;
            if (terminal.State == 0) {
                
                
                terminal.Start(currentcomputer["host"], (currentcomputer["tls"] == 0) ? 16994 : 16995, currentcomputer["user"], currentcomputer["pass"], currentcomputer["tls"]);
                
                
            } else {
                terminal.Stop();
            }
        }

        function onTerminalStateChange(terminal, state) {
            // console.log("onTerminalStateChange: " + state);
            Q('connectbutton2').value = (state == 0) ? 'Connect' : 'Disconnect';
            Q('termstatus').textContent = StatusStrs[state];
            QE('tpastebutton', state == 3);
            switch (state) {
                case 0:
                    terminal.m.TermResetScreen();
                    terminal.m.TermDraw();
                    if (xxdialogMode == 3) setDialogMode(0);
                    break;
                case 2:
                    break;
            }
        }

        function termPaste() { terminal.m.TermSendKeys(Q('d3pastetextarea').value) }
        function termSendKey(k) { terminal.m.TermSendKey(k) }

        

        
        function connectDesktop(e) {
            if (desktop == null) return;
            if (desktop.State == 0) {
                desktop.m.bpp = (desktopsettings.encoding == 1 || desktopsettings.encoding == 3) ? 1 : 2;
                desktop.m.useZRLE = (desktopsettings.encoding < 3);
                desktop.m.showmouse = desktopsettings.showmouse;
                
                
                desktop.Start(currentcomputer["host"], (currentcomputer["tls"] == 0) ? 16994 : 16995, currentcomputer["user"], currentcomputer["pass"], currentcomputer["tls"]);
                
                
            } else {
                desktop.Stop();
            }
        }

        function onDesktopStateChange(desktop, state) {
            //console.log("onDesktopStateChange: " + state);
            Q('connectbutton1').value = (state == 0) ? 'Connect' : 'Disconnect';
            Q('deskstatus').textContent = StatusStrs[state];
            switch (state) {
                case 0:
                    // desktop.m.ResetScreen();
                    break;
                case 2:
                    break;
            }
        }

        function showDesktopSettings() {
            setDialogMode(7, "Remote Desktop Settings", 3, showDesktopSettingsChanged);
        }

        function showDesktopSettingsChanged() {
            desktopsettings.encoding = Q('d7desktopmode').value;
            desktopsettings.showfocus = Q('d7showfocus').checked;
            desktopsettings.showmouse = Q('d7showcursor').checked;
            desktopsettings.showcad = Q('d7showcad').checked;
            localStorage.setItem('desktopsettings', JSON.stringify(desktopsettings));
            applyDesktopSettings();
            if (desktopsettings.showfocus == false) { desktop.m.focusmode = 0; Q('deskFocusBtn').value = 'All Focus'; }
            if (desktop.State != 0) { desktop.Stop(); setTimeout(connectDesktop, 50); }
        }

        function applyDesktopSettings() {
            Q('d7desktopmode').value = desktopsettings.encoding;
            Q('d7showfocus').checked = desktopsettings.showfocus;
            Q('d7showcursor').checked = desktopsettings.showmouse;
            Q('d7showcad').checked = desktopsettings.showcad;
            QV('deskFocusBtn', desktopsettings.showfocus);
            QV('DeskCAD', desktopsettings.showcad);
        }

        var fullscreen = false;
        function deskToggleFull() {
            fullscreen = !fullscreen;
            
            QV('topheader', !fullscreen);
            
            QV('leftbar', !fullscreen);
            QV('rdheader', !fullscreen);
            if (fullscreen) {
                
                QS('mainarea').top = 0;
                
                QS('mainarea').left = 0;
                QS('mainarea').padding = 0;
                Q('deskFullBtn').value = 'Normal';
            } else {
                
                QS('mainarea').top = '69px';
                
                QS('mainarea').left = '156px';
                QS('mainarea').padding = '8px';
                Q('deskFullBtn').value = 'Full';
            }
        }

        
        function deskToggleFocus() {
            var t = ['All Focus', 'Small Focus', 'Large Focus'];
            desktop.m.focusmode = (desktop.m.focusmode + 64) % 192;
            Q('deskFocusBtn').value = t[desktop.m.focusmode / 64];
        }
        

        // Send CTRL-ALT-DEL
        function sendCAD() { desktop.m.sendcad(); }

        // Send special keys
        //function sendSpecialKey() { var k = Q('specialkeylist').value; desktop.m.sendkey(k, 1); desktop.m.sendkey(k, 0); }

        function dmousedown(e) { if (xxdialogMode == 0) desktop.m.mousedown(e) }
        function dmouseup(e) { if (xxdialogMode == 0) desktop.m.mouseup(e) }
        function dmousemove(e) { if (xxdialogMode == 0) desktop.m.mousemove(e) }

        function drotate(x) { desktop.m.setRotation(desktop.m.rotation + x) }

        

        //
        // Edit Computer Name
        //

        function showEditNameDlg() {
            if (xxdialogMode != 0) return;
            var t = amtsysstate['AMT_GeneralSettings'].response["HostName"], y = amtsysstate['AMT_GeneralSettings'].response["DomainName"];
            if (y != null && y.length > 0) t += "." + y;
            QH('dialogOptions', '<br /><div style="height:26px"><input id="d11name" type="text" value="' + t + '" style="float:right;width:200px" /><div>Name & Domain</div></div>')
            setDialogMode(11, 'Computer Name', 3, editNameDlgOk)
        }

        function editNameDlgOk() {
            var i = Q('d11name').value, j = i.indexOf('.'), k = '';
            if (j >= 0) { k = i.substring(j + 1); i = i.substring(0, j); }
            amtsysstate['AMT_GeneralSettings'].response["HostName"] = i;
            amtsysstate['AMT_GeneralSettings'].response["DomainName"] = k;
            amtstack.Put('AMT_GeneralSettings', amtsysstate['AMT_GeneralSettings'].response, function() { amtstack.Get('AMT_GeneralSettings', computerNameGet, 0, 1); }, 0, 1);
        }

        function computerNameGet(stack, name, response, status) {
            if (status == 200) { amtsysstate['AMT_GeneralSettings'].response = response.Body; updateSystemStatus(); }
        }

        //
        // Intel AMT Features
        //

        function showFeaturesDlg() {
            if (xxdialogMode != 0) return;
            setDialogMode(9, 'Intel&reg; AMT Features', 3, featuresDlgOk)
        }

        function featuresDlgOk() {
            var r = amtsysstate['AMT_RedirectionService'].response;
            r["ListenerEnabled"] = Q('d9redir').checked;
            r["EnabledState"] = (Q('d9ider').checked?1:0) + (Q('d9sol').checked?2:0);
            amtstack.AMT_RedirectionService_RequestStateChange(32768 + r["EnabledState"],
                function() { amtstack.CIM_KVMRedirectionSAP_RequestStateChange((Q('d9kvm').checked)?2:3, 0,
                    function() {
                        amtstack.Put("AMT_RedirectionService", r, function() { amtstack.Get("AMT_RedirectionService", featuresDlgGet1, 0, 1); amtstack.Get("CIM_KVMRedirectionSAP", featuresDlgGet2, 0, 1) }, 0, 1)
                    }
                );}
            );
        }

        function featuresDlgGet1(stack, name, response, status) {
            if (status == 200) { amtsysstate['AMT_RedirectionService'].response = response.Body; updateSystemStatus(); }
        }

        function featuresDlgGet2(stack, name, response, status) {
            if (status == 200) { amtsysstate['CIM_KVMRedirectionSAP'].response = response.Body; updateSystemStatus(); }
        }

        //
        // Intel AMT User Consent
        //

        function showConsentDlg() {
            if (xxdialogMode != 0) return;
            setDialogMode(10, 'User Consent', 3, consentDlgOk)
        }

        function consentDlgOk() {
            amtsysstate['IPS_OptInService'].response["OptInRequired"] = document.querySelector('input[name="d10"]:checked').value;
            amtstack.Put("IPS_OptInService", amtsysstate['IPS_OptInService'].response, function() { amtstack.Get("IPS_OptInService", consentGet, 0, 1); }, 0, 1);
        }

        function consentGet(stack, name, response, status) {
            if (status == 200) { amtsysstate['IPS_OptInService'].response = response.Body; updateSystemStatus(); }
        }

        //
        // POWER ACTIONS
        //

        function showPowerActionDlg() {
            if (xxdialogMode != 0) return;
            statusbox("Power Actions", "Checking capabilities...");
            amtstack.Get("AMT_BootCapabilities", powerActionResponse00, 0, 1);
        }

        function powerActionResponse00(stack, name, response, status) {
            var r = response.Body;
            QH('d5actionSelect', '');
            addOption('d5actionSelect', 'Power up', '2');
            addOption('d5actionSelect', 'Power cycle', '5');
            addOption('d5actionSelect', 'Power down', '8');
            addOption('d5actionSelect', 'Reset', '10');
            //addOption('d5actionSelect', 'Diagnostic', '11');
            if (amtversion > 9) {
                addOption('d5actionSelect', 'Soft-off', '12');
                addOption('d5actionSelect', 'Sleep', '4');
                addOption('d5actionSelect', 'Hibernate', '7');
            }
            if (r["BIOSSetup"] == "true") {
                addOption('d5actionSelect', 'Power up to BIOS', '100');
                addOption('d5actionSelect', 'Reset to BIOS', '101');
                if (r["SOL"] == "true") {
                    addOption('d5actionSelect', 'Power up to BIOS (SOL)', '102');
                    addOption('d5actionSelect', 'Reset to BIOS (SOL)', '103');
                }
            }
            setDialogMode(5, 'Power Actions', 3, powerActionDlg)
        }

        function powerActionDlg() {
            //if (amtversion == 0) return;
            //if (amtversion > 6) { amtstack.Get("IPS_OptInService", powerActionResponse0); } else { amtstack.Get("AMT_BootSettingData", powerActionResponse1); }
            statusbox("Power Action", "Checking state...");
            var action = Q('d5actionSelect').value;
            if (action <= 10) {
                // Skip user consent
                amtstack.Get("AMT_BootSettingData", powerActionResponse1, 0, 1);
            } else {
                // Attempt user concent
                amtstack.Get("IPS_OptInService", powerActionResponse0, 0, 1);
            }
        }

        function powerActionResponse0(stack, name, response, status) {
            if (errcheck(status)) return; // TODO: If AMT 5 or below, this will error and we need to skip user consent.
            //console.log("powerActionResponse0(" + name + "," + response + "," + status + ")");
            //console.log("Opt-in:", response.Body["OptInRequired"]);
            if (response.Body["OptInRequired"] == 0xFFFFFFFF && response.Body["OptInState"] != 3 && response.Body["OptInState"] != 4) {
                if (response.Body["OptInState"] == 2) amtstack.IPS_OptInService_CancelOptIn(null);
                //console.log("Opt-in Required.", response.Body["OptInRequired"]);
                statusbox("Power Action", "Starting opt-in...");
                amtstack.IPS_OptInService_StartOptIn(powerActionResponseC1, 0, 1);
            } else {
                statusbox("Power Action", "Getting Boot Settings...");
                amtstack.Get("AMT_BootSettingData", powerActionResponse1, 0, 1);
            }
        }

        function powerActionResponseC1(stack, name, response, status) {
            if (errcheck(status)) return;
            //console.log("powerActionResponseC1(" + name + "," + response + "," + status + ")");
            if (response.Body["ReturnValue"] != 0) {
                messagebox("User Consent Error", response.Body.ReturnValueStr.replace(/_/g, ' '));
            } else {
                setDialogMode(6, "User Consent", 3, powerActionSendConsent);
                checkConsentDisplay();
                consentChanged();
            }
        }

        function powerActionCancelConsent() { amtstack.IPS_OptInService_CancelOptIn(null); }

        function powerActionSendConsent() {
            //console.log("IPS_OptInService_SendOptInCode()");
            statusbox("Power Action", "Sending user consent...");
            amtstack.IPS_OptInService_SendOptInCode(Q('d6ConsentText').value, powerActionResponseC2, 0, 1);
        }

        function powerActionResponseC2(stack, name, response, status) {
            if (errcheck(status)) return;
            //console.log("powerActionResponseC2(" + name + "," + response + "," + status + ")");
            if (response.Body["ReturnValue"] != 0) {
                messagebox("User Consent Error", response.Body.ReturnValueStr.replace('_',' '));
            } else {
                statusbox("Power Action", "Checking state...");
                amtstack.Get("AMT_BootSettingData", powerActionResponse1, 0, 1);
            }
        }

        function powerActionResponse1(stack, name, response, status) {
            if (errcheck(status)) return;
            //console.log("powerActionResponse1(" + name + "," + response + "," + status + ")");
            var action = Q('d5actionSelect').value;
            var r = response.Body;
            if (r.BIOSPause) response.Body["BIOSPause"] = "false";
            if (r.BIOSSetup) response.Body["BIOSSetup"] = ((action >= 100 && action <= 103) ? "true" : "false");
            if (r.BootMediaIndex) response.Body["BootMediaIndex"] = 0;
            if (r.ConfigurationDataReset) response.Body["ConfigurationDataReset"] = "false";
            if (r.FirmwareVerbosity) response.Body["FirmwareVerbosity"] = 0;
            if (r.ForcedProgressEvents) response.Body["ForcedProgressEvents"] = "false";
            if (r.IDERBootDevice) response.Body["IDERBootDevice"] = 0;
            if (r.LockKeyboard) response.Body["LockKeyboard"] = "false";
            if (r.LockPowerButton) response.Body["LockPowerButton"] = "false";
            if (r.LockResetButton) response.Body["LockResetButton"] = "false";
            if (r.LockSleepButton) response.Body["LockSleepButton"] = "false";
            if (r.ReflashBIOS) response.Body["ReflashBIOS"] = "false";
            if (r.UseIDER) response.Body["UseIDER"] = "false";
            if (r.UseSOL) response.Body["UseSOL"] = ((action >= 102 && action <= 103) ? "true" : "false");
            if (r.UseSafeMode) response.Body["UseSafeMode"] = "false";
            if (r.UserPasswordBypass) response.Body["UserPasswordBypass"] = "false";
            if (r.SecureErase) response.Body["SecureErase"] = ((action == 104) ? "true" : "false");
            if (action == 104 && typeof (response.Body["SecureErase"]) === 'undefined') { /*console.log("This Intel&reg; AMT does not support Secure Erase");*/ cleanup(); return; }
            //console.log("Setting Boot Settings.");
            statusbox("Power Action", "Setting boot settings...");
            amtstack.Put("AMT_BootSettingData", r, powerActionResponse2, 0, 1);
        }

        function powerActionResponse2(stack, name, response, status) {
            //console.log("powerActionResponse2(" + name + "," + response + "," + status + ")");
            if (errcheck(status)) return;
            //console.log("Setup next boot...");
            statusbox("Power Action", "Setting next boot...");
            amtstack.SetBootConfigRole(1, powerActionResponse3, 0, 1);
        }

        var targetPowerAction = 0;
        function powerActionResponse3(stack, name, response, status) {
            //console.log("powerActionResponse3(" + name + "," + response + "," + status + ")");
            if (errcheck(status)) return;
            //console.log("Performing Power State Change...");
            statusbox("Power Action", "Performing power action...");
            var action = Q('d5actionSelect').value;
            if (action == 100 || action == 102) action = 2;
            if (action == 101 || action == 103) action = 10;
            if (action == 104) action = 10;
            targetPowerAction = action;
            amtstack.RequestPowerStateChange(action, powerActionResponse4, 0, 1);
        }

        function powerActionResponse4(stack, name, response, status) {
            //console.log("powerActionResponse4(" + name + "," + response + "," + status + ")");
            if (status == 200) {
                // Done!
                //console.log("Action Completed.");
                messagebox("Power Action", "Power action completed.");
            }
            //console.log("Power State Error: " + status);
            // Sometimes Intel AMT with not respond and this will timeout. Try to pull the power state
            amtstack.Get("CIM_AssociatedPowerManagementService", powerActionResponse5, 0,1);
        }

        function powerActionResponse5(stack, name, response, status) {
            /*
            console.log("powerActionResponse5(" + name + "," + response + "," + status + ")");
            if (errcheck(status)) return;
            var powerstate = parseInt(response.Body["PowerState"]);
            console.log("powerstate: " + powerstate);
            if (targetPowerAction == powerstate) {
                console.log("Action Completed. ");
            } else {
                console.log("Power State Error: " + status + ", CurrentState=" + powerstate + ", TargetState=" + targetPowerAction);
            }
            */
        }

        function consentChanged() { QE('dlgOkButton', Q('d6ConsentText').value.length == 6); }
        function changeConsentDisplay() { xxchangeConsentDisplay = true; checkConsentDisplay(); }
        function checkConsentDisplay() { /*console.log("Getting display information...");*/ amtstack.Get("IPS_SecIOService", checkConsentDisplayResponse1); }

        var xxchangeConsentDisplay = false;
        function checkConsentDisplayResponse1(stack, name, response, status) {
            // console.log("checkConsentDisplayResponse1(" + name + "," + response + "," + status + ")");
            if (status == 200) {
                if (response.Body["DefaultScreen"]) response.Body["DefaultScreen"] = parseInt(response.Body["DefaultScreen"]);
                if (response.Body["NumberOfScreens"]) response.Body["NumberOfScreens"] = parseInt(response.Body["NumberOfScreens"]);
                if (xxchangeConsentDisplay == true) {
                    xxchangeConsentDisplay = false;
                    // Change consent screen settings
                    response.Body["DefaultScreen"] = Q("d6Display").value;
                    amtstack.Put("IPS_SecIOService", response.Body, checkConsentDisplayResponse1);
                } else {
                    Q("d6Display").value = response.Body["DefaultScreen"];
                    QV("d6ThirdDisplay", response.Body["NumberOfScreens"] > 2);
                }
            } else {
                //console.log("Display Error: " + status);
            }
        }

        //
        // POPUP DIALOG
        //

        // 0 = Hidden, 1 = Generic Message
        var xxdialogMode = 0;
        var xxdialogFunc = null;

        // Display a dialog box
        // Parameters: Dialog Mode (0 = none), Dialog Title, Buttons (1 = OK, 2 = Cancel, 3 = OK & Cancel), Call back function(0 = Cancel, 1 = OK).
        function setDialogMode(x, y, b, f) {
            xxdialogMode = x;
            xxdialogFunc = f;
            QE('dlgOkButton', true);
            QV('dlgOkButton', (b & 1) != 0);
            QV('dlgCancelButton', (b & 2) != 0);
            if (y) QH('dialogtitle', y);
            for (var i = 1; i <= 12; i++) { QV('dialog' + i, i == x); } // Edit this line when more dialogs are added
            QV('dialog', x != 0);
        }

        function dialogclose(x) {
            var f = xxdialogFunc;
            setDialogMode(0);
            if (x != 0 && f != null) { f(x); }
        }

        function center() { QS('dialog').left = ((((getDocWidth() - 400) / 2)) + "px"); }
        function messagebox(t, m) { QH('dialogMessage', m); setDialogMode(1, t, 1); }
        function statusbox(t, m) { QH('dialogMessage', m); setDialogMode(1, t, 0); }

        //
        // GENERIC METHODS
        //

        function errcheck(s, p) {
            if (s == 400 && p) {
                // lock panel number p
                QV('lock' + p, true);
                if (LockedPanels.indexOf(p) < 0) LockedPanels.push(p);
                if (currentView == p) go(1)
            }
            else if (s != 200) {
                if (s != 9) {
                    if (wsstack != null) { wsstack.FailAllError = s };
                    if (amtstack != null) { amtstack.CancelAllQueries(9); }

                    var t = 'Error #' + s;
                    if (s == 401) { t = 'Authentication Error'; }
                    if (s == 408) { t = 'Timeout Error'; }
                    if (s == 601) { t = 'WSMAN Parsing Error'; }
                    QH('messageviewstr', t);
                    go(100);
                }
            }
            return (s != 200);
        }

        function go(x) {
            if (xxdialogMode != 0 || LockedPanels.indexOf(x) >= 0) return;
            
            QV('computerSelector', x == 101);
            
            QV('messageview', x == 100);
            QV('mainview', x < 100);
            for (var i = 0; i < 18; i++) { QV('p' + i, i == x); } currentView = x; // Edit this line when adding a new screen
        }

        function addLink(x, f) { return "<a style='cursor:pointer' onclick='" + f + "'>&diams; " + x + "</a>"; }
        function haltEvent(e) { if (e.preventDefault) e.preventDefault(); if (e.stopPropagation) e.stopPropagation(); return false; }
        function addOption(q, t, i) { var option = document.createElement("option"); option.text = t; option.value = i; Q(q).add(option); }
        function passwordcheck(p) { var re = /(?=.*\d)(?=.*[a-z])(?=.*[A-Z])(?=.*[!@#$%^&*()]).{8,}/; return re.test(p); }
        function methodcheck(r) { if (r && r != null && r.Body && r.Body.ReturnValueStr != "SUCCESS") { messagebox("Call Error", r.Header.Method + ": " + r.Body.ReturnValueStr.replace("_", " ")); return true; } return false; }
        function TableStart() { return "<table class='log1 us' cellpadding=0 cellspacing=0 style='width:100%;border-radius:8px'><tr><td width='200px'><p></p></td><td></td></tr>"; }
        function TableStart2() { return "<table class='log1 us' cellpadding=0 cellspacing=0 style='width:100%;border-radius:8px'><tr><td><p></p></td><td></td></tr>"; }
        function TableEntry(n, v) { return "<tr><td class=r1><p>" + n + "</p></td><td class=r1>" + v + "</td></tr>"; }
        function TableEnd(n) { return "<tr><td colspan=2><p>" + n + "</p></td></tr></table>"; }
        function AddButton(v, f) { return "<input type='button' value='" + v + "' onclick='" + f + "' style='margin: 4px;' />"; }
        function AddButton2(v, f) { return "<input type='button' value='" + v + "' onclick='" + f + "' />"; }
        function MoreStart() { return "<a style='cursor:pointer;color:blue' id='morexxx1' onclick='QV(\"morexxx1\",false);QV(\"morexxx2\",true);'>&#x25BC; More</a><div id='morexxx2' style='display:none'><br /><hr />"; };
        function MoreEnd() { return "<a style='cursor:pointer;color:blue' onclick='QV(\"morexxx2\",false);QV(\"morexxx1\",true);'>&#x25B2; Less</a></div>"; };
        function getSelectedOptions(sel) { var opts = [], opt; for (var i = 0, len = sel.options.length; i < len; i++) { opt = sel.options[i]; if (opt.selected) { opts.push(opt.value); } } return opts; }
        function getInstance(x, y) { for (var i in x) { if (x[i]["InstanceID"] == y) return x[i]; } return null; }
        function guidToStr(g) { return g.substring(6, 8) + g.substring(4, 6) + g.substring(2, 4) + g.substring(0, 2) + "-" + g.substring(10, 12) + g.substring(8, 10) + "-" + g.substring(14, 16) + g.substring(12, 14) + "-" + g.substring(16, 20) + "-" + g.substring(20); }
        function getUrlVars() { var j, hash, vars = [], hashes = window.location.href.slice(window.location.href.indexOf('?') + 1).split('&'); for (var i = 0; i < hashes.length; i++) { j = hashes[i].indexOf('='); if (j > 0) { vars[hashes[i].substring(0, j)] = hashes[i].substring(j + 1, hashes[i].length); } } return vars; }
        function getDocWidth() { if (typeof window.innerWidth != 'undefined') return window.innerWidth; if (typeof document.documentElement != 'undefined' && typeof document.documentElement.clientWidth != 'undefined' && document.documentElement.clientWidth != 0) return document.documentElement.clientWidth; return document.getElementsByTagName('body')[0].clientWidth; }
        function Q(x) { return document.getElementById(x); } // "Q"
        function QS(x) { return Q(x).style; }                // "Q" style
        function QE(x, y) { Q(x).disabled = !y; }            // "Q" enable
        function QV(x, y) { try { QS(x).display = (y ? '' : 'none'); } catch(x) {} } // "Q" visible
        function QA(x, y) { Q(x).innerHTML += y; }           // "Q" append
        function QH(x, y) { Q(x).innerHTML = y; }            // "Q" html

        

// ###BEGIN###{**ClosureAdvancedMode}
        // Google closure advanced mode externs
        window['cleanup'] = cleanup;
        window['disconnect'] = disconnect;
        window['dialogclose'] = dialogclose;
        window['go'] = go;
        window['showPowerActionDlg'] = showPowerActionDlg;
        window['showFeaturesDlg'] = showFeaturesDlg;
        window['showConsentDlg'] = showConsentDlg;
        window['PullSystemStatus'] = PullSystemStatus;
        window['removeAccountButton'] = removeAccountButton;
        window['changeAccountButton'] = changeAccountButton;
        window['newAccountButton'] = newAccountButton;
        window['showUserDetails'] = showUserDetails;
        window['setDialogMode'] = setDialogMode;
        window['PullUserInfo'] = PullUserInfo;
        window['showEditNameDlg'] = showEditNameDlg;

        
        window['connectDesktop'] = connectDesktop;
        window['deskToggleFull'] = deskToggleFull;
        window['showDesktopSettings'] = showDesktopSettings;
        window['dmousedown'] = dmousedown;
        window['dmouseup'] = dmouseup;
        window['dmousemove'] = dmousemove;
        window['drotate'] = drotate;
        window['sendCAD'] = sendCAD;
        
        
        window['deskToggleFocus'] = deskToggleFocus;
        

        
        window['connectTerminal'] = connectTerminal;
        window['termPaste'] = termPaste;
        window['termSendKey'] = termSendKey;
        

        
        window['showEventDetails'] = showEventDetails;
        window['PullEventLog'] = PullEventLog;
        window['FreezeLog'] = FreezeLog;
        window['ClearLog'] = ClearLog;
        window['eventFilter'] = eventFilter;
        

        
        window['PullAuditLog'] = PullAuditLog;
        

        
        window['showCertDetails'] = showCertDetails;
        window['PullCertificates'] = PullCertificates;
        

        
        window['showWifiStateDlg'] = showWifiStateDlg;
        window['showWifiDetails'] = showWifiDetails;
        window['wifiRemoveButton'] = wifiRemoveButton;
        window['showWifiNewProfile'] = showWifiNewProfile;
        window['updateWifiDialog'] = updateWifiDialog;
        window['wifiRefresh'] = wifiRefresh;
        

        
        window['wsmanQuery'] = wsmanQuery;
        window['wsmanFilter'] = wsmanFilter;
        window['QH'] = QH;
        window['QV'] = QV;
        
        
        
        window['computerConnect'] = computerConnect;
        window['addComputer'] = addComputer;
        window['updateComputerDialog'] = updateComputerDialog;
        window['computerRemove'] = computerRemove;
        
// ###END###{**ClosureAdvancedMode}

        // Get things started
        startup();
    </script>